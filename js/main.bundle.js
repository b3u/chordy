/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const chord = __webpack_require__(/*! tonal-chord */ "./node_modules/tonal-chord/build/es6.js"); // Turn chords into notes
const MidiWriter = __webpack_require__(/*! midi-writer-js */ "./node_modules/midi-writer-js/build/index.js"); // Turn notes into midi events
const MidiPlayer = __webpack_require__(/*! midi-player-js */ "./node_modules/midi-player-js/browser/midiplayer.js"); // Play Midi events
const Soundfont = __webpack_require__(/*! soundfont-player */ "./node_modules/soundfont-player/lib/index.js"); // Attach audio to midi events

function getNotes() {
    let notes = [];

    let cinput = document.querySelector('input[name=chords]').value;
    if(cinput == null) return null

    cinput.split(' ').forEach(c => {
        notes.push(chord.notes(c))
    });

    notes.forEach((item, i)=> {
        notes[i] = item.map(n => n += '4')
    })

    return notes
}

function getDataUri() {
    let track = new MidiWriter.Track();
    track.addEvent(new MidiWriter.ProgramChangeEvent({instrument : 1}));
    
    let noteList = getNotes()
    if(noteList == null){
        return
    }
    
    noteList.forEach(el => {
        var note = new MidiWriter.NoteEvent({pitch: el, duration: 'd2'});
        track.addEvent(note);
    })
    
    var write = new MidiWriter.Writer(track);
    return write.dataUri()
}

function play() {
    let ac = new AudioContext();
    Soundfont.instrument(ac, 'acoustic_grand_piano').then(function (piano) {
        var Player = new MidiPlayer.Player(function(event) {            
            if(event.name == 'Note on') {
                piano.play(event.noteName, ac.currentTime, {gain:event.velocity/100})
            }
        });

        Player.loadDataUri(getDataUri())
        Player.play();
    })
}

document.querySelector('button').addEventListener('click', play);

/***/ }),

/***/ "./node_modules/adsr/index.js":
/*!************************************!*\
  !*** ./node_modules/adsr/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ADSR

function ADSR(audioContext){
  var node = audioContext.createGain()

  var voltage = node._voltage = getVoltage(audioContext)
  var value = scale(voltage)
  var startValue = scale(voltage)
  var endValue = scale(voltage)

  node._startAmount = scale(startValue)
  node._endAmount = scale(endValue)

  node._multiplier = scale(value)
  node._multiplier.connect(node)
  node._startAmount.connect(node)
  node._endAmount.connect(node)

  node.value = value.gain
  node.startValue = startValue.gain
  node.endValue = endValue.gain

  node.startValue.value = 0
  node.endValue.value = 0

  Object.defineProperties(node, props)
  return node
}

var props = {

  attack: { value: 0, writable: true },
  decay: { value: 0, writable: true },
  sustain: { value: 1, writable: true },
  release: {value: 0, writable: true },

  getReleaseDuration: {
    value: function(){
      return this.release
    }
  },

  start: {
    value: function(at){
      var target = this._multiplier.gain
      var startAmount = this._startAmount.gain
      var endAmount = this._endAmount.gain

      this._voltage.start(at)
      this._decayFrom = this._decayFrom = at+this.attack
      this._startedAt = at

      var sustain = this.sustain

      target.cancelScheduledValues(at)
      startAmount.cancelScheduledValues(at)
      endAmount.cancelScheduledValues(at)

      endAmount.setValueAtTime(0, at)

      if (this.attack){
        target.setValueAtTime(0, at)
        target.linearRampToValueAtTime(1, at + this.attack)

        startAmount.setValueAtTime(1, at)
        startAmount.linearRampToValueAtTime(0, at + this.attack)
      } else {
        target.setValueAtTime(1, at)
        startAmount.setValueAtTime(0, at)
      }

      if (this.decay){
        target.setTargetAtTime(sustain, this._decayFrom, getTimeConstant(this.decay))
      }
    }
  },

  stop: {
    value: function(at, isTarget){
      if (isTarget){
        at = at - this.release
      }

      var endTime = at + this.release
      if (this.release){

        var target = this._multiplier.gain
        var startAmount = this._startAmount.gain
        var endAmount = this._endAmount.gain

        target.cancelScheduledValues(at)
        startAmount.cancelScheduledValues(at)
        endAmount.cancelScheduledValues(at)

        var expFalloff = getTimeConstant(this.release)

        // truncate attack (required as linearRamp is removed by cancelScheduledValues)
        if (this.attack && at < this._decayFrom){
          var valueAtTime = getValue(0, 1, this._startedAt, this._decayFrom, at)
          target.linearRampToValueAtTime(valueAtTime, at)
          startAmount.linearRampToValueAtTime(1-valueAtTime, at)
          startAmount.setTargetAtTime(0, at, expFalloff)
        }

        endAmount.setTargetAtTime(1, at, expFalloff)
        target.setTargetAtTime(0, at, expFalloff)
      }

      this._voltage.stop(endTime)
      return endTime
    }
  },

  onended: {
    get: function(){
      return this._voltage.onended
    },
    set: function(value){
      this._voltage.onended = value
    }
  }

}

var flat = new Float32Array([1,1])
function getVoltage(context){
  var voltage = context.createBufferSource()
  var buffer = context.createBuffer(1, 2, context.sampleRate)
  buffer.getChannelData(0).set(flat)
  voltage.buffer = buffer
  voltage.loop = true
  return voltage
}

function scale(node){
  var gain = node.context.createGain()
  node.connect(gain)
  return gain
}

function getTimeConstant(time){
  return Math.log(time+1)/Math.log(100)
}

function getValue(start, end, fromTime, toTime, at){
  var difference = end - start
  var time = toTime - fromTime
  var truncateTime = at - fromTime
  var phase = truncateTime / time
  var value = start + phase * difference

  if (value <= start) {
      value = start
  }
  if (value >= end) {
      value = end
  }

  return value
}


/***/ }),

/***/ "./node_modules/audio-loader/lib/base64.js":
/*!*************************************************!*\
  !*** ./node_modules/audio-loader/lib/base64.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// DECODE UTILITIES
function b64ToUint6 (nChr) {
  return nChr > 64 && nChr < 91 ? nChr - 65
    : nChr > 96 && nChr < 123 ? nChr - 71
    : nChr > 47 && nChr < 58 ? nChr + 4
    : nChr === 43 ? 62
    : nChr === 47 ? 63
    : 0
}

// Decode Base64 to Uint8Array
// ---------------------------
function decode (sBase64, nBlocksSize) {
  var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, '')
  var nInLen = sB64Enc.length
  var nOutLen = nBlocksSize
    ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize
    : nInLen * 3 + 1 >> 2
  var taBytes = new Uint8Array(nOutLen)

  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
    nMod4 = nInIdx & 3
    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4
    if (nMod4 === 3 || nInLen - nInIdx === 1) {
      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255
      }
      nUint24 = 0
    }
  }
  return taBytes
}

module.exports = { decode: decode }


/***/ }),

/***/ "./node_modules/audio-loader/lib/fetch.js":
/*!************************************************!*\
  !*** ./node_modules/audio-loader/lib/fetch.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global XMLHttpRequest */


/**
 * Given a url and a return type, returns a promise to the content of the url
 * Basically it wraps a XMLHttpRequest into a Promise
 *
 * @param {String} url
 * @param {String} type - can be 'text' or 'arraybuffer'
 * @return {Promise}
 */
module.exports = function (url, type) {
  return new Promise(function (done, reject) {
    var req = new XMLHttpRequest()
    if (type) req.responseType = type

    req.open('GET', url)
    req.onload = function () {
      req.status === 200 ? done(req.response) : reject(Error(req.statusText))
    }
    req.onerror = function () { reject(Error('Network Error')) }
    req.send()
  })
}


/***/ }),

/***/ "./node_modules/audio-loader/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/audio-loader/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/audio-loader/lib/base64.js")
var fetch = __webpack_require__(/*! ./fetch */ "./node_modules/audio-loader/lib/fetch.js")

// Given a regex, return a function that test if against a string
function fromRegex (r) {
  return function (o) { return typeof o === 'string' && r.test(o) }
}
// Try to apply a prefix to a name
function prefix (pre, name) {
  return typeof pre === 'string' ? pre + name
    : typeof pre === 'function' ? pre(name)
    : name
}

/**
 * Load one or more audio files
 *
 *
 * Possible option keys:
 *
 * - __from__ {Function|String}: a function or string to convert from file names to urls.
 * If is a string it will be prefixed to the name:
 * `load(ac, 'snare.mp3', { from: 'http://audio.net/samples/' })`
 * If it's a function it receives the file name and should return the url as string.
 * - __only__ {Array} - when loading objects, if provided, only the given keys
 * will be included in the decoded object:
 * `load(ac, 'piano.json', { only: ['C2', 'D2'] })`
 *
 * @param {AudioContext} ac - the audio context
 * @param {Object} source - the object to be loaded
 * @param {Object} options - (Optional) the load options for that object
 * @param {Object} defaultValue - (Optional) the default value to return as
 * in a promise if not valid loader found
 */
function load (ac, source, options, defVal) {
  var loader =
    // Basic audio loading
      isArrayBuffer(source) ? loadArrayBuffer
    : isAudioFileName(source) ? loadAudioFile
    : isPromise(source) ? loadPromise
    // Compound objects
    : isArray(source) ? loadArrayData
    : isObject(source) ? loadObjectData
    : isJsonFileName(source) ? loadJsonFile
    // Base64 encoded audio
    : isBase64Audio(source) ? loadBase64Audio
    : isJsFileName(source) ? loadMidiJSFile
    : null

  var opts = options || {}
  return loader ? loader(ac, source, opts)
    : defVal ? Promise.resolve(defVal)
    : Promise.reject('Source not valid (' + source + ')')
}
load.fetch = fetch

// BASIC AUDIO LOADING
// ===================

// Load (decode) an array buffer
function isArrayBuffer (o) { return o instanceof ArrayBuffer }
function loadArrayBuffer (ac, array, options) {
  return new Promise(function (done, reject) {
    ac.decodeAudioData(array,
      function (buffer) { done(buffer) },
      function () { reject("Can't decode audio data (" + array.slice(0, 30) + '...)') }
    )
  })
}

// Load an audio filename
var isAudioFileName = fromRegex(/\.(mp3|wav|ogg)(\?.*)?$/i)
function loadAudioFile (ac, name, options) {
  var url = prefix(options.from, name)
  return load(ac, load.fetch(url, 'arraybuffer'), options)
}

// Load the result of a promise
function isPromise (o) { return o && typeof o.then === 'function' }
function loadPromise (ac, promise, options) {
  return promise.then(function (value) {
    return load(ac, value, options)
  })
}

// COMPOUND OBJECTS
// ================

// Try to load all the items of an array
var isArray = Array.isArray
function loadArrayData (ac, array, options) {
  return Promise.all(array.map(function (data) {
    return load(ac, data, options, data)
  }))
}

// Try to load all the values of a key/value object
function isObject (o) { return o && typeof o === 'object' }
function loadObjectData (ac, obj, options) {
  var dest = {}
  var promises = Object.keys(obj).map(function (key) {
    if (options.only && options.only.indexOf(key) === -1) return null
    var value = obj[key]
    return load(ac, value, options, value).then(function (audio) {
      dest[key] = audio
    })
  })
  return Promise.all(promises).then(function () { return dest })
}

// Load the content of a JSON file
var isJsonFileName = fromRegex(/\.json(\?.*)?$/i)
function loadJsonFile (ac, name, options) {
  var url = prefix(options.from, name)
  return load(ac, load.fetch(url, 'text').then(JSON.parse), options)
}

// BASE64 ENCODED FORMATS
// ======================

// Load strings with Base64 encoded audio
var isBase64Audio = fromRegex(/^data:audio/)
function loadBase64Audio (ac, source, options) {
  var i = source.indexOf(',')
  return load(ac, base64.decode(source.slice(i + 1)).buffer, options)
}

// Load .js files with MidiJS soundfont prerendered audio
var isJsFileName = fromRegex(/\.js(\?.*)?$/i)
function loadMidiJSFile (ac, name, options) {
  var url = prefix(options.from, name)
  return load(ac, load.fetch(url, 'text').then(midiJsToJson), options)
}

// convert a MIDI.js javascript soundfont file to json
function midiJsToJson (data) {
  var begin = data.indexOf('MIDI.Soundfont.')
  if (begin < 0) throw Error('Invalid MIDI.js Soundfont format')
  begin = data.indexOf('=', begin) + 2
  var end = data.lastIndexOf(',')
  return JSON.parse(data.slice(begin, end) + '}')
}

if ( true && module.exports) module.exports = load
if (typeof window !== 'undefined') window.loadAudio = load


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/midi-player-js/browser/midiplayer.js":
/*!***********************************************************!*\
  !*** ./node_modules/midi-player-js/browser/midiplayer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":1,"ieee754":3}],3:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],4:[function(require,module,exports){
'use strict';

/**
 * Constants used in player.
 */
var Constants = {
	VERSION: '2.0.5',
	NOTES: [],
	CIRCLE_OF_FOURTHS: ['C', 'F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb', 'Fb', 'Bbb', 'Ebb', 'Abb'],
	CIRCLE_OF_FIFTHS: ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#']
};

// Builds notes object for reference against binary values.
var allNotes = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']];
var counter = 0;

// All available octaves.

var _loop = function _loop(i) {
	allNotes.forEach(function (noteGroup) {
		noteGroup.forEach(function (note) {
			return Constants.NOTES[counter] = note + i;
		});
		counter++;
	});
};

for (var i = -1; i <= 9; i++) {
	_loop(i);
}

exports.Constants = Constants;

},{}],5:[function(require,module,exports){
"use strict";

var Player = require("./player");
var Utils = require("./utils");
var Constants = require("./constants");

module.exports = {
    Player: Player.Player,
    Utils: Utils.Utils,
    Constants: Constants.Constants
};

},{"./constants":4,"./player":6,"./utils":8}],6:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Utils = require("./utils").Utils;
var Track = require("./track").Track;

// Polyfill Uint8Array.forEach: Doesn't exist on Safari <10
if (!Uint8Array.prototype.forEach) {
	Object.defineProperty(Uint8Array.prototype, 'forEach', {
		value: Array.prototype.forEach
	});
}

/**
 * Main player class.  Contains methods to load files, start, stop.
 * @param {function} - Callback to fire for each MIDI event.  Can also be added with on('midiEvent', fn)
 * @param {array} - Array buffer of MIDI file (optional).
 */

var Player = function () {
	function Player(eventHandler, buffer) {
		_classCallCheck(this, Player);

		this.sampleRate = 5; // milliseconds
		this.startTime = 0;
		this.buffer = buffer || null;
		this.division;
		this.format;
		this.setIntervalId = false;
		this.tracks = [];
		this.instruments = [];
		this.defaultTempo = 120;
		this.tempo = null;
		this.startTick = 0;
		this.tick = 0;
		this.lastTick = null;
		this.inLoop = false;
		this.totalTicks = 0;
		this.events = [];
		this.totalEvents = 0;
		this.eventListeners = {};

		if (typeof eventHandler === 'function') this.on('midiEvent', eventHandler);
	}

	/**
  * Load a file into the player (Node.js only).
  * @param {string} path - Path of file.
  * @return {Player}
  */


	_createClass(Player, [{
		key: "loadFile",
		value: function loadFile(path) {
			var fs = require('fs');
			this.buffer = fs.readFileSync(path);
			return this.fileLoaded();
		}

		/**
   * Load an array buffer into the player.
   * @param {array} arrayBuffer - Array buffer of file to be loaded.
   * @return {Player}
   */

	}, {
		key: "loadArrayBuffer",
		value: function loadArrayBuffer(arrayBuffer) {
			this.buffer = new Uint8Array(arrayBuffer);
			return this.fileLoaded();
		}

		/**
   * Load a data URI into the player.
   * @param {string} dataUri - Data URI to be loaded.
   * @return {Player}
   */

	}, {
		key: "loadDataUri",
		value: function loadDataUri(dataUri) {
			// convert base64 to raw binary data held in a string.
			// doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
			var byteString = Utils.atob(dataUri.split(',')[1]);

			// write the bytes of the string to an ArrayBuffer
			var ia = new Uint8Array(byteString.length);
			for (var i = 0; i < byteString.length; i++) {
				ia[i] = byteString.charCodeAt(i);
			}

			this.buffer = ia;
			return this.fileLoaded();
		}

		/**
   * Get filesize of loaded file in number of bytes.
   * @return {number} - The filesize.
   */

	}, {
		key: "getFilesize",
		value: function getFilesize() {
			return this.buffer ? this.buffer.length : 0;
		}

		/**
   * Sets default tempo, parses file for necessary information, and does a dry run to calculate total length.
   * Populates this.events & this.totalTicks.
   * @return {Player}
   */

	}, {
		key: "fileLoaded",
		value: function fileLoaded() {
			if (!this.validate()) throw 'Invalid MIDI file; should start with MThd';
			return this.setTempo(this.defaultTempo).getDivision().getFormat().getTracks().dryRun();
		}

		/**
   * Validates file using simple means - first four bytes should == MThd.
   * @return {boolean}
   */

	}, {
		key: "validate",
		value: function validate() {
			return Utils.bytesToLetters(this.buffer.subarray(0, 4)) === 'MThd';
		}

		/**
   * Gets MIDI file format for loaded file.
   * @return {Player}
   */

	}, {
		key: "getFormat",
		value: function getFormat() {
			/*
   MIDI files come in 3 variations:
   Format 0 which contain a single track
   Format 1 which contain one or more simultaneous tracks
   (ie all tracks are to be played simultaneously).
   Format 2 which contain one or more independant tracks
   (ie each track is to be played independantly of the others).
   return Utils.bytesToNumber(this.buffer.subarray(8, 10));
   */

			this.format = Utils.bytesToNumber(this.buffer.subarray(8, 10));
			return this;
		}

		/**
   * Parses out tracks, places them in this.tracks and initializes this.pointers
   * @return {Player}
   */

	}, {
		key: "getTracks",
		value: function getTracks() {
			this.tracks = [];
			var trackOffset = 0;
			while (trackOffset < this.buffer.length) {
				if (Utils.bytesToLetters(this.buffer.subarray(trackOffset, trackOffset + 4)) == 'MTrk') {
					var trackLength = Utils.bytesToNumber(this.buffer.subarray(trackOffset + 4, trackOffset + 8));
					this.tracks.push(new Track(this.tracks.length, this.buffer.subarray(trackOffset + 8, trackOffset + 8 + trackLength)));
				}

				trackOffset += Utils.bytesToNumber(this.buffer.subarray(trackOffset + 4, trackOffset + 8)) + 8;
			}
			return this;
		}

		/**
   * Enables a track for playing.
   * @param {number} trackNumber - Track number
   * @return {Player}
   */

	}, {
		key: "enableTrack",
		value: function enableTrack(trackNumber) {
			this.tracks[trackNumber - 1].enable();
			return this;
		}

		/**
   * Disables a track for playing.
   * @param {number} - Track number
   * @return {Player}
   */

	}, {
		key: "disableTrack",
		value: function disableTrack(trackNumber) {
			this.tracks[trackNumber - 1].disable();
			return this;
		}

		/**
   * Gets quarter note division of loaded MIDI file.
   * @return {Player}
   */

	}, {
		key: "getDivision",
		value: function getDivision() {
			this.division = Utils.bytesToNumber(this.buffer.subarray(12, 14));
			return this;
		}

		/**
   * The main play loop.
   * @param {boolean} - Indicates whether or not this is being called simply for parsing purposes.  Disregards timing if so.
   * @return {undefined}
   */

	}, {
		key: "playLoop",
		value: function playLoop(dryRun) {
			if (!this.inLoop) {
				this.inLoop = true;
				this.tick = this.getCurrentTick();

				this.tracks.forEach(function (track) {
					// Handle next event
					if (!dryRun && this.endOfFile()) {
						//console.log('end of file')
						this.triggerPlayerEvent('endOfFile');
						this.stop();
					} else {
						var event = track.handleEvent(this.tick, dryRun);

						if (dryRun && event) {
							if (event.hasOwnProperty('name') && event.name === 'Set Tempo') {
								// Grab tempo if available.
								this.defaultTempo = event.data;
								this.setTempo(event.data);
							}
							if (event.hasOwnProperty('name') && event.name === 'Program Change') {
								if (!this.instruments.includes(event.value)) {
									this.instruments.push(event.value);
								}
							}
						} else if (event) this.emitEvent(event);
					}
				}, this);

				if (!dryRun) this.triggerPlayerEvent('playing', { tick: this.tick });
				this.inLoop = false;
			}
		}

		/**
   * Setter for tempo.
   * @param {number} - Tempo in bpm (defaults to 120)
   */

	}, {
		key: "setTempo",
		value: function setTempo(tempo) {
			this.tempo = tempo;
			return this;
		}

		/**
   * Setter for startTime.
   * @param {number} - UTC timestamp
   */

	}, {
		key: "setStartTime",
		value: function setStartTime(startTime) {
			this.startTime = startTime;
		}

		/**
   * Start playing loaded MIDI file if not already playing.
   * @return {Player}
   */

	}, {
		key: "play",
		value: function play() {
			if (this.isPlaying()) throw 'Already playing...';

			// Initialize
			if (!this.startTime) this.startTime = new Date().getTime();

			// Start play loop
			//window.requestAnimationFrame(this.playLoop.bind(this));
			this.setIntervalId = setInterval(this.playLoop.bind(this), this.sampleRate);

			return this;
		}

		/**
   * Pauses playback if playing.
   * @return {Player}
   */

	}, {
		key: "pause",
		value: function pause() {
			clearInterval(this.setIntervalId);
			this.setIntervalId = false;
			this.startTick = this.tick;
			this.startTime = 0;
			return this;
		}

		/**
   * Stops playback if playing.
   * @return {Player}
   */

	}, {
		key: "stop",
		value: function stop() {
			clearInterval(this.setIntervalId);
			this.setIntervalId = false;
			this.startTick = 0;
			this.startTime = 0;
			this.resetTracks();
			return this;
		}

		/**
   * Skips player pointer to specified tick.
   * @param {number} - Tick to skip to.
   * @return {Player}
   */

	}, {
		key: "skipToTick",
		value: function skipToTick(tick) {
			this.stop();
			this.startTick = tick;

			// Need to set track event indexes to the nearest possible event to the specified tick.
			this.tracks.forEach(function (track) {
				track.setEventIndexByTick(tick);
			});
			return this;
		}

		/**
   * Skips player pointer to specified percentage.
   * @param {number} - Percent value in integer format.
   * @return {Player}
   */

	}, {
		key: "skipToPercent",
		value: function skipToPercent(percent) {
			if (percent < 0 || percent > 100) throw "Percent must be number between 1 and 100.";
			this.skipToTick(Math.round(percent / 100 * this.totalTicks));
			return this;
		}

		/**
   * Skips player pointer to specified seconds.
   * @param {number} - Seconds to skip to.
   * @return {Player}
   */

	}, {
		key: "skipToSeconds",
		value: function skipToSeconds(seconds) {
			var songTime = this.getSongTime();
			if (seconds < 0 || seconds > songTime) throw seconds + " seconds not within song time of " + songTime;
			this.skipToPercent(seconds / songTime * 100);
			return this;
		}

		/**
   * Checks if player is playing
   * @return {boolean}
   */

	}, {
		key: "isPlaying",
		value: function isPlaying() {
			return this.setIntervalId > 0 || _typeof(this.setIntervalId) === 'object';
		}

		/**
   * Plays the loaded MIDI file without regard for timing and saves events in this.events.  Essentially used as a parser.
   * @return {Player}
   */

	}, {
		key: "dryRun",
		value: function dryRun() {
			// Reset tracks first
			this.resetTracks();
			while (!this.endOfFile()) {
				this.playLoop(true);
			}this.events = this.getEvents();
			this.totalEvents = this.getTotalEvents();
			this.totalTicks = this.getTotalTicks();
			this.startTick = 0;
			this.startTime = 0;

			// Leave tracks in pristine condish
			this.resetTracks();

			//console.log('Song time: ' + this.getSongTime() + ' seconds / ' + this.totalTicks + ' ticks.');

			this.triggerPlayerEvent('fileLoaded', this);
			return this;
		}

		/**
   * Resets play pointers for all tracks.
   * @return {Player}
   */

	}, {
		key: "resetTracks",
		value: function resetTracks() {
			this.tracks.forEach(function (track) {
				return track.reset();
			});
			return this;
		}

		/**
   * Gets an array of events grouped by track.
   * @return {array}
   */

	}, {
		key: "getEvents",
		value: function getEvents() {
			return this.tracks.map(function (track) {
				return track.events;
			});
		}

		/**
   * Gets total number of ticks in the loaded MIDI file.
   * @return {number}
   */

	}, {
		key: "getTotalTicks",
		value: function getTotalTicks() {
			return Math.max.apply(null, this.tracks.map(function (track) {
				return track.delta;
			}));
		}

		/**
   * Gets total number of events in the loaded MIDI file.
   * @return {number}
   */

	}, {
		key: "getTotalEvents",
		value: function getTotalEvents() {
			return this.tracks.reduce(function (a, b) {
				return { events: { length: a.events.length + b.events.length } };
			}, { events: { length: 0 } }).events.length;
		}

		/**
   * Gets song duration in seconds.
   * @return {number}
   */

	}, {
		key: "getSongTime",
		value: function getSongTime() {
			return this.totalTicks / this.division / this.tempo * 60;
		}

		/**
   * Gets remaining number of seconds in playback.
   * @return {number}
   */

	}, {
		key: "getSongTimeRemaining",
		value: function getSongTimeRemaining() {
			return Math.round((this.totalTicks - this.getCurrentTick()) / this.division / this.tempo * 60);
		}

		/**
   * Gets remaining percent of playback.
   * @return {number}
   */

	}, {
		key: "getSongPercentRemaining",
		value: function getSongPercentRemaining() {
			return Math.round(this.getSongTimeRemaining() / this.getSongTime() * 100);
		}

		/**
   * Number of bytes processed in the loaded MIDI file.
   * @return {number}
   */

	}, {
		key: "bytesProcessed",
		value: function bytesProcessed() {
			// Currently assume header chunk is strictly 14 bytes
			return 14 + this.tracks.length * 8 + this.tracks.reduce(function (a, b) {
				return { pointer: a.pointer + b.pointer };
			}, { pointer: 0 }).pointer;
		}

		/**
   * Number of events played up to this point.
   * @return {number}
   */

	}, {
		key: "eventsPlayed",
		value: function eventsPlayed() {
			return this.tracks.reduce(function (a, b) {
				return { eventIndex: a.eventIndex + b.eventIndex };
			}, { eventIndex: 0 }).eventIndex;
		}

		/**
   * Determines if the player pointer has reached the end of the loaded MIDI file.
   * Used in two ways:
   * 1. If playing result is based on loaded JSON events.
   * 2. If parsing (dryRun) it's based on the actual buffer length vs bytes processed.
   * @return {boolean}
   */

	}, {
		key: "endOfFile",
		value: function endOfFile() {
			if (this.isPlaying()) {
				return this.totalTicks - this.tick <= 0;
			}

			return this.bytesProcessed() == this.buffer.length;
		}

		/**
   * Gets the current tick number in playback.
   * @return {number}
   */

	}, {
		key: "getCurrentTick",
		value: function getCurrentTick() {
			if (!this.startTime && this.tick) return this.startTick;else if (!this.startTime) return 0;
			return Math.round((new Date().getTime() - this.startTime) / 1000 * (this.division * (this.tempo / 60))) + this.startTick;
		}

		/**
   * Sends MIDI event out to listener.
   * @param {object}
   * @return {Player}
   */

	}, {
		key: "emitEvent",
		value: function emitEvent(event) {
			this.triggerPlayerEvent('midiEvent', event);
			return this;
		}

		/**
   * Subscribes events to listeners
   * @param {string} - Name of event to subscribe to.
   * @param {function} - Callback to fire when event is broadcast.
   * @return {Player}
   */

	}, {
		key: "on",
		value: function on(playerEvent, fn) {
			if (!this.eventListeners.hasOwnProperty(playerEvent)) this.eventListeners[playerEvent] = [];
			this.eventListeners[playerEvent].push(fn);
			return this;
		}

		/**
   * Broadcasts event to trigger subscribed callbacks.
   * @param {string} - Name of event.
   * @param {object} - Data to be passed to subscriber callback.
   * @return {Player}
   */

	}, {
		key: "triggerPlayerEvent",
		value: function triggerPlayerEvent(playerEvent, data) {
			if (this.eventListeners.hasOwnProperty(playerEvent)) this.eventListeners[playerEvent].forEach(function (fn) {
				return fn(data || {});
			});
			return this;
		}
	}]);

	return Player;
}();

exports.Player = Player;

},{"./track":7,"./utils":8,"fs":"fs"}],7:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Constants = require("./constants").Constants;
var Utils = require("./utils").Utils;

/**
 * Class representing a track.  Contains methods for parsing events and keeping track of pointer.
 */

var Track = function () {
	function Track(index, data) {
		_classCallCheck(this, Track);

		this.enabled = true;
		this.eventIndex = 0;
		this.pointer = 0;
		this.lastTick = 0;
		this.lastStatus = null;
		this.index = index;
		this.data = data;
		this.delta = 0;
		this.runningDelta = 0;
		this.events = [];
	}

	/**
  * Resets all stateful track informaion used during playback.
  * @return {Track}
  */


	_createClass(Track, [{
		key: "reset",
		value: function reset() {
			this.enabled = true;
			this.eventIndex = 0;
			this.pointer = 0;
			this.lastTick = 0;
			this.lastStatus = null;
			this.delta = 0;
			this.runningDelta = 0;
			return this;
		}

		/**
   * Sets this track to be enabled during playback.
   * @return {Track}
   */

	}, {
		key: "enable",
		value: function enable() {
			this.enabled = true;
			return this;
		}

		/**
   * Sets this track to be disabled during playback.
   * @return {Track}
   */

	}, {
		key: "disable",
		value: function disable() {
			this.enabled = false;
			return this;
		}

		/**
   * Sets the track event index to the nearest event to the given tick.
   * @param {number} tick
   * @return {Track}
   */

	}, {
		key: "setEventIndexByTick",
		value: function setEventIndexByTick(tick) {
			tick = tick || 0;

			for (var i in this.events) {
				if (this.events[i].tick >= tick) {
					this.eventIndex = i;
					return this;
				}
			}
		}

		/**
   * Gets byte located at pointer position.
   * @return {number}
   */

	}, {
		key: "getCurrentByte",
		value: function getCurrentByte() {
			return this.data[this.pointer];
		}

		/**
   * Gets count of delta bytes and current pointer position.
   * @return {number}
   */

	}, {
		key: "getDeltaByteCount",
		value: function getDeltaByteCount() {
			// Get byte count of delta VLV
			// http://www.ccarh.org/courses/253/handout/vlv/
			// If byte is greater or equal to 80h (128 decimal) then the next byte
			// is also part of the VLV,
			// else byte is the last byte in a VLV.
			var currentByte = this.getCurrentByte();
			var byteCount = 1;

			while (currentByte >= 128) {
				currentByte = this.data[this.pointer + byteCount];
				byteCount++;
			}

			return byteCount;
		}

		/**
   * Get delta value at current pointer position.
   * @return {number}
   */

	}, {
		key: "getDelta",
		value: function getDelta() {
			return Utils.readVarInt(this.data.subarray(this.pointer, this.pointer + this.getDeltaByteCount()));
		}

		/**
   * Handles event within a given track starting at specified index
   * @param {number} currentTick
   * @param {boolean} dryRun - If true events will be parsed and returned regardless of time.
   */

	}, {
		key: "handleEvent",
		value: function handleEvent(currentTick, dryRun) {
			dryRun = dryRun || false;

			if (dryRun) {
				var elapsedTicks = currentTick - this.lastTick;
				var delta = this.getDelta();
				var eventReady = elapsedTicks >= delta;

				if (this.pointer < this.data.length && (dryRun || eventReady)) {
					var _event = this.parseEvent();
					if (this.enabled) return _event;
					// Recursively call this function for each event ahead that has 0 delta time?
				}
			} else {
				// Let's actually play the MIDI from the generated JSON events created by the dry run.
				if (this.events[this.eventIndex] && this.events[this.eventIndex].tick <= currentTick) {
					this.eventIndex++;
					if (this.enabled) return this.events[this.eventIndex - 1];
				}
			}

			return null;
		}

		/**
   * Get string data from event.
   * @param {number} eventStartIndex
   * @return {string}
   */

	}, {
		key: "getStringData",
		value: function getStringData(eventStartIndex) {
			var currentByte = this.pointer;
			var byteCount = 1;
			var length = Utils.readVarInt(this.data.subarray(eventStartIndex + 2, eventStartIndex + 2 + byteCount));
			var stringLength = length;

			return Utils.bytesToLetters(this.data.subarray(eventStartIndex + byteCount + 2, eventStartIndex + byteCount + length + 2));
		}

		/**
   * Parses event into JSON and advances pointer for the track
   * @return {object}
   */

	}, {
		key: "parseEvent",
		value: function parseEvent() {
			var eventStartIndex = this.pointer + this.getDeltaByteCount();
			var eventJson = {};
			var deltaByteCount = this.getDeltaByteCount();
			eventJson.track = this.index + 1;
			eventJson.delta = this.getDelta();
			this.lastTick = this.lastTick + eventJson.delta;
			this.runningDelta += eventJson.delta;
			eventJson.tick = this.runningDelta;
			eventJson.byteIndex = this.pointer;

			//eventJson.raw = event;
			if (this.data[eventStartIndex] == 0xff) {
				// Meta Event

				// If this is a meta event we should emit the data and immediately move to the next event
				// otherwise if we let it run through the next cycle a slight delay will accumulate if multiple tracks
				// are being played simultaneously

				switch (this.data[eventStartIndex + 1]) {
					case 0x00:
						// Sequence Number
						eventJson.name = 'Sequence Number';
						break;
					case 0x01:
						// Text Event
						eventJson.name = 'Text Event';
						eventJson.string = this.getStringData(eventStartIndex);
						break;
					case 0x02:
						// Copyright Notice
						eventJson.name = 'Copyright Notice';
						break;
					case 0x03:
						// Sequence/Track Name
						eventJson.name = 'Sequence/Track Name';
						eventJson.string = this.getStringData(eventStartIndex);
						break;
					case 0x04:
						// Instrument Name
						eventJson.name = 'Instrument Name';
						eventJson.string = this.getStringData(eventStartIndex);
						break;
					case 0x05:
						// Lyric
						eventJson.name = 'Lyric';
						eventJson.string = this.getStringData(eventStartIndex);
						break;
					case 0x06:
						// Marker
						eventJson.name = 'Marker';
						break;
					case 0x07:
						// Cue Point
						eventJson.name = 'Cue Point';
						eventJson.string = this.getStringData(eventStartIndex);
						break;
					case 0x09:
						// Device Name
						eventJson.name = 'Device Name';
						eventJson.string = this.getStringData(eventStartIndex);
						break;
					case 0x20:
						// MIDI Channel Prefix
						eventJson.name = 'MIDI Channel Prefix';
						break;
					case 0x21:
						// MIDI Port
						eventJson.name = 'MIDI Port';
						eventJson.data = Utils.bytesToNumber([this.data[eventStartIndex + 3]]);
						break;
					case 0x2F:
						// End of Track
						eventJson.name = 'End of Track';
						break;
					case 0x51:
						// Set Tempo
						eventJson.name = 'Set Tempo';
						eventJson.data = Math.round(60000000 / Utils.bytesToNumber(this.data.subarray(eventStartIndex + 3, eventStartIndex + 6)));
						this.tempo = eventJson.data;
						break;
					case 0x54:
						// SMTPE Offset
						eventJson.name = 'SMTPE Offset';
						break;
					case 0x58:
						// Time Signature
						// FF 58 04 nn dd cc bb
						eventJson.name = 'Time Signature';
						eventJson.data = this.data.subarray(eventStartIndex + 3, eventStartIndex + 7);
						eventJson.timeSignature = "" + eventJson.data[0] + "/" + Math.pow(2, eventJson.data[1]);
						break;
					case 0x59:
						// Key Signature
						// FF 59 02 sf mi
						eventJson.name = 'Key Signature';
						eventJson.data = this.data.subarray(eventStartIndex + 3, eventStartIndex + 5);

						if (eventJson.data[0] >= 0) {
							eventJson.keySignature = Constants.CIRCLE_OF_FIFTHS[eventJson.data[0]];
						} else if (eventJson.data[0] < 0) {
							eventJson.keySignature = Constants.CIRCLE_OF_FOURTHS[Math.abs(eventJson.data[0])];
						}

						if (eventJson.data[1] == 0) {
							eventJson.keySignature += " Major";
						} else if (eventJson.data[1] == 1) {
							eventJson.keySignature += " Minor";
						}

						break;
					case 0x7F:
						// Sequencer-Specific Meta-event
						eventJson.name = 'Sequencer-Specific Meta-event';
						break;
					default:
						eventJson.name = 'Unknown: ' + this.data[eventStartIndex + 1].toString(16);
						break;
				}

				var length = this.data[this.pointer + deltaByteCount + 2];
				// Some meta events will have vlv that needs to be handled

				this.pointer += deltaByteCount + 3 + length;
			} else if (this.data[eventStartIndex] == 0xf0) {
				// Sysex
				eventJson.name = 'Sysex';
				var length = this.data[this.pointer + deltaByteCount + 1];
				this.pointer += deltaByteCount + 2 + length;
			} else {
				// Voice event
				if (this.data[eventStartIndex] < 0x80) {
					// Running status
					eventJson.running = true;
					eventJson.noteNumber = this.data[eventStartIndex];
					eventJson.noteName = Constants.NOTES[this.data[eventStartIndex]];
					eventJson.velocity = this.data[eventStartIndex + 1];

					if (this.lastStatus <= 0x8f) {
						eventJson.name = 'Note off';
						eventJson.channel = this.lastStatus - 0x80 + 1;
					} else if (this.lastStatus <= 0x9f) {
						eventJson.name = 'Note on';
						eventJson.channel = this.lastStatus - 0x90 + 1;
					}

					this.pointer += deltaByteCount + 2;
				} else {
					this.lastStatus = this.data[eventStartIndex];

					if (this.data[eventStartIndex] <= 0x8f) {
						// Note off
						eventJson.name = 'Note off';
						eventJson.channel = this.lastStatus - 0x80 + 1;
						eventJson.noteNumber = this.data[eventStartIndex + 1];
						eventJson.noteName = Constants.NOTES[this.data[eventStartIndex + 1]];
						eventJson.velocity = Math.round(this.data[eventStartIndex + 2] / 127 * 100);
						this.pointer += deltaByteCount + 3;
					} else if (this.data[eventStartIndex] <= 0x9f) {
						// Note on
						eventJson.name = 'Note on';
						eventJson.channel = this.lastStatus - 0x90 + 1;
						eventJson.noteNumber = this.data[eventStartIndex + 1];
						eventJson.noteName = Constants.NOTES[this.data[eventStartIndex + 1]];
						eventJson.velocity = Math.round(this.data[eventStartIndex + 2] / 127 * 100);
						this.pointer += deltaByteCount + 3;
					} else if (this.data[eventStartIndex] <= 0xaf) {
						// Polyphonic Key Pressure
						eventJson.name = 'Polyphonic Key Pressure';
						eventJson.channel = this.lastStatus - 0xa0 + 1;
						eventJson.note = Constants.NOTES[this.data[eventStartIndex + 1]];
						eventJson.pressure = event[2];
						this.pointer += deltaByteCount + 3;
					} else if (this.data[eventStartIndex] <= 0xbf) {
						// Controller Change
						eventJson.name = 'Controller Change';
						eventJson.channel = this.lastStatus - 0xb0 + 1;
						eventJson.number = this.data[eventStartIndex + 1];
						eventJson.value = this.data[eventStartIndex + 2];
						this.pointer += deltaByteCount + 3;
					} else if (this.data[eventStartIndex] <= 0xcf) {
						// Program Change
						eventJson.name = 'Program Change';
						eventJson.channel = this.lastStatus - 0xc0 + 1;
						eventJson.value = this.data[eventStartIndex + 1];
						this.pointer += deltaByteCount + 2;
					} else if (this.data[eventStartIndex] <= 0xdf) {
						// Channel Key Pressure
						eventJson.name = 'Channel Key Pressure';
						eventJson.channel = this.lastStatus - 0xd0 + 1;
						this.pointer += deltaByteCount + 2;
					} else if (this.data[eventStartIndex] <= 0xef) {
						// Pitch Bend
						eventJson.name = 'Pitch Bend';
						eventJson.channel = this.lastStatus - 0xe0 + 1;
						this.pointer += deltaByteCount + 3;
					} else {
						eventJson.name = 'Unknown.  Pointer: ' + this.pointer.toString() + ' ' + eventStartIndex.toString() + ' ' + this.data.length;
					}
				}
			}

			this.delta += eventJson.delta;
			this.events.push(eventJson);

			return eventJson;
		}

		/**
   * Returns true if pointer has reached the end of the track.
   * @param {boolean}
   */

	}, {
		key: "endOfTrack",
		value: function endOfTrack() {
			if (this.data[this.pointer + 1] == 0xff && this.data[this.pointer + 2] == 0x2f && this.data[this.pointer + 3] == 0x00) {
				return true;
			}

			return false;
		}
	}]);

	return Track;
}();

module.exports.Track = Track;

},{"./constants":4,"./utils":8}],8:[function(require,module,exports){
(function (Buffer){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains misc static utility methods.
 */
var Utils = function () {
	function Utils() {
		_classCallCheck(this, Utils);
	}

	_createClass(Utils, null, [{
		key: 'byteToHex',


		/**
   * Converts a single byte to a hex string.
   * @param {number} byte
   * @return {string}
   */
		value: function byteToHex(byte) {
			// Ensure hex string always has two chars
			return ('0' + byte.toString(16)).slice(-2);
		}

		/**
   * Converts an array of bytes to a hex string.
   * @param {array} byteArray
   * @return {string}
   */

	}, {
		key: 'bytesToHex',
		value: function bytesToHex(byteArray) {
			var hex = [];
			byteArray.forEach(function (byte) {
				return hex.push(Utils.byteToHex(byte));
			});
			return hex.join('');
		}

		/**
   * Converts a hex string to a number.
   * @param {string} hexString
   * @return {number}
   */

	}, {
		key: 'hexToNumber',
		value: function hexToNumber(hexString) {
			return parseInt(hexString, 16);
		}

		/**
   * Converts an array of bytes to a number.
   * @param {array} byteArray
   * @return {number}
   */

	}, {
		key: 'bytesToNumber',
		value: function bytesToNumber(byteArray) {
			return Utils.hexToNumber(Utils.bytesToHex(byteArray));
		}

		/**
   * Converts an array of bytes to letters.
   * @param {array} byteArray
   * @return {string}
   */

	}, {
		key: 'bytesToLetters',
		value: function bytesToLetters(byteArray) {
			var letters = [];
			byteArray.forEach(function (byte) {
				return letters.push(String.fromCharCode(byte));
			});
			return letters.join('');
		}

		/**
   * Converts a decimal to it's binary representation.
   * @param {number} dec
   * @return {string}
   */

	}, {
		key: 'decToBinary',
		value: function decToBinary(dec) {
			return (dec >>> 0).toString(2);
		}

		/**
   * Reads a variable length value.
   * @param {array} byteArray
   * @return {number}
   */

	}, {
		key: 'readVarInt',
		value: function readVarInt(byteArray) {
			var result = 0;
			byteArray.forEach(function (number) {
				var b = number;
				if (b & 0x80) {
					result += b & 0x7f;
					result <<= 7;
				} else {
					/* b is the last byte */
					result += b;
				}
			});

			return result;
		}

		/**
   * Decodes base-64 encoded string
   * @param {string} string
   * @return {string}
   */

	}, {
		key: 'atob',
		value: function (_atob) {
			function atob(_x) {
				return _atob.apply(this, arguments);
			}

			atob.toString = function () {
				return _atob.toString();
			};

			return atob;
		}(function (string) {
			if (typeof atob === 'function') return atob(string);
			return new Buffer(string, 'base64').toString('binary');
		})
	}]);

	return Utils;
}();

exports.Utils = Utils;

}).call(this,require("buffer").Buffer)

},{"buffer":2}]},{},[5])(5)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwic3JjL2NvbnN0YW50cy5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9wbGF5ZXIuanMiLCJzcmMvdHJhY2suanMiLCJzcmMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcEZBOzs7QUFHQSxJQUFJLFlBQVk7QUFDZixVQUFTLE9BRE07QUFFZixRQUFP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Ozs7Ozs7OEJBS21CLEcsRUFBSztBQUNwQixVQUFPLENBQUMsUUFBUSxDQUFULEVBQVksUUFBWixDQUFxQixDQUFyQixDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7OzZCQUtrQixTLEVBQVc7QUFDNUIsT0FBSSxTQUFTLENBQWI7QUFDQSxhQUFVLE9BQVYsQ0FBa0Isa0JBQVU7QUFDM0IsUUFBSSxJQUFJLE1BQVI7QUFDQSxRQUFJLElBQUksSUFBUixFQUFjO0FBQ2IsZUFBVyxJQUFJLElBQWY7QUFDQSxnQkFBVyxDQUFYO0FBQ0EsS0FIRCxNQUdPO0FBQ047QUFDQSxlQUFVLENBQVY7QUFDQTtBQUNELElBVEQ7O0FBV0EsVUFBTyxNQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQUtZLE0sRUFBUTtBQUNuQixPQUFJLE9BQU8sSUFBUCxLQUFnQixVQUFwQixFQUFnQyxPQUFPLEtBQUssTUFBTCxDQUFQO0FBQ2hDLFVBQU8sSUFBSSxNQUFKLENBQVcsTUFBWCxFQUFtQixRQUFuQixFQUE2QixRQUE3QixDQUFzQyxRQUF0QyxDQUFQO0FBQ0EsRzs7Ozs7O0FBR0YsUUFBUSxLQUFSLEdBQWdCLEtBQWhCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDApIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXJzIGZyb20gYW5vdGhlciBjb250ZXh0IChpLmUuIGFuIGlmcmFtZSkgZG8gbm90IHBhc3MgdGhlIGBpbnN0YW5jZW9mYCBjaGVja1xuLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJylcbn1cblxuLy8gTm9kZSAwLjEwIHN1cHBvcnRzIGBBcnJheUJ1ZmZlcmAgYnV0IGxhY2tzIGBBcnJheUJ1ZmZlci5pc1ZpZXdgXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyAob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcbn1cblxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiLyoqXG4gKiBDb25zdGFudHMgdXNlZCBpbiBwbGF5ZXIuXG4gKi9cbnZhciBDb25zdGFudHMgPSB7XG5cdFZFUlNJT046ICcyLjAuNScsXG5cdE5PVEVTOiBbXSxcblx0Q0lSQ0xFX09GX0ZPVVJUSFM6IFsnQycsICdGJywgJ0JiJywgJ0ViJywgJ0FiJywgJ0RiJywgJ0diJywgJ0NiJywgJ0ZiJywgJ0JiYicsICdFYmInLCAnQWJiJ10sXG5cdENJUkNMRV9PRl9GSUZUSFM6IFsnQycsICdHJywgJ0QnLCAnQScsICdFJywgJ0InLCAnRiMnLCAnQyMnLCAnRyMnLCAnRCMnLCAnQSMnLCAnRSMnXVxufTtcblxuLy8gQnVpbGRzIG5vdGVzIG9iamVjdCBmb3IgcmVmZXJlbmNlIGFnYWluc3QgYmluYXJ5IHZhbHVlcy5cbnZhciBhbGxOb3RlcyA9IFtbJ0MnXSwgWydDIycsJ0RiJ10sIFsnRCddLCBbJ0QjJywnRWInXSwgWydFJ10sWydGJ10sIFsnRiMnLCdHYiddLCBbJ0cnXSwgWydHIycsJ0FiJ10sIFsnQSddLCBbJ0EjJywnQmInXSwgWydCJ11dO1xudmFyIGNvdW50ZXIgPSAwO1xuXG4vLyBBbGwgYXZhaWxhYmxlIG9jdGF2ZXMuXG5mb3IgKGxldCBpID0gLTE7IGkgPD0gOTsgaSsrKSB7XG5cdGFsbE5vdGVzLmZvckVhY2gobm90ZUdyb3VwID0+IHtcblx0XHRub3RlR3JvdXAuZm9yRWFjaChub3RlID0+IENvbnN0YW50cy5OT1RFU1tjb3VudGVyXSA9IG5vdGUgKyBpKTtcblx0XHRjb3VudGVyICsrO1xuXHR9KTtcbn1cblxuZXhwb3J0cy5Db25zdGFudHMgPSBDb25zdGFudHM7IiwiY29uc3QgUGxheWVyID0gcmVxdWlyZShcIi4vcGxheWVyXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUGxheWVyOlBsYXllci5QbGF5ZXIsXG4gICAgVXRpbHM6VXRpbHMuVXRpbHMsXG4gICAgQ29uc3RhbnRzOkNvbnN0YW50cy5Db25zdGFudHNcbn0iLCJjb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpLlV0aWxzO1xuY29uc3QgVHJhY2sgPSByZXF1aXJlKFwiLi90cmFja1wiKS5UcmFjaztcblxuLy8gUG9seWZpbGwgVWludDhBcnJheS5mb3JFYWNoOiBEb2Vzbid0IGV4aXN0IG9uIFNhZmFyaSA8MTBcbmlmICghVWludDhBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDhBcnJheS5wcm90b3R5cGUsICdmb3JFYWNoJywge1xuXHRcdHZhbHVlOiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaFxuXHR9KTtcbn1cblxuLyoqXG4gKiBNYWluIHBsYXllciBjbGFzcy4gIENvbnRhaW5zIG1ldGhvZHMgdG8gbG9hZCBmaWxlcywgc3RhcnQsIHN0b3AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAtIENhbGxiYWNrIHRvIGZpcmUgZm9yIGVhY2ggTUlESSBldmVudC4gIENhbiBhbHNvIGJlIGFkZGVkIHdpdGggb24oJ21pZGlFdmVudCcsIGZuKVxuICogQHBhcmFtIHthcnJheX0gLSBBcnJheSBidWZmZXIgb2YgTUlESSBmaWxlIChvcHRpb25hbCkuXG4gKi9cbmNsYXNzIFBsYXllciB7XG5cdGNvbnN0cnVjdG9yKGV2ZW50SGFuZGxlciwgYnVmZmVyKSB7XG5cdFx0dGhpcy5zYW1wbGVSYXRlID0gNTsgLy8gbWlsbGlzZWNvbmRzXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXHRcdHRoaXMuYnVmZmVyID0gYnVmZmVyIHx8IG51bGw7XG5cdFx0dGhpcy5kaXZpc2lvbjtcblx0XHR0aGlzLmZvcm1hdDtcblx0XHR0aGlzLnNldEludGVydmFsSWQgPSBmYWxzZTtcblx0XHR0aGlzLnRyYWNrcyA9IFtdO1xuXHRcdHRoaXMuaW5zdHJ1bWVudHMgPSBbXTtcblx0XHR0aGlzLmRlZmF1bHRUZW1wbyA9IDEyMDtcblx0XHR0aGlzLnRlbXBvID0gbnVsbDtcblx0XHR0aGlzLnN0YXJ0VGljayA9IDA7XG5cdFx0dGhpcy50aWNrID0gMDtcblx0XHR0aGlzLmxhc3RUaWNrID0gbnVsbDtcblx0XHR0aGlzLmluTG9vcCA9IGZhbHNlO1xuXHRcdHRoaXMudG90YWxUaWNrcyA9IDA7XG5cdFx0dGhpcy5ldmVudHMgPSBbXTtcblx0XHR0aGlzLnRvdGFsRXZlbnRzID0gMDtcblx0XHR0aGlzLmV2ZW50TGlzdGVuZXJzID0ge307XG5cblx0XHRpZiAodHlwZW9mKGV2ZW50SGFuZGxlcikgPT09ICdmdW5jdGlvbicpIHRoaXMub24oJ21pZGlFdmVudCcsIGV2ZW50SGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogTG9hZCBhIGZpbGUgaW50byB0aGUgcGxheWVyIChOb2RlLmpzIG9ubHkpLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFBhdGggb2YgZmlsZS5cblx0ICogQHJldHVybiB7UGxheWVyfVxuXHQgKi9cblx0bG9hZEZpbGUocGF0aCkge1xuXHRcdHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cdFx0dGhpcy5idWZmZXIgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCk7XG5cdFx0cmV0dXJuIHRoaXMuZmlsZUxvYWRlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvYWQgYW4gYXJyYXkgYnVmZmVyIGludG8gdGhlIHBsYXllci5cblx0ICogQHBhcmFtIHthcnJheX0gYXJyYXlCdWZmZXIgLSBBcnJheSBidWZmZXIgb2YgZmlsZSB0byBiZSBsb2FkZWQuXG5cdCAqIEByZXR1cm4ge1BsYXllcn1cblx0ICovXG5cdGxvYWRBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuXHRcdHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXHRcdHJldHVybiB0aGlzLmZpbGVMb2FkZWQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMb2FkIGEgZGF0YSBVUkkgaW50byB0aGUgcGxheWVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVyaSAtIERhdGEgVVJJIHRvIGJlIGxvYWRlZC5cblx0ICogQHJldHVybiB7UGxheWVyfVxuXHQgKi9cblx0bG9hZERhdGFVcmkoZGF0YVVyaSkge1xuXHRcdC8vIGNvbnZlcnQgYmFzZTY0IHRvIHJhdyBiaW5hcnkgZGF0YSBoZWxkIGluIGEgc3RyaW5nLlxuXHRcdC8vIGRvZXNuJ3QgaGFuZGxlIFVSTEVuY29kZWQgRGF0YVVSSXMgLSBzZWUgU08gYW5zd2VyICM2ODUwMjc2IGZvciBjb2RlIHRoYXQgZG9lcyB0aGlzXG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSBVdGlscy5hdG9iKGRhdGFVcmkuc3BsaXQoJywnKVsxXSk7XG5cblx0XHQvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlclxuXHRcdHZhciBpYSA9IG5ldyBVaW50OEFycmF5KGJ5dGVTdHJpbmcubGVuZ3RoKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXHRcdH1cblxuXHRcdHRoaXMuYnVmZmVyID0gaWE7XG5cdFx0cmV0dXJuIHRoaXMuZmlsZUxvYWRlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBmaWxlc2l6ZSBvZiBsb2FkZWQgZmlsZSBpbiBudW1iZXIgb2YgYnl0ZXMuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgZmlsZXNpemUuXG5cdCAqL1xuXHRnZXRGaWxlc2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5sZW5ndGggOiAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgZGVmYXVsdCB0ZW1wbywgcGFyc2VzIGZpbGUgZm9yIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiwgYW5kIGRvZXMgYSBkcnkgcnVuIHRvIGNhbGN1bGF0ZSB0b3RhbCBsZW5ndGguXG5cdCAqIFBvcHVsYXRlcyB0aGlzLmV2ZW50cyAmIHRoaXMudG90YWxUaWNrcy5cblx0ICogQHJldHVybiB7UGxheWVyfVxuXHQgKi9cblx0ZmlsZUxvYWRlZCgpIHtcblx0XHRpZiAoIXRoaXMudmFsaWRhdGUoKSkgdGhyb3cgJ0ludmFsaWQgTUlESSBmaWxlOyBzaG91bGQgc3RhcnQgd2l0aCBNVGhkJztcblx0XHRyZXR1cm4gdGhpcy5zZXRUZW1wbyh0aGlzLmRlZmF1bHRUZW1wbykuZ2V0RGl2aXNpb24oKS5nZXRGb3JtYXQoKS5nZXRUcmFja3MoKS5kcnlSdW4oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZXMgZmlsZSB1c2luZyBzaW1wbGUgbWVhbnMgLSBmaXJzdCBmb3VyIGJ5dGVzIHNob3VsZCA9PSBNVGhkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0dmFsaWRhdGUoKSB7XG5cdFx0cmV0dXJuIFV0aWxzLmJ5dGVzVG9MZXR0ZXJzKHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIDQpKSA9PT0gJ01UaGQnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgTUlESSBmaWxlIGZvcm1hdCBmb3IgbG9hZGVkIGZpbGUuXG5cdCAqIEByZXR1cm4ge1BsYXllcn1cblx0ICovXG5cdGdldEZvcm1hdCgpIHtcblx0XHQvKlxuXHRcdE1JREkgZmlsZXMgY29tZSBpbiAzIHZhcmlhdGlvbnM6XG5cdFx0Rm9ybWF0IDAgd2hpY2ggY29udGFpbiBhIHNpbmdsZSB0cmFja1xuXHRcdEZvcm1hdCAxIHdoaWNoIGNvbnRhaW4gb25lIG9yIG1vcmUgc2ltdWx0YW5lb3VzIHRyYWNrc1xuXHRcdChpZSBhbGwgdHJhY2tzIGFyZSB0byBiZSBwbGF5ZWQgc2ltdWx0YW5lb3VzbHkpLlxuXHRcdEZvcm1hdCAyIHdoaWNoIGNvbnRhaW4gb25lIG9yIG1vcmUgaW5kZXBlbmRhbnQgdHJhY2tzXG5cdFx0KGllIGVhY2ggdHJhY2sgaXMgdG8gYmUgcGxheWVkIGluZGVwZW5kYW50bHkgb2YgdGhlIG90aGVycykuXG5cdFx0cmV0dXJuIFV0aWxzLmJ5dGVzVG9OdW1iZXIodGhpcy5idWZmZXIuc3ViYXJyYXkoOCwgMTApKTtcblx0XHQqL1xuXG5cdFx0dGhpcy5mb3JtYXQgPSBVdGlscy5ieXRlc1RvTnVtYmVyKHRoaXMuYnVmZmVyLnN1YmFycmF5KDgsIDEwKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIG91dCB0cmFja3MsIHBsYWNlcyB0aGVtIGluIHRoaXMudHJhY2tzIGFuZCBpbml0aWFsaXplcyB0aGlzLnBvaW50ZXJzXG5cdCAqIEByZXR1cm4ge1BsYXllcn1cblx0ICovXG5cdGdldFRyYWNrcygpIHtcblx0XHR0aGlzLnRyYWNrcyA9IFtdO1xuXHRcdGxldCB0cmFja09mZnNldCA9IDA7XG5cdFx0d2hpbGUgKHRyYWNrT2Zmc2V0IDwgdGhpcy5idWZmZXIubGVuZ3RoKSB7XG5cdFx0XHRpZiAoVXRpbHMuYnl0ZXNUb0xldHRlcnModGhpcy5idWZmZXIuc3ViYXJyYXkodHJhY2tPZmZzZXQsIHRyYWNrT2Zmc2V0ICsgNCkpID09ICdNVHJrJykge1xuXHRcdFx0XHRsZXQgdHJhY2tMZW5ndGggPSBVdGlscy5ieXRlc1RvTnVtYmVyKHRoaXMuYnVmZmVyLnN1YmFycmF5KHRyYWNrT2Zmc2V0ICsgNCwgdHJhY2tPZmZzZXQgKyA4KSk7XG5cdFx0XHRcdHRoaXMudHJhY2tzLnB1c2gobmV3IFRyYWNrKHRoaXMudHJhY2tzLmxlbmd0aCwgdGhpcy5idWZmZXIuc3ViYXJyYXkodHJhY2tPZmZzZXQgKyA4LCB0cmFja09mZnNldCArIDggKyB0cmFja0xlbmd0aCkpKTtcblx0XHRcdH1cblxuXHRcdFx0dHJhY2tPZmZzZXQgKz0gVXRpbHMuYnl0ZXNUb051bWJlcih0aGlzLmJ1ZmZlci5zdWJhcnJheSh0cmFja09mZnNldCArIDQsIHRyYWNrT2Zmc2V0ICsgOCkpICsgODtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyBhIHRyYWNrIGZvciBwbGF5aW5nLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdHJhY2tOdW1iZXIgLSBUcmFjayBudW1iZXJcblx0ICogQHJldHVybiB7UGxheWVyfVxuXHQgKi9cblx0ZW5hYmxlVHJhY2sodHJhY2tOdW1iZXIpIHtcblx0XHR0aGlzLnRyYWNrc1t0cmFja051bWJlciAtIDFdLmVuYWJsZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGVzIGEgdHJhY2sgZm9yIHBsYXlpbmcuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSAtIFRyYWNrIG51bWJlclxuXHQgKiBAcmV0dXJuIHtQbGF5ZXJ9XG5cdCAqL1xuXHRkaXNhYmxlVHJhY2sodHJhY2tOdW1iZXIpIHtcblx0XHR0aGlzLnRyYWNrc1t0cmFja051bWJlciAtIDFdLmRpc2FibGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHF1YXJ0ZXIgbm90ZSBkaXZpc2lvbiBvZiBsb2FkZWQgTUlESSBmaWxlLlxuXHQgKiBAcmV0dXJuIHtQbGF5ZXJ9XG5cdCAqL1xuXHRnZXREaXZpc2lvbigpIHtcblx0XHR0aGlzLmRpdmlzaW9uID0gVXRpbHMuYnl0ZXNUb051bWJlcih0aGlzLmJ1ZmZlci5zdWJhcnJheSgxMiwgMTQpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbWFpbiBwbGF5IGxvb3AuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gLSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyBiZWluZyBjYWxsZWQgc2ltcGx5IGZvciBwYXJzaW5nIHB1cnBvc2VzLiAgRGlzcmVnYXJkcyB0aW1pbmcgaWYgc28uXG5cdCAqIEByZXR1cm4ge3VuZGVmaW5lZH1cblx0ICovXG5cdHBsYXlMb29wKGRyeVJ1bikge1xuXHRcdGlmICghdGhpcy5pbkxvb3ApIHtcblx0XHRcdHRoaXMuaW5Mb29wID0gdHJ1ZTtcblx0XHRcdHRoaXMudGljayA9IHRoaXMuZ2V0Q3VycmVudFRpY2soKTtcblxuXHRcdFx0dGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuXHRcdFx0XHQvLyBIYW5kbGUgbmV4dCBldmVudFxuXHRcdFx0XHRpZiAoIWRyeVJ1biAmJiB0aGlzLmVuZE9mRmlsZSgpKSB7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZW5kIG9mIGZpbGUnKVxuXHRcdFx0XHRcdHRoaXMudHJpZ2dlclBsYXllckV2ZW50KCdlbmRPZkZpbGUnKTtcblx0XHRcdFx0XHR0aGlzLnN0b3AoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgZXZlbnQgPSB0cmFjay5oYW5kbGVFdmVudCh0aGlzLnRpY2ssIGRyeVJ1bik7XG5cblx0XHRcdFx0XHRpZiAoZHJ5UnVuICYmIGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBldmVudC5uYW1lID09PSAnU2V0IFRlbXBvJykge1xuXHRcdFx0XHRcdFx0XHQvLyBHcmFiIHRlbXBvIGlmIGF2YWlsYWJsZS5cblx0XHRcdFx0XHRcdFx0dGhpcy5kZWZhdWx0VGVtcG8gPSBldmVudC5kYXRhO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFRlbXBvKGV2ZW50LmRhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCduYW1lJykgJiYgZXZlbnQubmFtZSA9PT0gJ1Byb2dyYW0gQ2hhbmdlJykge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXRoaXMuaW5zdHJ1bWVudHMuaW5jbHVkZXMoZXZlbnQudmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5pbnN0cnVtZW50cy5wdXNoKGV2ZW50LnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZXZlbnQpIHRoaXMuZW1pdEV2ZW50KGV2ZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0aWYgKCFkcnlSdW4pIHRoaXMudHJpZ2dlclBsYXllckV2ZW50KCdwbGF5aW5nJywge3RpY2s6IHRoaXMudGlja30pO1xuXHRcdFx0dGhpcy5pbkxvb3AgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0dGVyIGZvciB0ZW1wby5cblx0ICogQHBhcmFtIHtudW1iZXJ9IC0gVGVtcG8gaW4gYnBtIChkZWZhdWx0cyB0byAxMjApXG5cdCAqL1xuXHRzZXRUZW1wbyh0ZW1wbykge1xuXHRcdHRoaXMudGVtcG8gPSB0ZW1wbztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXR0ZXIgZm9yIHN0YXJ0VGltZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IC0gVVRDIHRpbWVzdGFtcFxuXHQgKi9cblx0c2V0U3RhcnRUaW1lKHN0YXJ0VGltZSkge1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0IHBsYXlpbmcgbG9hZGVkIE1JREkgZmlsZSBpZiBub3QgYWxyZWFkeSBwbGF5aW5nLlxuXHQgKiBAcmV0dXJuIHtQbGF5ZXJ9XG5cdCAqL1xuXHRwbGF5KCkge1xuXHRcdGlmICh0aGlzLmlzUGxheWluZygpKSB0aHJvdyAnQWxyZWFkeSBwbGF5aW5nLi4uJztcblxuXHRcdC8vIEluaXRpYWxpemVcblx0XHRpZiAoIXRoaXMuc3RhcnRUaW1lKSB0aGlzLnN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cblx0XHQvLyBTdGFydCBwbGF5IGxvb3Bcblx0XHQvL3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5wbGF5TG9vcC5iaW5kKHRoaXMpKTtcblx0XHR0aGlzLnNldEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0aGlzLnBsYXlMb29wLmJpbmQodGhpcyksIHRoaXMuc2FtcGxlUmF0ZSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXVzZXMgcGxheWJhY2sgaWYgcGxheWluZy5cblx0ICogQHJldHVybiB7UGxheWVyfVxuXHQgKi9cblx0cGF1c2UoKSB7XG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnNldEludGVydmFsSWQpO1xuXHRcdHRoaXMuc2V0SW50ZXJ2YWxJZCA9IGZhbHNlO1xuXHRcdHRoaXMuc3RhcnRUaWNrID0gdGhpcy50aWNrO1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTdG9wcyBwbGF5YmFjayBpZiBwbGF5aW5nLlxuXHQgKiBAcmV0dXJuIHtQbGF5ZXJ9XG5cdCAqL1xuXHRzdG9wKCkge1xuXHRcdGNsZWFySW50ZXJ2YWwodGhpcy5zZXRJbnRlcnZhbElkKTtcblx0XHR0aGlzLnNldEludGVydmFsSWQgPSBmYWxzZTtcblx0XHR0aGlzLnN0YXJ0VGljayA9IDA7XG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXHRcdHRoaXMucmVzZXRUcmFja3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTa2lwcyBwbGF5ZXIgcG9pbnRlciB0byBzcGVjaWZpZWQgdGljay5cblx0ICogQHBhcmFtIHtudW1iZXJ9IC0gVGljayB0byBza2lwIHRvLlxuXHQgKiBAcmV0dXJuIHtQbGF5ZXJ9XG5cdCAqL1xuXHRza2lwVG9UaWNrKHRpY2spIHtcblx0XHR0aGlzLnN0b3AoKTtcblx0XHR0aGlzLnN0YXJ0VGljayA9IHRpY2s7XG5cblx0XHQvLyBOZWVkIHRvIHNldCB0cmFjayBldmVudCBpbmRleGVzIHRvIHRoZSBuZWFyZXN0IHBvc3NpYmxlIGV2ZW50IHRvIHRoZSBzcGVjaWZpZWQgdGljay5cblx0XHR0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG5cdFx0XHR0cmFjay5zZXRFdmVudEluZGV4QnlUaWNrKHRpY2spO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNraXBzIHBsYXllciBwb2ludGVyIHRvIHNwZWNpZmllZCBwZXJjZW50YWdlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gLSBQZXJjZW50IHZhbHVlIGluIGludGVnZXIgZm9ybWF0LlxuXHQgKiBAcmV0dXJuIHtQbGF5ZXJ9XG5cdCAqL1xuXHRza2lwVG9QZXJjZW50KHBlcmNlbnQpIHtcblx0XHRpZiAocGVyY2VudCA8IDAgfHwgcGVyY2VudCA+IDEwMCkgdGhyb3cgXCJQZXJjZW50IG11c3QgYmUgbnVtYmVyIGJldHdlZW4gMSBhbmQgMTAwLlwiO1xuXHRcdHRoaXMuc2tpcFRvVGljayhNYXRoLnJvdW5kKHBlcmNlbnQgLyAxMDAgKiB0aGlzLnRvdGFsVGlja3MpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTa2lwcyBwbGF5ZXIgcG9pbnRlciB0byBzcGVjaWZpZWQgc2Vjb25kcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IC0gU2Vjb25kcyB0byBza2lwIHRvLlxuXHQgKiBAcmV0dXJuIHtQbGF5ZXJ9XG5cdCAqL1xuXHRza2lwVG9TZWNvbmRzKHNlY29uZHMpIHtcblx0XHR2YXIgc29uZ1RpbWUgPSB0aGlzLmdldFNvbmdUaW1lKCk7XG5cdFx0aWYgKHNlY29uZHMgPCAwIHx8IHNlY29uZHMgPiBzb25nVGltZSkgdGhyb3cgc2Vjb25kcyArIFwiIHNlY29uZHMgbm90IHdpdGhpbiBzb25nIHRpbWUgb2YgXCIgKyBzb25nVGltZTtcblx0XHR0aGlzLnNraXBUb1BlcmNlbnQoc2Vjb25kcyAvIHNvbmdUaW1lICogMTAwKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcGxheWVyIGlzIHBsYXlpbmdcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzUGxheWluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRJbnRlcnZhbElkID4gMCB8fCB0eXBlb2YgdGhpcy5zZXRJbnRlcnZhbElkID09PSAnb2JqZWN0Jztcblx0fVxuXG5cdC8qKlxuXHQgKiBQbGF5cyB0aGUgbG9hZGVkIE1JREkgZmlsZSB3aXRob3V0IHJlZ2FyZCBmb3IgdGltaW5nIGFuZCBzYXZlcyBldmVudHMgaW4gdGhpcy5ldmVudHMuICBFc3NlbnRpYWxseSB1c2VkIGFzIGEgcGFyc2VyLlxuXHQgKiBAcmV0dXJuIHtQbGF5ZXJ9XG5cdCAqL1xuXHRkcnlSdW4oKSB7XG5cdFx0Ly8gUmVzZXQgdHJhY2tzIGZpcnN0XG5cdFx0dGhpcy5yZXNldFRyYWNrcygpO1xuXHRcdHdoaWxlICghdGhpcy5lbmRPZkZpbGUoKSkgdGhpcy5wbGF5TG9vcCh0cnVlKTtcblx0XHR0aGlzLmV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0dGhpcy50b3RhbEV2ZW50cyA9IHRoaXMuZ2V0VG90YWxFdmVudHMoKTtcblx0XHR0aGlzLnRvdGFsVGlja3MgPSB0aGlzLmdldFRvdGFsVGlja3MoKTtcblx0XHR0aGlzLnN0YXJ0VGljayA9IDA7XG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXG5cdFx0Ly8gTGVhdmUgdHJhY2tzIGluIHByaXN0aW5lIGNvbmRpc2hcblx0XHR0aGlzLnJlc2V0VHJhY2tzKCk7XG5cblx0XHQvL2NvbnNvbGUubG9nKCdTb25nIHRpbWU6ICcgKyB0aGlzLmdldFNvbmdUaW1lKCkgKyAnIHNlY29uZHMgLyAnICsgdGhpcy50b3RhbFRpY2tzICsgJyB0aWNrcy4nKTtcblxuXHRcdHRoaXMudHJpZ2dlclBsYXllckV2ZW50KCdmaWxlTG9hZGVkJywgdGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHBsYXkgcG9pbnRlcnMgZm9yIGFsbCB0cmFja3MuXG5cdCAqIEByZXR1cm4ge1BsYXllcn1cblx0ICovXG5cdHJlc2V0VHJhY2tzKCkge1xuXHRcdHRoaXMudHJhY2tzLmZvckVhY2godHJhY2sgPT4gdHJhY2sucmVzZXQoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBhcnJheSBvZiBldmVudHMgZ3JvdXBlZCBieSB0cmFjay5cblx0ICogQHJldHVybiB7YXJyYXl9XG5cdCAqL1xuXHRnZXRFdmVudHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhY2tzLm1hcCh0cmFjayA9PiB0cmFjay5ldmVudHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdG90YWwgbnVtYmVyIG9mIHRpY2tzIGluIHRoZSBsb2FkZWQgTUlESSBmaWxlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRUb3RhbFRpY2tzKCkge1xuXHRcdHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLnRyYWNrcy5tYXAodHJhY2sgPT4gdHJhY2suZGVsdGEpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRvdGFsIG51bWJlciBvZiBldmVudHMgaW4gdGhlIGxvYWRlZCBNSURJIGZpbGUuXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGdldFRvdGFsRXZlbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLnRyYWNrcy5yZWR1Y2UoKGEsIGIpID0+IHtyZXR1cm4ge2V2ZW50czoge2xlbmd0aDogYS5ldmVudHMubGVuZ3RoICsgYi5ldmVudHMubGVuZ3RofX19LCB7ZXZlbnRzOiB7bGVuZ3RoOiAwfX0pLmV2ZW50cy5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBzb25nIGR1cmF0aW9uIGluIHNlY29uZHMuXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGdldFNvbmdUaW1lKCkge1xuXHRcdHJldHVybiB0aGlzLnRvdGFsVGlja3MgLyB0aGlzLmRpdmlzaW9uIC8gdGhpcy50ZW1wbyAqIDYwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgcmVtYWluaW5nIG51bWJlciBvZiBzZWNvbmRzIGluIHBsYXliYWNrLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRTb25nVGltZVJlbWFpbmluZygpIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgodGhpcy50b3RhbFRpY2tzIC0gdGhpcy5nZXRDdXJyZW50VGljaygpKSAvIHRoaXMuZGl2aXNpb24gLyB0aGlzLnRlbXBvICogNjApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgcmVtYWluaW5nIHBlcmNlbnQgb2YgcGxheWJhY2suXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGdldFNvbmdQZXJjZW50UmVtYWluaW5nKCkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHRoaXMuZ2V0U29uZ1RpbWVSZW1haW5pbmcoKSAvIHRoaXMuZ2V0U29uZ1RpbWUoKSAqIDEwMCk7XG5cdH1cblxuXHQvKipcblx0ICogTnVtYmVyIG9mIGJ5dGVzIHByb2Nlc3NlZCBpbiB0aGUgbG9hZGVkIE1JREkgZmlsZS5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0Ynl0ZXNQcm9jZXNzZWQoKSB7XG5cdFx0Ly8gQ3VycmVudGx5IGFzc3VtZSBoZWFkZXIgY2h1bmsgaXMgc3RyaWN0bHkgMTQgYnl0ZXNcblx0XHRyZXR1cm4gMTQgKyB0aGlzLnRyYWNrcy5sZW5ndGggKiA4ICsgdGhpcy50cmFja3MucmVkdWNlKChhLCBiKSA9PiB7cmV0dXJuIHtwb2ludGVyOiBhLnBvaW50ZXIgKyBiLnBvaW50ZXJ9fSwge3BvaW50ZXI6IDB9KS5wb2ludGVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIE51bWJlciBvZiBldmVudHMgcGxheWVkIHVwIHRvIHRoaXMgcG9pbnQuXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGV2ZW50c1BsYXllZCgpIHtcblx0XHRyZXR1cm4gdGhpcy50cmFja3MucmVkdWNlKChhLCBiKSA9PiB7cmV0dXJuIHtldmVudEluZGV4OiBhLmV2ZW50SW5kZXggKyBiLmV2ZW50SW5kZXh9fSwge2V2ZW50SW5kZXg6IDB9KS5ldmVudEluZGV4O1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIHBsYXllciBwb2ludGVyIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGxvYWRlZCBNSURJIGZpbGUuXG5cdCAqIFVzZWQgaW4gdHdvIHdheXM6XG5cdCAqIDEuIElmIHBsYXlpbmcgcmVzdWx0IGlzIGJhc2VkIG9uIGxvYWRlZCBKU09OIGV2ZW50cy5cblx0ICogMi4gSWYgcGFyc2luZyAoZHJ5UnVuKSBpdCdzIGJhc2VkIG9uIHRoZSBhY3R1YWwgYnVmZmVyIGxlbmd0aCB2cyBieXRlcyBwcm9jZXNzZWQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRlbmRPZkZpbGUoKSB7XG5cdFx0aWYgKHRoaXMuaXNQbGF5aW5nKCkpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGlja3MgLSB0aGlzLnRpY2sgPD0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5ieXRlc1Byb2Nlc3NlZCgpID09IHRoaXMuYnVmZmVyLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50IHRpY2sgbnVtYmVyIGluIHBsYXliYWNrLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDdXJyZW50VGljaygpIHtcblx0XHRpZighdGhpcy5zdGFydFRpbWUgJiYgdGhpcy50aWNrKSByZXR1cm4gdGhpcy5zdGFydFRpY2s7XG5cdFx0ZWxzZSBpZighdGhpcy5zdGFydFRpbWUpIHJldHVybiAwO1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGhpcy5zdGFydFRpbWUpIC8gMTAwMCAqICh0aGlzLmRpdmlzaW9uICogKHRoaXMudGVtcG8gLyA2MCkpKSArIHRoaXMuc3RhcnRUaWNrO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmRzIE1JREkgZXZlbnQgb3V0IHRvIGxpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge29iamVjdH1cblx0ICogQHJldHVybiB7UGxheWVyfVxuXHQgKi9cblx0ZW1pdEV2ZW50KGV2ZW50KSB7XG5cdFx0dGhpcy50cmlnZ2VyUGxheWVyRXZlbnQoJ21pZGlFdmVudCcsIGV2ZW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmVzIGV2ZW50cyB0byBsaXN0ZW5lcnNcblx0ICogQHBhcmFtIHtzdHJpbmd9IC0gTmFtZSBvZiBldmVudCB0byBzdWJzY3JpYmUgdG8uXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IC0gQ2FsbGJhY2sgdG8gZmlyZSB3aGVuIGV2ZW50IGlzIGJyb2FkY2FzdC5cblx0ICogQHJldHVybiB7UGxheWVyfVxuXHQgKi9cblx0b24ocGxheWVyRXZlbnQsIGZuKSB7XG5cdFx0aWYgKCF0aGlzLmV2ZW50TGlzdGVuZXJzLmhhc093blByb3BlcnR5KHBsYXllckV2ZW50KSkgdGhpcy5ldmVudExpc3RlbmVyc1twbGF5ZXJFdmVudF0gPSBbXTtcblx0XHR0aGlzLmV2ZW50TGlzdGVuZXJzW3BsYXllckV2ZW50XS5wdXNoKGZuKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBCcm9hZGNhc3RzIGV2ZW50IHRvIHRyaWdnZXIgc3Vic2NyaWJlZCBjYWxsYmFja3MuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSAtIE5hbWUgb2YgZXZlbnQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSAtIERhdGEgdG8gYmUgcGFzc2VkIHRvIHN1YnNjcmliZXIgY2FsbGJhY2suXG5cdCAqIEByZXR1cm4ge1BsYXllcn1cblx0ICovXG5cdHRyaWdnZXJQbGF5ZXJFdmVudChwbGF5ZXJFdmVudCwgZGF0YSkge1xuXHRcdGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmhhc093blByb3BlcnR5KHBsYXllckV2ZW50KSkgdGhpcy5ldmVudExpc3RlbmVyc1twbGF5ZXJFdmVudF0uZm9yRWFjaChmbiA9PiBmbihkYXRhIHx8IHt9KSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5leHBvcnRzLlBsYXllciA9IFBsYXllcjtcbiIsImNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKS5Db25zdGFudHM7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpLlV0aWxzO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHRyYWNrLiAgQ29udGFpbnMgbWV0aG9kcyBmb3IgcGFyc2luZyBldmVudHMgYW5kIGtlZXBpbmcgdHJhY2sgb2YgcG9pbnRlci5cbiAqL1xuY2xhc3MgVHJhY2tcdHtcblx0Y29uc3RydWN0b3IoaW5kZXgsIGRhdGEpIHtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnRJbmRleCA9IDA7XG5cdFx0dGhpcy5wb2ludGVyID0gMDtcblx0XHR0aGlzLmxhc3RUaWNrID0gMDtcblx0XHR0aGlzLmxhc3RTdGF0dXMgPSBudWxsO1xuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdHRoaXMuZGVsdGEgPSAwO1xuXHRcdHRoaXMucnVubmluZ0RlbHRhID0gMDtcblx0XHR0aGlzLmV2ZW50cyA9IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlc2V0cyBhbGwgc3RhdGVmdWwgdHJhY2sgaW5mb3JtYWlvbiB1c2VkIGR1cmluZyBwbGF5YmFjay5cblx0ICogQHJldHVybiB7VHJhY2t9XG5cdCAqL1xuXHRyZXNldCgpIHtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnRJbmRleCA9IDA7XG5cdFx0dGhpcy5wb2ludGVyID0gMDtcblx0XHR0aGlzLmxhc3RUaWNrID0gMDtcblx0XHR0aGlzLmxhc3RTdGF0dXMgPSBudWxsO1xuXHRcdHRoaXMuZGVsdGEgPSAwO1xuXHRcdHRoaXMucnVubmluZ0RlbHRhID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgdHJhY2sgdG8gYmUgZW5hYmxlZCBkdXJpbmcgcGxheWJhY2suXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0ZW5hYmxlKCkge1xuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHRyYWNrIHRvIGJlIGRpc2FibGVkIGR1cmluZyBwbGF5YmFjay5cblx0ICogQHJldHVybiB7VHJhY2t9XG5cdCAqL1xuXHRkaXNhYmxlKCkge1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHRyYWNrIGV2ZW50IGluZGV4IHRvIHRoZSBuZWFyZXN0IGV2ZW50IHRvIHRoZSBnaXZlbiB0aWNrLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlja1xuXHQgKiBAcmV0dXJuIHtUcmFja31cblx0ICovXG5cdHNldEV2ZW50SW5kZXhCeVRpY2sodGljaykge1xuXHRcdHRpY2sgPSB0aWNrIHx8IDA7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuZXZlbnRzKSB7XG5cdFx0XHRpZiAodGhpcy5ldmVudHNbaV0udGljayA+PSB0aWNrKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRJbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGJ5dGUgbG9jYXRlZCBhdCBwb2ludGVyIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDdXJyZW50Qnl0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhW3RoaXMucG9pbnRlcl07XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBjb3VudCBvZiBkZWx0YSBieXRlcyBhbmQgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXREZWx0YUJ5dGVDb3VudCgpIHtcblx0XHQvLyBHZXQgYnl0ZSBjb3VudCBvZiBkZWx0YSBWTFZcblx0XHQvLyBodHRwOi8vd3d3LmNjYXJoLm9yZy9jb3Vyc2VzLzI1My9oYW5kb3V0L3Zsdi9cblx0XHQvLyBJZiBieXRlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gODBoICgxMjggZGVjaW1hbCkgdGhlbiB0aGUgbmV4dCBieXRlXG5cdCAgICAvLyBpcyBhbHNvIHBhcnQgb2YgdGhlIFZMVixcblx0ICAgXHQvLyBlbHNlIGJ5dGUgaXMgdGhlIGxhc3QgYnl0ZSBpbiBhIFZMVi5cblx0ICAgXHR2YXIgY3VycmVudEJ5dGUgPSB0aGlzLmdldEN1cnJlbnRCeXRlKCk7XG5cdCAgIFx0dmFyIGJ5dGVDb3VudCA9IDE7XG5cblx0XHR3aGlsZSAoY3VycmVudEJ5dGUgPj0gMTI4KSB7XG5cdFx0XHRjdXJyZW50Qnl0ZSA9IHRoaXMuZGF0YVt0aGlzLnBvaW50ZXIgKyBieXRlQ291bnRdO1xuXHRcdFx0Ynl0ZUNvdW50Kys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ5dGVDb3VudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgZGVsdGEgdmFsdWUgYXQgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXREZWx0YSgpIHtcblx0XHRyZXR1cm4gVXRpbHMucmVhZFZhckludCh0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5wb2ludGVyLCB0aGlzLnBvaW50ZXIgKyB0aGlzLmdldERlbHRhQnl0ZUNvdW50KCkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGV2ZW50IHdpdGhpbiBhIGdpdmVuIHRyYWNrIHN0YXJ0aW5nIGF0IHNwZWNpZmllZCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpY2tcblx0ICogQHBhcmFtIHtib29sZWFufSBkcnlSdW4gLSBJZiB0cnVlIGV2ZW50cyB3aWxsIGJlIHBhcnNlZCBhbmQgcmV0dXJuZWQgcmVnYXJkbGVzcyBvZiB0aW1lLlxuXHQgKi9cblx0aGFuZGxlRXZlbnQoY3VycmVudFRpY2ssIGRyeVJ1bikge1xuXHRcdGRyeVJ1biA9IGRyeVJ1biB8fCBmYWxzZTtcblxuXHRcdGlmIChkcnlSdW4pIHtcblx0XHRcdHZhciBlbGFwc2VkVGlja3MgPSBjdXJyZW50VGljayAtIHRoaXMubGFzdFRpY2s7XG5cdFx0XHR2YXIgZGVsdGEgPSB0aGlzLmdldERlbHRhKCk7XG5cdFx0XHR2YXIgZXZlbnRSZWFkeSA9IGVsYXBzZWRUaWNrcyA+PSBkZWx0YTtcblxuXHRcdFx0aWYgKHRoaXMucG9pbnRlciA8IHRoaXMuZGF0YS5sZW5ndGggJiYgKGRyeVJ1biB8fCBldmVudFJlYWR5KSkge1xuXHRcdFx0XHRsZXQgZXZlbnQgPSB0aGlzLnBhcnNlRXZlbnQoKTtcblx0XHRcdFx0aWYgKHRoaXMuZW5hYmxlZCkgcmV0dXJuIGV2ZW50O1xuXHRcdFx0XHQvLyBSZWN1cnNpdmVseSBjYWxsIHRoaXMgZnVuY3Rpb24gZm9yIGVhY2ggZXZlbnQgYWhlYWQgdGhhdCBoYXMgMCBkZWx0YSB0aW1lP1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIExldCdzIGFjdHVhbGx5IHBsYXkgdGhlIE1JREkgZnJvbSB0aGUgZ2VuZXJhdGVkIEpTT04gZXZlbnRzIGNyZWF0ZWQgYnkgdGhlIGRyeSBydW4uXG5cdFx0XHRpZiAodGhpcy5ldmVudHNbdGhpcy5ldmVudEluZGV4XSAmJiB0aGlzLmV2ZW50c1t0aGlzLmV2ZW50SW5kZXhdLnRpY2sgPD0gY3VycmVudFRpY2spIHtcblx0XHRcdFx0dGhpcy5ldmVudEluZGV4Kys7XG5cdFx0XHRcdGlmICh0aGlzLmVuYWJsZWQpIHJldHVybiB0aGlzLmV2ZW50c1t0aGlzLmV2ZW50SW5kZXggLSAxXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgc3RyaW5nIGRhdGEgZnJvbSBldmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50U3RhcnRJbmRleFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCkge1xuXHRcdHZhciBjdXJyZW50Qnl0ZSA9IHRoaXMucG9pbnRlcjtcblx0XHR2YXIgYnl0ZUNvdW50ID0gMTtcblx0XHR2YXIgbGVuZ3RoID0gVXRpbHMucmVhZFZhckludCh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgMiwgZXZlbnRTdGFydEluZGV4ICsgMiArIGJ5dGVDb3VudCkpO1xuXHRcdHZhciBzdHJpbmdMZW5ndGggPSBsZW5ndGg7XG5cblx0XHRyZXR1cm4gVXRpbHMuYnl0ZXNUb0xldHRlcnModGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIGJ5dGVDb3VudCArIDIsIGV2ZW50U3RhcnRJbmRleCArIGJ5dGVDb3VudCArIGxlbmd0aCArIDIpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgZXZlbnQgaW50byBKU09OIGFuZCBhZHZhbmNlcyBwb2ludGVyIGZvciB0aGUgdHJhY2tcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKi9cblx0cGFyc2VFdmVudCgpIHtcblx0XHR2YXIgZXZlbnRTdGFydEluZGV4ID0gdGhpcy5wb2ludGVyICsgdGhpcy5nZXREZWx0YUJ5dGVDb3VudCgpO1xuXHRcdHZhciBldmVudEpzb24gPSB7fTtcblx0XHR2YXIgZGVsdGFCeXRlQ291bnQgPSB0aGlzLmdldERlbHRhQnl0ZUNvdW50KCk7XG5cdFx0ZXZlbnRKc29uLnRyYWNrID0gdGhpcy5pbmRleCArIDE7XG5cdFx0ZXZlbnRKc29uLmRlbHRhID0gdGhpcy5nZXREZWx0YSgpO1xuXHRcdHRoaXMubGFzdFRpY2sgPSB0aGlzLmxhc3RUaWNrICsgZXZlbnRKc29uLmRlbHRhO1xuXHRcdHRoaXMucnVubmluZ0RlbHRhICs9IGV2ZW50SnNvbi5kZWx0YTtcblx0XHRldmVudEpzb24udGljayA9IHRoaXMucnVubmluZ0RlbHRhO1xuXHRcdGV2ZW50SnNvbi5ieXRlSW5kZXggPSB0aGlzLnBvaW50ZXI7XG5cblx0XHQvL2V2ZW50SnNvbi5yYXcgPSBldmVudDtcblx0XHRpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPT0gMHhmZikge1xuXHRcdFx0Ly8gTWV0YSBFdmVudFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbWV0YSBldmVudCB3ZSBzaG91bGQgZW1pdCB0aGUgZGF0YSBhbmQgaW1tZWRpYXRlbHkgbW92ZSB0byB0aGUgbmV4dCBldmVudFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIGlmIHdlIGxldCBpdCBydW4gdGhyb3VnaCB0aGUgbmV4dCBjeWNsZSBhIHNsaWdodCBkZWxheSB3aWxsIGFjY3VtdWxhdGUgaWYgbXVsdGlwbGUgdHJhY2tzXG5cdFx0XHQvLyBhcmUgYmVpbmcgcGxheWVkIHNpbXVsdGFuZW91c2x5XG5cblx0XHRcdHN3aXRjaCh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV0pIHtcblx0XHRcdFx0Y2FzZSAweDAwOiAvLyBTZXF1ZW5jZSBOdW1iZXJcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdTZXF1ZW5jZSBOdW1iZXInO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDB4MDE6IC8vIFRleHQgRXZlbnRcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdUZXh0IEV2ZW50Jztcblx0XHRcdFx0XHRldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMHgwMjogLy8gQ29weXJpZ2h0IE5vdGljZVxuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ0NvcHlyaWdodCBOb3RpY2UnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDB4MDM6IC8vIFNlcXVlbmNlL1RyYWNrIE5hbWVcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdTZXF1ZW5jZS9UcmFjayBOYW1lJztcblx0XHRcdFx0XHRldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMHgwNDogLy8gSW5zdHJ1bWVudCBOYW1lXG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnSW5zdHJ1bWVudCBOYW1lJztcblx0XHRcdFx0XHRldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMHgwNTogLy8gTHlyaWNcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdMeXJpYyc7XG5cdFx0XHRcdFx0ZXZlbnRKc29uLnN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nRGF0YShldmVudFN0YXJ0SW5kZXgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDB4MDY6IC8vIE1hcmtlclxuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ01hcmtlcic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMHgwNzogLy8gQ3VlIFBvaW50XG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnQ3VlIFBvaW50Jztcblx0XHRcdFx0XHRldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMHgwOTogLy8gRGV2aWNlIE5hbWVcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdEZXZpY2UgTmFtZSc7XG5cdFx0XHRcdFx0ZXZlbnRKc29uLnN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nRGF0YShldmVudFN0YXJ0SW5kZXgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDB4MjA6IC8vIE1JREkgQ2hhbm5lbCBQcmVmaXhcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdNSURJIENoYW5uZWwgUHJlZml4Jztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAweDIxOiAvLyBNSURJIFBvcnRcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdNSURJIFBvcnQnO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5kYXRhID0gVXRpbHMuYnl0ZXNUb051bWJlcihbdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDNdXSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMHgyRjogLy8gRW5kIG9mIFRyYWNrXG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnRW5kIG9mIFRyYWNrJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAweDUxOiAvLyBTZXQgVGVtcG9cblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdTZXQgVGVtcG8nO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5kYXRhID0gTWF0aC5yb3VuZCg2MDAwMDAwMCAvIFV0aWxzLmJ5dGVzVG9OdW1iZXIodGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDMsIGV2ZW50U3RhcnRJbmRleCArIDYpKSk7XG5cdFx0XHRcdFx0dGhpcy50ZW1wbyA9IGV2ZW50SnNvbi5kYXRhO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDB4NTQ6IC8vIFNNVFBFIE9mZnNldFxuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1NNVFBFIE9mZnNldCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMHg1ODogLy8gVGltZSBTaWduYXR1cmVcblx0XHRcdFx0XHQvLyBGRiA1OCAwNCBubiBkZCBjYyBiYlxuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1RpbWUgU2lnbmF0dXJlJztcblx0XHRcdFx0XHRldmVudEpzb24uZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheShldmVudFN0YXJ0SW5kZXggKyAzLCBldmVudFN0YXJ0SW5kZXggKyA3KTtcblx0XHRcdFx0XHRldmVudEpzb24udGltZVNpZ25hdHVyZSA9IFwiXCIgKyBldmVudEpzb24uZGF0YVswXSArIFwiL1wiICsgTWF0aC5wb3coMiwgZXZlbnRKc29uLmRhdGFbMV0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDB4NTk6IC8vIEtleSBTaWduYXR1cmVcblx0XHRcdFx0XHQvLyBGRiA1OSAwMiBzZiBtaVxuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ0tleSBTaWduYXR1cmUnO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5kYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDMsIGV2ZW50U3RhcnRJbmRleCArIDUpO1xuXG5cdFx0XHRcdFx0aWYgKGV2ZW50SnNvbi5kYXRhWzBdID49IDApIHtcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5rZXlTaWduYXR1cmUgPSBDb25zdGFudHMuQ0lSQ0xFX09GX0ZJRlRIU1tldmVudEpzb24uZGF0YVswXV07XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50SnNvbi5kYXRhWzBdIDwgMCkge1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLmtleVNpZ25hdHVyZSA9IENvbnN0YW50cy5DSVJDTEVfT0ZfRk9VUlRIU1tNYXRoLmFicyhldmVudEpzb24uZGF0YVswXSldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChldmVudEpzb24uZGF0YVsxXSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRldmVudEpzb24ua2V5U2lnbmF0dXJlICs9IFwiIE1ham9yXCI7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50SnNvbi5kYXRhWzFdID09IDEpIHtcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5rZXlTaWduYXR1cmUgKz0gXCIgTWlub3JcIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAweDdGOiAvLyBTZXF1ZW5jZXItU3BlY2lmaWMgTWV0YS1ldmVudFxuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1NlcXVlbmNlci1TcGVjaWZpYyBNZXRhLWV2ZW50Jztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdVbmtub3duOiAnICsgdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdLnRvU3RyaW5nKDE2KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuZGF0YVt0aGlzLnBvaW50ZXIgKyBkZWx0YUJ5dGVDb3VudCArIDJdO1xuXHRcdFx0Ly8gU29tZSBtZXRhIGV2ZW50cyB3aWxsIGhhdmUgdmx2IHRoYXQgbmVlZHMgdG8gYmUgaGFuZGxlZFxuXG5cdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzICsgbGVuZ3RoO1xuXG5cdFx0fSBlbHNlIGlmKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdID09IDB4ZjApIHtcblx0XHRcdC8vIFN5c2V4XG5cdFx0XHRldmVudEpzb24ubmFtZSA9ICdTeXNleCc7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5kYXRhW3RoaXMucG9pbnRlciArIGRlbHRhQnl0ZUNvdW50ICsgMV07XG5cdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAyICsgbGVuZ3RoO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFZvaWNlIGV2ZW50XG5cdFx0XHRpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPCAweDgwKSB7XG5cdFx0XHRcdC8vIFJ1bm5pbmcgc3RhdHVzXG5cdFx0XHRcdGV2ZW50SnNvbi5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdFx0ZXZlbnRKc29uLm5vdGVOdW1iZXIgPSB0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XTtcblx0XHRcdFx0ZXZlbnRKc29uLm5vdGVOYW1lID0gQ29uc3RhbnRzLk5PVEVTW3RoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdXTtcblx0XHRcdFx0ZXZlbnRKc29uLnZlbG9jaXR5ID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdO1xuXG5cdFx0XHRcdGlmICh0aGlzLmxhc3RTdGF0dXMgPD0gMHg4Zikge1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ05vdGUgb2ZmJztcblx0XHRcdFx0XHRldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4ODAgKyAxO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5sYXN0U3RhdHVzIDw9IDB4OWYpIHtcblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdOb3RlIG9uJztcblx0XHRcdFx0XHRldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4OTAgKyAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMjtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5sYXN0U3RhdHVzID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF07XG5cblx0XHRcdFx0aWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4OGYpIHtcblx0XHRcdFx0XHQvLyBOb3RlIG9mZlxuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ05vdGUgb2ZmJztcblx0XHRcdFx0XHRldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4ODAgKyAxO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5ub3RlTnVtYmVyID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5ub3RlTmFtZSA9IENvbnN0YW50cy5OT1RFU1t0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV1dO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi52ZWxvY2l0eSA9IE1hdGgucm91bmQodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDJdIC8gMTI3ICogMTAwKTtcblx0XHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPD0gMHg5Zikge1xuXHRcdFx0XHRcdC8vIE5vdGUgb25cblx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdOb3RlIG9uJztcblx0XHRcdFx0XHRldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4OTAgKyAxO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5ub3RlTnVtYmVyID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5ub3RlTmFtZSA9IENvbnN0YW50cy5OT1RFU1t0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV1dO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi52ZWxvY2l0eSA9IE1hdGgucm91bmQodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDJdIC8gMTI3ICogMTAwKTtcblx0XHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPD0gMHhhZikge1xuXHRcdFx0XHRcdC8vIFBvbHlwaG9uaWMgS2V5IFByZXNzdXJlXG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnUG9seXBob25pYyBLZXkgUHJlc3N1cmUnO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHhhMCArIDE7XG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5vdGUgPSBDb25zdGFudHMuTk9URVNbdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdXTtcblx0XHRcdFx0XHRldmVudEpzb24ucHJlc3N1cmUgPSBldmVudFsyXTtcblx0XHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPD0gMHhiZikge1xuXHRcdFx0XHRcdC8vIENvbnRyb2xsZXIgQ2hhbmdlXG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnQ29udHJvbGxlciBDaGFuZ2UnO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHhiMCArIDE7XG5cdFx0XHRcdFx0ZXZlbnRKc29uLm51bWJlciA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAxXTtcblx0XHRcdFx0XHRldmVudEpzb24udmFsdWUgPSB0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMl07XG5cdFx0XHRcdFx0dGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4Y2YpIHtcblx0XHRcdFx0XHQvLyBQcm9ncmFtIENoYW5nZVxuXHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1Byb2dyYW0gQ2hhbmdlJztcblx0XHRcdFx0XHRldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4YzAgKyAxO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi52YWx1ZSA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAxXTtcblx0XHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAyO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPD0gMHhkZikge1xuXHRcdFx0XHRcdC8vIENoYW5uZWwgS2V5IFByZXNzdXJlXG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnQ2hhbm5lbCBLZXkgUHJlc3N1cmUnO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHhkMCArIDE7XG5cdFx0XHRcdFx0dGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMjtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4ZWYpIHtcblx0XHRcdFx0XHQvLyBQaXRjaCBCZW5kXG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnUGl0Y2ggQmVuZCc7XG5cdFx0XHRcdFx0ZXZlbnRKc29uLmNoYW5uZWwgPSB0aGlzLmxhc3RTdGF0dXMgLSAweGUwICsgMTtcblx0XHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnVW5rbm93bi4gIFBvaW50ZXI6ICcgKyB0aGlzLnBvaW50ZXIudG9TdHJpbmcoKSArICcgJyAgKyBldmVudFN0YXJ0SW5kZXgudG9TdHJpbmcoKSArICcgJyArIHRoaXMuZGF0YS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmRlbHRhICs9IGV2ZW50SnNvbi5kZWx0YTtcblx0XHR0aGlzLmV2ZW50cy5wdXNoKGV2ZW50SnNvbik7XG5cblx0XHRyZXR1cm4gZXZlbnRKc29uO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBwb2ludGVyIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHRyYWNrLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59XG5cdCAqL1xuXHRlbmRPZlRyYWNrKCkge1xuXHRcdGlmICh0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgMV0gPT0gMHhmZiAmJiB0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgMl0gPT0gMHgyZiAmJiB0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgM10gPT0gMHgwMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzLlRyYWNrID0gVHJhY2s7IiwiLyoqXG4gKiBDb250YWlucyBtaXNjIHN0YXRpYyB1dGlsaXR5IG1ldGhvZHMuXG4gKi9cbmNsYXNzIFV0aWxzIHtcblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzaW5nbGUgYnl0ZSB0byBhIGhleCBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyBieXRlVG9IZXgoYnl0ZSkge1xuXHRcdC8vIEVuc3VyZSBoZXggc3RyaW5nIGFsd2F5cyBoYXMgdHdvIGNoYXJzXG5cdFx0cmV0dXJuICgnMCcgKyBieXRlLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGJ5dGVzIHRvIGEgaGV4IHN0cmluZy5cblx0ICogQHBhcmFtIHthcnJheX0gYnl0ZUFycmF5XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyBieXRlc1RvSGV4KGJ5dGVBcnJheSkge1xuXHRcdHZhciBoZXggPSBbXTtcblx0XHRieXRlQXJyYXkuZm9yRWFjaChieXRlID0+IGhleC5wdXNoKFV0aWxzLmJ5dGVUb0hleChieXRlKSkpO1xuXHRcdHJldHVybiBoZXguam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgbnVtYmVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyaW5nXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdHN0YXRpYyBoZXhUb051bWJlcihoZXhTdHJpbmcpIHtcblx0XHRyZXR1cm4gcGFyc2VJbnQoaGV4U3RyaW5nLCAxNik7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYW4gYXJyYXkgb2YgYnl0ZXMgdG8gYSBudW1iZXIuXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGJ5dGVBcnJheVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRzdGF0aWMgYnl0ZXNUb051bWJlcihieXRlQXJyYXkpIHtcblx0XHRyZXR1cm4gVXRpbHMuaGV4VG9OdW1iZXIoVXRpbHMuYnl0ZXNUb0hleChieXRlQXJyYXkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBieXRlcyB0byBsZXR0ZXJzLlxuXHQgKiBAcGFyYW0ge2FycmF5fSBieXRlQXJyYXlcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIGJ5dGVzVG9MZXR0ZXJzKGJ5dGVBcnJheSkge1xuXHRcdHZhciBsZXR0ZXJzID0gW107XG5cdFx0Ynl0ZUFycmF5LmZvckVhY2goYnl0ZSA9PiBsZXR0ZXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSkpO1xuXHRcdHJldHVybiBsZXR0ZXJzLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGVjaW1hbCB0byBpdCdzIGJpbmFyeSByZXByZXNlbnRhdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGRlY1xuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRzdGF0aWMgZGVjVG9CaW5hcnkoZGVjKSB7XG4gICAgXHRyZXR1cm4gKGRlYyA+Pj4gMCkudG9TdHJpbmcoMik7XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgYSB2YXJpYWJsZSBsZW5ndGggdmFsdWUuXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGJ5dGVBcnJheVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRzdGF0aWMgcmVhZFZhckludChieXRlQXJyYXkpIHtcblx0XHR2YXIgcmVzdWx0ID0gMDtcblx0XHRieXRlQXJyYXkuZm9yRWFjaChudW1iZXIgPT4ge1xuXHRcdFx0dmFyIGIgPSBudW1iZXI7XG5cdFx0XHRpZiAoYiAmIDB4ODApIHtcblx0XHRcdFx0cmVzdWx0ICs9IChiICYgMHg3Zik7XG5cdFx0XHRcdHJlc3VsdCA8PD0gNztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIGIgaXMgdGhlIGxhc3QgYnl0ZSAqL1xuXHRcdFx0XHRyZXN1bHQgKz0gYjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIGF0b2Ioc3RyaW5nKSB7XG5cdFx0aWYgKHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nKSByZXR1cm4gYXRvYihzdHJpbmcpO1xuXHRcdHJldHVybiBuZXcgQnVmZmVyKHN0cmluZywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcblx0fVxufVxuXG5leHBvcnRzLlV0aWxzID0gVXRpbHM7Il19


/***/ }),

/***/ "./node_modules/midi-writer-js/build/index.js":
/*!****************************************************!*\
  !*** ./node_modules/midi-writer-js/build/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer, process) {

var tonalMidi = __webpack_require__(/*! tonal-midi */ "./node_modules/tonal-midi/index.js");

/**
 * MIDI file format constants.
 * @return {Constants}
 */
var Constants = {
  VERSION: __webpack_require__(/*! ../package.json */ "./node_modules/midi-writer-js/package.json").version,
  HEADER_CHUNK_TYPE: [0x4d, 0x54, 0x68, 0x64],
  // Mthd
  HEADER_CHUNK_LENGTH: [0x00, 0x00, 0x00, 0x06],
  // Header size for SMF
  HEADER_CHUNK_FORMAT0: [0x00, 0x00],
  // Midi Type 0 id
  HEADER_CHUNK_FORMAT1: [0x00, 0x01],
  // Midi Type 1 id
  HEADER_CHUNK_DIVISION: [0x00, 0x80],
  // Defaults to 128 ticks per beat
  TRACK_CHUNK_TYPE: [0x4d, 0x54, 0x72, 0x6b],
  // MTrk,
  META_EVENT_ID: 0xFF,
  META_TEXT_ID: 0x01,
  META_COPYRIGHT_ID: 0x02,
  META_TRACK_NAME_ID: 0x03,
  META_INSTRUMENT_NAME_ID: 0x04,
  META_LYRIC_ID: 0x05,
  META_MARKER_ID: 0x06,
  META_CUE_POINT: 0x07,
  META_TEMPO_ID: 0x51,
  META_SMTPE_OFFSET: 0x54,
  META_TIME_SIGNATURE_ID: 0x58,
  META_KEY_SIGNATURE_ID: 0x59,
  META_END_OF_TRACK_ID: [0x2F, 0x00],
  CONTROLLER_CHANGE_STATUS: 0xB0,
  // includes channel number (0)
  PROGRAM_CHANGE_STATUS: 0xC0 // includes channel number (0)

};

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/**
 * Holds all data for a "controller change" MIDI event
 * @param {object} fields {controllerNumber: integer, controllerValue: integer}
 * @return {ControllerChangeEvent}
 */

var ControllerChangeEvent = function ControllerChangeEvent(fields) {
  _classCallCheck(this, ControllerChangeEvent);

  this.type = 'controller'; // delta time defaults to 0.

  this.data = Utils.numberToVariableLength(0x00).concat(Constants.CONTROLLER_CHANGE_STATUS, fields.controllerNumber, fields.controllerValue);
};

/**
 * Static utility functions used throughout the library.
 */

var Utils$1 =
/*#__PURE__*/
function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, null, [{
    key: "version",

    /**
     * Gets MidiWriterJS version number.
     * @return {string}
     */
    value: function version() {
      return Constants.VERSION;
    }
    /**
     * Convert a string to an array of bytes
     * @param {string} string
     * @return {array}
     */

  }, {
    key: "stringToBytes",
    value: function stringToBytes(string) {
      return string.split('').map(function (char) {
        return char.charCodeAt();
      });
    }
    /**
     * Checks if argument is a valid number.
     * @param {*} n - Value to check
     * @return {boolean}
     */

  }, {
    key: "isNumeric",
    value: function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    /**
        * Returns the correct MIDI number for the specified pitch.
        * Uses Tonal Midi - https://github.com/danigb/tonal/tree/master/packages/midi
        * @param {(string|number)} pitch - 'C#4' or midi note code
        * @return {number}
        */

  }, {
    key: "getPitch",
    value: function getPitch(pitch) {
      return tonalMidi.toMidi(pitch);
    }
    /**
     * Translates number of ticks to MIDI timestamp format, returning an array of
     * hex strings with the time values. Midi has a very particular time to express time,
     * take a good look at the spec before ever touching this function.
     * Thanks to https://github.com/sergi/jsmidi
     *
     * @param {number} ticks - Number of ticks to be translated
     * @return {array} - Bytes that form the MIDI time value
     */

  }, {
    key: "numberToVariableLength",
    value: function numberToVariableLength(ticks) {
      var buffer = ticks & 0x7F;

      while (ticks = ticks >> 7) {
        buffer <<= 8;
        buffer |= ticks & 0x7F | 0x80;
      }

      var bList = [];

      while (true) {
        bList.push(buffer & 0xff);
        if (buffer & 0x80) buffer >>= 8;else {
          break;
        }
      }

      return bList;
    }
    /**
     * Counts number of bytes in string
     * @param {string} s
     * @return {array}
     */

  }, {
    key: "stringByteCount",
    value: function stringByteCount(s) {
      return encodeURI(s).split(/%..|./).length - 1;
    }
    /**
     * Get an int from an array of bytes.
     * @param {array} bytes
     * @return {number}
     */

  }, {
    key: "numberFromBytes",
    value: function numberFromBytes(bytes) {
      var hex = '';
      var stringResult;
      bytes.forEach(function (byte) {
        stringResult = byte.toString(16); // ensure string is 2 chars

        if (stringResult.length == 1) stringResult = "0" + stringResult;
        hex += stringResult;
      });
      return parseInt(hex, 16);
    }
    /**
     * Takes a number and splits it up into an array of bytes.  Can be padded by passing a number to bytesNeeded
     * @param {number} number
     * @param {number} bytesNeeded
     * @return {array} - Array of bytes
     */

  }, {
    key: "numberToBytes",
    value: function numberToBytes(number, bytesNeeded) {
      bytesNeeded = bytesNeeded || 1;
      var hexString = number.toString(16);

      if (hexString.length & 1) {
        // Make sure hex string is even number of chars
        hexString = '0' + hexString;
      } // Split hex string into an array of two char elements


      var hexArray = hexString.match(/.{2}/g); // Now parse them out as integers

      hexArray = hexArray.map(function (item) {
        return parseInt(item, 16);
      }); // Prepend empty bytes if we don't have enough

      if (hexArray.length < bytesNeeded) {
        while (bytesNeeded - hexArray.length > 0) {
          hexArray.unshift(0);
        }
      }

      return hexArray;
    }
    /**	
     * Converts value to array if needed.
     * @param {string} value
     * @return {array}
     */

  }, {
    key: "toArray",
    value: function toArray(value) {
      if (Array.isArray(value)) return value;
      return [value];
    }
    /**
     * Converts velocity to value 0-127
     * @param {number} velocity - Velocity value 1-100
     * @return {number}
     */

  }, {
    key: "convertVelocity",
    value: function convertVelocity(velocity) {
      // Max passed value limited to 100
      velocity = velocity > 100 ? 100 : velocity;
      return Math.round(velocity / 100 * 127);
    }
  }, {
    key: "getTickDuration",

    /**
     * Gets the total number of ticks of a specified duration.
     * Note: type=='note' defaults to quarter note, type==='rest' defaults to 0
     * @param {(string|array)} duration
     * @return {number}
     */
    value: function getTickDuration(duration) {
      if (Array.isArray(duration)) {
        // Recursively execute this method for each item in the array and return the sum of tick durations.
        return duration.map(function (value) {
          return Utils.getTickDuration(value);
        }).reduce(function (a, b) {
          return a + b;
        }, 0);
      }

      duration = duration.toString();

      if (duration.toLowerCase().charAt(0) === 't') {
        // If duration starts with 't' then the number that follows is an explicit tick count
        return parseInt(duration.substring(1));
      } // Need to apply duration here.  Quarter note == Constants.HEADER_CHUNK_DIVISION
      // Rounding only applies to triplets, which the remainder is handled below


      var quarterTicks = Utils.numberFromBytes(Constants.HEADER_CHUNK_DIVISION);
      return Math.round(quarterTicks * Utils.getDurationMultiplier(duration));
    }
    /**
     * Gets what to multiple ticks/quarter note by to get the specified duration.
     * Note: type=='note' defaults to quarter note, type==='rest' defaults to 0
     * @param {string} duration
     * @return {number}
     */

  }, {
    key: "getDurationMultiplier",
    value: function getDurationMultiplier(duration) {
      // Need to apply duration here.  Quarter note == Constants.HEADER_CHUNK_DIVISION
      switch (duration) {
        case '0':
          return 0;

        case '1':
          return 4;

        case '2':
          return 2;

        case 'd2':
          return 3;

        case '4':
          return 1;

        case '4t':
          return 0.666;

        case 'd4':
          return 1.5;

        case '8':
          return 0.5;

        case '8t':
          // For 8th triplets, let's divide a quarter by 3, round to the nearest int, and substract the remainder to the last one.
          return 0.33;

        case 'd8':
          return 0.75;

        case '16':
          return 0.25;

        case '16t':
          return 0.166;

        case '32':
          return 0.125;

        case '64':
          return 0.0625;

        default: // Notes default to a quarter, rests default to 0
        //return type === 'note' ? 1 : 0;

      }

      throw duration + ' is not a valid duration.';
    }
  }]);

  return Utils;
}();

/**
 * Holds all data for a "note on" MIDI event
 * @param {object} fields {data: []}
 * @return {NoteOnEvent}
 */

var NoteOnEvent =
/*#__PURE__*/
function () {
  function NoteOnEvent(fields) {
    _classCallCheck(this, NoteOnEvent);

    // Set default fields
    fields = Object.assign({
      channel: 1,
      startTick: null,
      velocity: 50,
      wait: 0
    }, fields);
    this.type = 'note-on';
    this.channel = fields.channel;
    this.pitch = fields.pitch;
    this.wait = fields.wait;
    this.velocity = fields.velocity;
    this.startTick = fields.startTick;
    this.midiNumber = Utils$1.getPitch(this.pitch);
    this.tick = null;
    this.delta = null;
    this.data = fields.data;
  }
  /**
   * Builds int array for this event.
   * @param {Track} track - parent track
   * @return {NoteOnEvent}
   */


  _createClass(NoteOnEvent, [{
    key: "buildData",
    value: function buildData(track) {
      this.data = []; // Explicitly defined startTick event

      if (this.startTick) {
        this.tick = this.startTick; // If this is the first event in the track then use event's starting tick as delta.

        if (track.tickPointer == 0) {
          this.delta = this.tick;
        }
      } else {
        this.delta = Utils$1.getTickDuration(this.wait);
        this.tick = track.tickPointer + this.delta;
      }

      this.data = Utils$1.numberToVariableLength(this.delta).concat(this.getStatusByte(), this.midiNumber, Utils$1.convertVelocity(this.velocity));
      return this;
    }
    /**
     * Gets the note on status code based on the selected channel. 0x9{0-F}
     * Note on at channel 0 is 0x90 (144)
     * 0 = Ch 1
     * @return {number}
     */

  }, {
    key: "getStatusByte",
    value: function getStatusByte() {
      return 144 + this.channel - 1;
    }
  }]);

  return NoteOnEvent;
}();

/**
 * Holds all data for a "note off" MIDI event
 * @param {object} fields {data: []}
 * @return {NoteOffEvent}
 */

var NoteOffEvent =
/*#__PURE__*/
function () {
  function NoteOffEvent(fields) {
    _classCallCheck(this, NoteOffEvent);

    // Set default fields
    fields = Object.assign({
      channel: 1,
      noteOnTick: null,
      velocity: 50
    }, fields);
    this.type = 'note-off';
    this.channel = fields.channel;
    this.pitch = fields.pitch;
    this.duration = fields.duration;
    this.velocity = fields.velocity;
    this.noteOnTick = fields.noteOnTick;
    this.midiNumber = Utils$1.getPitch(this.pitch);
    this.tick = null;
    this.delta = Utils$1.getTickDuration(this.duration);
    this.data = fields.data;
  }
  /**
   * Builds int array for this event.
   * @param {Track} track - parent track
   * @return {NoteOffEvent}
   */


  _createClass(NoteOffEvent, [{
    key: "buildData",
    value: function buildData(track) {
      if (this.noteOnTick) {
        this.tick = this.noteOnTick + Utils$1.getTickDuration(this.duration);
      } else {
        this.tick = this.delta + track.tickPointer;
      }

      this.data = Utils$1.numberToVariableLength(this.delta).concat(this.getStatusByte(), this.midiNumber, Utils$1.convertVelocity(this.velocity));
      return this;
    }
    /**
     * Gets the note off status code based on the selected channel. 0x8{0-F}
     * Note off at channel 0 is 0x80 (128)
     * 0 = Ch 1
     * @return {number}
     */

  }, {
    key: "getStatusByte",
    value: function getStatusByte() {
      return 128 + this.channel - 1;
    }
  }]);

  return NoteOffEvent;
}();

/**
 * Wrapper for noteOnEvent/noteOffEvent objects that builds both events.
 * @param {object} fields - {pitch: '[C4]', duration: '4', wait: '4', velocity: 1-100}
 * @return {NoteEvent}
 */

var NoteEvent =
/*#__PURE__*/
function () {
  function NoteEvent(fields) {
    _classCallCheck(this, NoteEvent);

    // Set default fields
    fields = Object.assign({
      channel: 1,
      repeat: 1,
      sequential: false,
      startTick: null,
      velocity: 50,
      wait: 0
    }, fields);
    this.data = [];
    this.type = 'note';
    this.pitch = Utils$1.toArray(fields.pitch);
    this.channel = fields.channel;
    this.duration = fields.duration;
    this.grace = fields.grace;
    this.repeat = fields.repeat;
    this.sequential = fields.sequential;
    this.startTick = fields.startTick;
    this.velocity = fields.velocity;
    this.wait = fields.wait;
    this.tickDuration = Utils$1.getTickDuration(this.duration);
    this.restDuration = Utils$1.getTickDuration(this.wait);
    this.events = []; // Hold actual NoteOn/NoteOff events
  }
  /**
   * Builds int array for this event.
   * @return {NoteEvent}
   */


  _createClass(NoteEvent, [{
    key: "buildData",
    value: function buildData() {
      var _this = this;

      // Reset data array
      this.data = [];
      var tickDuration = this.tickDuration;
      var restDuration = this.restDuration; // Apply grace note(s) and subtract ticks (currently 1 tick per grace note) from tickDuration so net value is the same

      if (this.grace) {
        var graceDuration = 1;
        this.grace = Utils$1.toArray(this.grace);
        this.grace.forEach(function (pitch) {
          var noteEvent = new NoteEvent({
            pitch: _this.grace,
            duration: 'T' + graceDuration
          });
          _this.data = _this.data.concat(noteEvent.data);
          tickDuration -= graceDuration;
        });
      } // fields.pitch could be an array of pitches.
      // If this.sequential === true then it's a sequential string of notes that requires separate NoteOnEvents.

      if (!this.sequential) {
        // Handle repeat
        for (var j = 0; j < this.repeat; j++) {
          // Note on
          this.pitch.forEach(function (p, i) {
            if (i == 0) {
              var noteOnNew = new NoteOnEvent({
                channel: _this.channel,
                wait: _this.wait,
                velocity: _this.velocity,
                pitch: p,
                startTick: _this.startTick
              });
            } else {
              // Running status (can ommit the note on status)
              //noteOn = new NoteOnEvent({data: [0, Utils.getPitch(p), Utils.convertVelocity(this.velocity)]});
              var noteOnNew = new NoteOnEvent({
                channel: _this.channel,
                wait: 0,
                velocity: _this.velocity,
                pitch: p,
                startTick: _this.startTick
              });
            }

            _this.events.push(noteOnNew);
          }); // Note off

          this.pitch.forEach(function (p, i) {
            if (i == 0) {
              //noteOff = new NoteOffEvent({data: Utils.numberToVariableLength(tickDuration).concat(this.getNoteOffStatus(), Utils.getPitch(p), Utils.convertVelocity(this.velocity))});
              var noteOffNew = new NoteOffEvent({
                channel: _this.channel,
                duration: _this.duration,
                velocity: _this.velocity,
                pitch: p,
                noteOnTick: _this.startTick
              });
            } else {
              // Running status (can ommit the note off status)
              //noteOff = new NoteOffEvent({data: [0, Utils.getPitch(p), Utils.convertVelocity(this.velocity)]});
              var noteOffNew = new NoteOffEvent({
                channel: _this.channel,
                duration: 0,
                velocity: _this.velocity,
                pitch: p,
                noteOnTick: _this.startTick
              });
            }

            _this.events.push(noteOffNew);
          });
        }
      } else {
        // Handle repeat
        for (var j = 0; j < this.repeat; j++) {
          this.pitch.forEach(function (p, i) {
            // restDuration only applies to first note
            if (i > 0) {
              restDuration = 0;
            } // If duration is 8th triplets we need to make sure that the total ticks == quarter note.
            // So, the last one will need to be the remainder


            if (_this.duration === '8t' && i == _this.pitch.length - 1) {
              var quarterTicks = Utils$1.numberFromBytes(Constants.HEADER_CHUNK_DIVISION);
              tickDuration = quarterTicks - tickDuration * 2;
            }

            var noteOnNew = new NoteOnEvent({
              channel: _this.channel,
              wait: i > 0 ? 0 : _this.wait,
              // wait only applies to first note in repetition
              velocity: _this.velocity,
              pitch: p,
              startTick: _this.startTick
            });
            var noteOffNew = new NoteOffEvent({
              channel: _this.channel,
              duration: _this.duration,
              velocity: _this.velocity,
              pitch: p,
              noteOnTick: _this.startTick
            });

            _this.events.push(noteOnNew, noteOffNew);
          });
        }
      }

      return this;
    }
  }]);

  return NoteEvent;
}();

/**
 * Holds all data for a "program change" MIDI event
 * @param {object} fields {instrument: integer}
 * @return {ProgramChangeEvent}
 */

var ProgramChangeEvent = function ProgramChangeEvent(fields) {
  _classCallCheck(this, ProgramChangeEvent);

  this.type = 'program'; // delta time defaults to 0.

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.PROGRAM_CHANGE_STATUS, fields.instrument);
};

/**
 * Object representation of a tempo meta event.
 * @param {string} text - Copyright text
 * @return {CopyrightEvent}
 */

var CopyrightEvent = function CopyrightEvent(text) {
  _classCallCheck(this, CopyrightEvent);

  this.type = 'copyright';
  var textBytes = Utils$1.stringToBytes(text); // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_COPYRIGHT_ID, Utils$1.numberToVariableLength(textBytes.length), // Size
  textBytes // Text
  );
};

/**
 * Object representation of a cue point meta event.
 * @param {string} text - Cue point text
 * @return {CuePointEvent}
 */

var CuePointEvent = function CuePointEvent(text) {
  _classCallCheck(this, CuePointEvent);

  this.type = 'marker';
  var textBytes = Utils$1.stringToBytes(text); // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_CUE_POINT, Utils$1.numberToVariableLength(textBytes.length), // Size
  textBytes // Text
  );
};

/**
 * Object representation of a end track meta event.
 * @return {EndTrackEvent}
 */

var EndTrackEvent = function EndTrackEvent() {
  _classCallCheck(this, EndTrackEvent);

  this.type = 'end-track'; // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_END_OF_TRACK_ID);
};

/**
 * Object representation of an instrument name meta event.
 * @param {number} bpm - Beats per minute
 * @return {InstrumentNameEvent}
 */

var InstrumentNameEvent = function InstrumentNameEvent(text) {
  _classCallCheck(this, InstrumentNameEvent);

  this.type = 'instrument-name';
  var textBytes = Utils$1.stringToBytes(text); // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_INSTRUMENT_NAME_ID, Utils$1.numberToVariableLength(textBytes.length), // Size
  textBytes // Instrument name
  );
};

/**
 * Object representation of a key signature meta event.
 * @return {KeySignatureEvent}
 */

var KeySignatureEvent = function KeySignatureEvent(sf, mi) {
  _classCallCheck(this, KeySignatureEvent);

  this.type = 'key-signature';
  var mode = mi || 0;
  sf = sf || 0; //	Function called with string notation

  if (typeof mi === 'undefined') {
    var fifths = [['Cb', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#'], ['ab', 'eb', 'bb', 'f', 'c', 'g', 'd', 'a', 'e', 'b', 'f#', 'c#', 'g#', 'd#', 'a#']];
    var _sflen = sf.length;
    var note = sf || 'C';
    if (sf[0] === sf[0].toLowerCase()) mode = 1;

    if (_sflen > 1) {
      switch (sf.charAt(_sflen - 1)) {
        case 'm':
          mode = 1;
          note = sf.charAt(0).toLowerCase();
          note = note.concat(sf.substring(1, _sflen - 1));
          break;

        case '-':
          mode = 1;
          note = sf.charAt(0).toLowerCase();
          note = note.concat(sf.substring(1, _sflen - 1));
          break;

        case 'M':
          mode = 0;
          note = sf.charAt(0).toUpperCase();
          note = note.concat(sf.substring(1, _sflen - 1));
          break;

        case '+':
          mode = 0;
          note = sf.charAt(0).toUpperCase();
          note = note.concat(sf.substring(1, _sflen - 1));
          break;
      }
    }

    var fifthindex = fifths[mode].indexOf(note);
    sf = fifthindex === -1 ? 0 : fifthindex - 7;
  } // Start with zero time delta


  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_KEY_SIGNATURE_ID, [0x02], // Size
  Utils$1.numberToBytes(sf, 1), // Number of sharp or flats ( < 0 flat; > 0 sharp)
  Utils$1.numberToBytes(mode, 1) // Mode: 0 major, 1 minor
  );
};

/**
 * Object representation of a lyric meta event.
 * @param {string} text - Lyric text
 * @return {LyricEvent}
 */

var LyricEvent = function LyricEvent(text) {
  _classCallCheck(this, LyricEvent);

  this.type = 'marker';
  var textBytes = Utils$1.stringToBytes(text); // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_LYRIC_ID, Utils$1.numberToVariableLength(textBytes.length), // Size
  textBytes // Text
  );
};

/**
 * Object representation of a marker meta event.
 * @param {string} text - Marker text
 * @return {MarkerEvent}
 */

var MarkerEvent = function MarkerEvent(text) {
  _classCallCheck(this, MarkerEvent);

  this.type = 'marker';
  var textBytes = Utils$1.stringToBytes(text); // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_MARKER_ID, Utils$1.numberToVariableLength(textBytes.length), // Size
  textBytes // Text
  );
};

/**
 * Object representation of a tempo meta event.
 * @param {number} bpm - Beats per minute
 * @return {TempoEvent}
 */

var TempoEvent = function TempoEvent(bpm) {
  _classCallCheck(this, TempoEvent);

  this.type = 'tempo';
  var tempo = Math.round(60000000 / bpm); // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_TEMPO_ID, [0x03], // Size
  Utils$1.numberToBytes(tempo, 3) // Tempo, 3 bytes
  );
};

/**
 * Object representation of a tempo meta event.
 * @param {number} bpm - Beats per minute
 * @return {TextEvent}
 */

var TextEvent = function TextEvent(text) {
  _classCallCheck(this, TextEvent);

  this.type = 'text';
  var textBytes = Utils$1.stringToBytes(text); // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_TEXT_ID, Utils$1.numberToVariableLength(textBytes.length), // Size
  textBytes // Text
  );
};

/**
 * Object representation of a time signature meta event.
 * @return {TimeSignatureEvent}
 */

var TimeSignatureEvent = function TimeSignatureEvent(numerator, denominator, midiclockspertick, notespermidiclock) {
  _classCallCheck(this, TimeSignatureEvent);

  this.type = 'time-signature'; // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_TIME_SIGNATURE_ID, [0x04], // Size
  Utils$1.numberToBytes(numerator, 1), // Numerator, 1 bytes
  Utils$1.numberToBytes(Math.log2(denominator), 1), // Denominator is expressed as pow of 2, 1 bytes
  Utils$1.numberToBytes(midiclockspertick || 24, 1), // MIDI Clocks per tick, 1 bytes
  Utils$1.numberToBytes(notespermidiclock || 8, 1) // Number of 1/32 notes per MIDI clocks, 1 bytes
  );
};

/**
 * Object representation of a tempo meta event.
 * @param {number} bpm - Beats per minute
 * @return {TrackNameEvent}
 */

var TrackNameEvent = function TrackNameEvent(text) {
  _classCallCheck(this, TrackNameEvent);

  this.type = 'track-name';
  var textBytes = Utils$1.stringToBytes(text); // Start with zero time delta

  this.data = Utils$1.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_TRACK_NAME_ID, Utils$1.numberToVariableLength(textBytes.length), // Size
  textBytes // Text
  );
};

/**
 * Holds all data for a track.
 * @param {object} fields {type: number, data: array, size: array, events: array}
 * @return {Track}
 */

var Track =
/*#__PURE__*/
function () {
  function Track() {
    _classCallCheck(this, Track);

    this.type = Constants.TRACK_CHUNK_TYPE;
    this.data = [];
    this.size = [];
    this.events = [];
    this.explicitTickEvents = []; // If there are any events with an explicit tick defined then we will create a "sub" track for those
    // and merge them in and the end.

    this.tickPointer = 0; // Each time an event is added this will increase
  }
  /**
   * Adds any event type to the track.
   * Events without a specific startTick property are assumed to be added in order of how they should output.
   * Events with a specific startTick property are set aside for now will be merged in during build process.
   * @param {(NoteEvent|ProgramChangeEvent)} events - Event object or array of Event objects.
   * @param {function} mapFunction - Callback which can be used to apply specific properties to all events. 
   * @return {Track}
   */


  _createClass(Track, [{
    key: "addEvent",
    value: function addEvent(events, mapFunction) {
      var _this = this;

      Utils$1.toArray(events).forEach(function (event, i) {
        if (event.type === 'note') {
          // Handle map function if provided
          if (typeof mapFunction === 'function') {
            var properties = mapFunction(i, event);

            if (_typeof(properties) === 'object') {
              for (var j in properties) {
                switch (j) {
                  case 'duration':
                    event.duration = properties[j];
                    break;

                  case 'sequential':
                    event.sequential = properties[j];
                    break;

                  case 'velocity':
                    event.velocity = Utils$1.convertVelocity(properties[j]);
                    break;
                }
              }
            }
          } // If this note event has an explicit startTick then we need to set aside for now


          if (event.startTick !== null) {
            _this.explicitTickEvents.push(event);
          } else {
            // Push each on/off event to track's event stack
            event.buildData().events.forEach(function (e) {
              return _this.events.push(e);
            });
          }
        } else {
          _this.events.push(event);
        }
      });
      return this;
    }
    /**
     * Builds int array of all events.
     * @return {Track}
     */

  }, {
    key: "buildData",
    value: function buildData() {
      var _this2 = this;

      // Remove existing end track event and add one.
      // This makes sure it's at the very end of the event list.
      this.removeEventsByType('end-track').addEvent(new EndTrackEvent()); // Reset

      this.data = [];
      this.size = [];
      this.tickPointer = 0;
      this.events.forEach(function (event, eventIndex) {
        // Build event & add to total tick duration
        if (event.type === 'note-on' || event.type === 'note-off') {
          _this2.data = _this2.data.concat(event.buildData(_this2).data);
          _this2.tickPointer = event.tick;
        } else {
          _this2.data = _this2.data.concat(event.data);
        }
      });
      this.mergeExplicitTickEvents();
      this.size = Utils$1.numberToBytes(this.data.length, 4); // 4 bytes long

      return this;
    }
  }, {
    key: "mergeExplicitTickEvents",
    value: function mergeExplicitTickEvents() {
      var _this3 = this;

      if (!this.explicitTickEvents.length) return; // First sort asc list of events by startTick

      this.explicitTickEvents.sort(function (a, b) {
        return a.startTick - b.startTick;
      }); // Now this.explicitTickEvents is in correct order, and so is this.events naturally.
      // For each explicit tick event, splice it into the main list of events and 
      // adjust the delta on the following events so they still play normally.

      this.explicitTickEvents.forEach(function (noteEvent) {
        // Convert NoteEvent to it's respective NoteOn/NoteOff events
        // Note that as we splice in events the delta for the NoteOff ones will
        // Need to change based on what comes before them after the splice.
        noteEvent.buildData().events.forEach(function (e) {
          return e.buildData(_this3);
        }); // Merge each event indivually into this track's event list.

        noteEvent.events.forEach(function (event) {
          return _this3.mergeSingleEvent(event);
        });
      }); // Hacky way to rebuild track with newly spliced events.  Need better solution.

      this.explicitTickEvents = [];
      this.buildData();
    }
    /**
     * Merges another track's events with this track.
     * @param {Track} track
     * @return {Track}
     */

  }, {
    key: "mergeTrack",
    value: function mergeTrack(track) {
      var _this4 = this;

      // First build this track to populate each event's tick property
      this.buildData(); // Then build track to be merged so that tick property is populated on all events & merge each event.

      track.buildData().events.forEach(function (event) {
        return _this4.mergeSingleEvent(event);
      });
    }
    /**
     * Merges a single event into this track's list of events based on event.tick property.
     * @param {NoteOnEvent|NoteOffEvent} - event
     * @return {Track}
     */

  }, {
    key: "mergeSingleEvent",
    value: function mergeSingleEvent(event) {
      // Find index of existing event we need to follow with 
      var lastEventIndex = 0;

      for (var i = 0; i < this.events.length; i++) {
        if (this.events[i].tick > event.tick) break;
        lastEventIndex = i;
      }

      var splicedEventIndex = lastEventIndex + 1; // Need to adjust the delta of this event to ensure it falls on the correct tick.

      event.delta = event.tick - this.events[lastEventIndex].tick; // Splice this event at lastEventIndex + 1

      this.events.splice(splicedEventIndex, 0, event); // Now adjust delta of all following events

      for (var i = splicedEventIndex + 1; i < this.events.length; i++) {
        // Since each existing event should have a tick value at this point we just need to
        // adjust delta to that the event still falls on the correct tick.
        this.events[i].delta = this.events[i].tick - this.events[i - 1].tick;
      }
    }
    /**
     * Removes all events matching specified type.
     * @param {string} eventType - Event type
     * @return {Track}
     */

  }, {
    key: "removeEventsByType",
    value: function removeEventsByType(eventType) {
      var _this5 = this;

      this.events.forEach(function (event, index) {
        if (event.type === eventType) {
          _this5.events.splice(index, 1);
        }
      });
      return this;
    }
    /**
     * Sets tempo of the MIDI file.
     * @param {number} bpm - Tempo in beats per minute.
     * @return {Track}
     */

  }, {
    key: "setTempo",
    value: function setTempo(bpm) {
      return this.addEvent(new TempoEvent(bpm));
    }
    /**
     * Sets time signature.
     * @param {number} numerator - Top number of the time signature.
     * @param {number} denominator - Bottom number of the time signature.
     * @param {number} midiclockspertick - Defaults to 24.
     * @param {number} notespermidiclock - Defaults to 8.
     * @return {Track}
     */

  }, {
    key: "setTimeSignature",
    value: function setTimeSignature(numerator, denominator, midiclockspertick, notespermidiclock) {
      return this.addEvent(new TimeSignatureEvent(numerator, denominator, midiclockspertick, notespermidiclock));
    }
    /**
     * Sets key signature.
     * @param {*} sf - 
     * @param {*} mi -
     * @return {Track}
     */

  }, {
    key: "setKeySignature",
    value: function setKeySignature(sf, mi) {
      return this.addEvent(new KeySignatureEvent(sf, mi));
    }
    /**
     * Adds text to MIDI file.
     * @param {string} text - Text to add.
     * @return {Track}
     */

  }, {
    key: "addText",
    value: function addText(text) {
      return this.addEvent(new TextEvent(text));
    }
    /**
     * Adds copyright to MIDI file.
     * @param {string} text - Text of copyright line.
     * @return {Track}
     */

  }, {
    key: "addCopyright",
    value: function addCopyright(text) {
      return this.addEvent(new CopyrightEvent(text));
    }
    /**
     * Adds Sequence/Track Name.
     * @param {string} text - Text of track name.
     * @return {Track}
     */

  }, {
    key: "addTrackName",
    value: function addTrackName(text) {
      return this.addEvent(new TrackNameEvent(text));
    }
    /**
     * Sets instrument name of track.
     * @param {string} text - Name of instrument.
     * @return {Track}
     */

  }, {
    key: "addInstrumentName",
    value: function addInstrumentName(text) {
      return this.addEvent(new InstrumentNameEvent(text));
    }
    /**
     * Adds marker to MIDI file.
     * @param {string} text - Marker text.
     * @return {Track}
     */

  }, {
    key: "addMarker",
    value: function addMarker(text) {
      return this.addEvent(new MarkerEvent(text));
    }
    /**
     * Adds cue point to MIDI file.
     * @param {string} text - Text of cue point.
     * @return {Track}
     */

  }, {
    key: "addCuePoint",
    value: function addCuePoint(text) {
      return this.addEvent(new CuePointEvent(text));
    }
    /**
     * Adds lyric to MIDI file.
     * @param {string} text - Lyric text to add.
     * @return {Track}
     */

  }, {
    key: "addLyric",
    value: function addLyric(text) {
      return this.addEvent(new LyricEvent(text));
    }
    /**
     * Channel mode messages
     * @return {Track}
     */

  }, {
    key: "polyModeOn",
    value: function polyModeOn() {
      var event = new NoteOnEvent({
        data: [0x00, 0xB0, 0x7E, 0x00]
      });
      return this.addEvent(event);
    }
  }]);

  return Track;
}();

var VexFlow =
/*#__PURE__*/
function () {
  function VexFlow() {
    _classCallCheck(this, VexFlow);
  } // code...

  /**
   * Support for converting VexFlow voice into MidiWriterJS track
   * @return MidiWritier.Track object
   */


  _createClass(VexFlow, [{
    key: "trackFromVoice",
    value: function trackFromVoice(voice) {
      var _this = this;

      var track = new Track();
      var wait;
      var pitches = [];
      voice.tickables.forEach(function (tickable) {
        pitches = [];

        if (tickable.noteType === 'n') {
          tickable.keys.forEach(function (key) {
            // build array of pitches
            pitches.push(_this.convertPitch(key));
          });
        } else if (tickable.noteType === 'r') {
          // move on to the next tickable and use this rest as a `wait` property for the next event
          wait = _this.convertDuration(tickable);
          return;
        }

        track.addEvent(new NoteEvent({
          pitch: pitches,
          duration: _this.convertDuration(tickable),
          wait: wait
        })); // reset wait

        wait = 0;
      });
      return track;
    }
    /**
     * Converts VexFlow pitch syntax to MidiWriterJS syntax
     * @param pitch string
     */

  }, {
    key: "convertPitch",
    value: function convertPitch(pitch) {
      return pitch.replace('/', '');
    }
    /**
     * Converts VexFlow duration syntax to MidiWriterJS syntax
     * @param note struct from VexFlow
     */

  }, {
    key: "convertDuration",
    value: function convertDuration(note) {
      switch (note.duration) {
        case 'w':
          return '1';

        case 'h':
          return note.isDotted() ? 'd2' : '2';

        case 'q':
          return note.isDotted() ? 'd4' : '4';

        case '8':
          return note.isDotted() ? 'd8' : '8';
      }

      return note.duration;
    }
  }]);

  return VexFlow;
}();

/**
 * Object representation of a header chunk section of a MIDI file.
 * @param {number} numberOfTracks - Number of tracks
 * @return {HeaderChunk}
 */

var HeaderChunk = function HeaderChunk(numberOfTracks) {
  _classCallCheck(this, HeaderChunk);

  this.type = Constants.HEADER_CHUNK_TYPE;
  var trackType = numberOfTracks > 1 ? Constants.HEADER_CHUNK_FORMAT1 : Constants.HEADER_CHUNK_FORMAT0;
  this.data = trackType.concat(Utils$1.numberToBytes(numberOfTracks, 2), // two bytes long,
  Constants.HEADER_CHUNK_DIVISION);
  this.size = [0, 0, 0, this.data.length];
};

/**
 * Object that puts together tracks and provides methods for file output.
 * @param {array|Track} tracks - A single {Track} object or an array of {Track} objects.
 * @return {Writer}
 */

var Writer =
/*#__PURE__*/
function () {
  function Writer(tracks) {
    var _this = this;

    _classCallCheck(this, Writer);

    // Ensure track is an array
    tracks = Utils$1.toArray(tracks);
    this.data = [];
    this.data.push(new HeaderChunk(tracks.length)); // For each track add final end of track event and build data

    tracks.forEach(function (track, i) {
      _this.data.push(track.buildData());
    });
  }
  /**
   * Builds the file into a Uint8Array
   * @return {Uint8Array}
   */


  _createClass(Writer, [{
    key: "buildFile",
    value: function buildFile() {
      var build = []; // Data consists of chunks which consists of data

      this.data.forEach(function (d) {
        return build = build.concat(d.type, d.size, d.data);
      });
      return new Uint8Array(build);
    }
    /**
     * Convert file buffer to a base64 string.  Different methods depending on if browser or node.
     * @return {string}
     */

  }, {
    key: "base64",
    value: function base64() {
      if (typeof btoa === 'function') return btoa(String.fromCharCode.apply(null, this.buildFile()));
      return Buffer.from(this.buildFile()).toString('base64');
    }
    /**
     * Get the data URI.
     * @return {string}
     */

  }, {
    key: "dataUri",
    value: function dataUri() {
      return 'data:audio/midi;base64,' + this.base64();
    }
    /**
     * Output to stdout
     * @return {string}
     */

  }, {
    key: "stdout",
    value: function stdout() {
      return process.stdout.write(new Buffer(this.buildFile()));
    }
    /**
     * Save to MIDI file
     * @param {string} filename
     */

  }, {
    key: "saveMIDI",
    value: function saveMIDI(filename) {
      var fs = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js");

      var buffer = new Buffer(this.buildFile());
      fs.writeFile(filename + '.mid', buffer, function (err) {
        if (err) throw err;
      });
    }
  }]);

  return Writer;
}();

var main = {
  Constants: Constants,
  ControllerChangeEvent: ControllerChangeEvent,
  NoteEvent: NoteEvent,
  ProgramChangeEvent: ProgramChangeEvent,
  Track: Track,
  Utils: Utils$1,
  VexFlow: VexFlow,
  Writer: Writer
};

module.exports = main;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/midi-writer-js/package.json":
/*!**************************************************!*\
  !*** ./node_modules/midi-writer-js/package.json ***!
  \**************************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, directories, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = {"_from":"midi-writer-js","_id":"midi-writer-js@1.7.1","_inBundle":false,"_integrity":"sha512-/BbEZjNALrr695CflzjIsFD+B+LmNgLEn0UnmdGfrnbLiI95JOdP6DW1545ep0tiYeMvOaA/ZgxyyQBV9jOITQ==","_location":"/midi-writer-js","_phantomChildren":{},"_requested":{"type":"tag","registry":true,"raw":"midi-writer-js","name":"midi-writer-js","escapedName":"midi-writer-js","rawSpec":"","saveSpec":null,"fetchSpec":"latest"},"_requiredBy":["#USER","/"],"_resolved":"https://registry.npmjs.org/midi-writer-js/-/midi-writer-js-1.7.1.tgz","_shasum":"3d732dbc4946c800a6fd26b5aecbb266ad63127d","_spec":"midi-writer-js","_where":"C:\\Users\\Carl\\Coding\\piano_fun","author":{"name":"Garrett Grimm"},"bugs":{"url":"https://github.com/grimmdude/MidiWriterJS/issues"},"bundleDependencies":false,"dependencies":{"tonal-midi":"^0.69.7"},"deprecated":false,"description":"A library providing an API for generating MIDI files.","devDependencies":{"@babel/core":"^7.2.2","@babel/plugin-transform-destructuring":"^7.2.0","@babel/preset-env":"^7.2.3","jsdoc":"^3.5.5","minami":"^1.1.1","mocha":"^5.2.0","rollup":"^1.0.1","rollup-plugin-babel":"^4.2.0","uglify-js":"^2.7.3","watch":"^1.0.2"},"directories":{"lib":"src","example":"examples","test":"test"},"homepage":"https://github.com/grimmdude/MidiWriterJS#readme","keywords":["midi","generator","music"],"license":"MIT","main":"build/index.js","name":"midi-writer-js","repository":{"type":"git","url":"git+https://github.com/grimmdude/MidiWriterJS.git"},"scripts":{"build":"mkdir -p build && rollup -c && npm run docs","docs":"jsdoc -r src README.md -d ./docs -t ./node_modules/minami","pretest":"npm run build","test":"mocha","watch":"watch 'npm run build' src"},"version":"1.7.1"};

/***/ }),

/***/ "./node_modules/midimessage/dist/index.min.js":
/*!****************************************************!*\
  !*** ./node_modules/midimessage/dist/index.min.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;(function(e){if(true){module.exports=e()}else { var t; }})(function(){var e,t,s;return function o(e,t,s){function a(n,i){if(!t[n]){if(!e[n]){var l=typeof require=="function"&&require;if(!i&&l)return require(n,!0);if(r)return r(n,!0);var h=new Error("Cannot find module '"+n+"'");throw h.code="MODULE_NOT_FOUND",h}var c=t[n]={exports:{}};e[n][0].call(c.exports,function(t){var s=e[n][1][t];return a(s?s:t)},c,c.exports,o,e,t,s)}return t[n].exports}var r=typeof require=="function"&&require;for(var n=0;n<s.length;n++)a(s[n]);return a}({1:[function(e,t,s){"use strict";Object.defineProperty(s,"__esModule",{value:true});s["default"]=function(e){function t(e){this._event=e;this._data=e.data;this.receivedTime=e.receivedTime;if(this._data&&this._data.length<2){console.warn("Illegal MIDI message of length",this._data.length);return}this._messageCode=e.data[0]&240;this.channel=e.data[0]&15;switch(this._messageCode){case 128:this.messageType="noteoff";this.key=e.data[1]&127;this.velocity=e.data[2]&127;break;case 144:this.messageType="noteon";this.key=e.data[1]&127;this.velocity=e.data[2]&127;break;case 160:this.messageType="keypressure";this.key=e.data[1]&127;this.pressure=e.data[2]&127;break;case 176:this.messageType="controlchange";this.controllerNumber=e.data[1]&127;this.controllerValue=e.data[2]&127;if(this.controllerNumber===120&&this.controllerValue===0){this.channelModeMessage="allsoundoff"}else if(this.controllerNumber===121){this.channelModeMessage="resetallcontrollers"}else if(this.controllerNumber===122){if(this.controllerValue===0){this.channelModeMessage="localcontroloff"}else{this.channelModeMessage="localcontrolon"}}else if(this.controllerNumber===123&&this.controllerValue===0){this.channelModeMessage="allnotesoff"}else if(this.controllerNumber===124&&this.controllerValue===0){this.channelModeMessage="omnimodeoff"}else if(this.controllerNumber===125&&this.controllerValue===0){this.channelModeMessage="omnimodeon"}else if(this.controllerNumber===126){this.channelModeMessage="monomodeon"}else if(this.controllerNumber===127){this.channelModeMessage="polymodeon"}break;case 192:this.messageType="programchange";this.program=e.data[1];break;case 208:this.messageType="channelpressure";this.pressure=e.data[1]&127;break;case 224:this.messageType="pitchbendchange";var t=e.data[2]&127;var s=e.data[1]&127;this.pitchBend=(t<<8)+s;break}}return new t(e)};t.exports=s["default"]},{}]},{},[1])(1)});
//# sourceMappingURL=dist/index.js.map

/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/note-parser/index.js":
/*!*******************************************!*\
  !*** ./node_modules/note-parser/index.js ***!
  \*******************************************/
/*! exports provided: regex, parse, build, midi, freq, letter, acc, pc, step, alt, chroma, oct */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regex", function() { return regex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "build", function() { return build; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "midi", function() { return midi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "freq", function() { return freq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "letter", function() { return letter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acc", function() { return acc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pc", function() { return pc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "step", function() { return step; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alt", function() { return alt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chroma", function() { return chroma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oct", function() { return oct; });


// util
function fillStr (s, num) { return Array(num + 1).join(s) }
function isNum (x) { return typeof x === 'number' }
function isStr (x) { return typeof x === 'string' }
function isDef (x) { return typeof x !== 'undefined' }
function midiToFreq (midi, tuning) {
  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)
}

var REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/
/**
 * A regex for matching note strings in scientific notation.
 *
 * @name regex
 * @function
 * @return {RegExp} the regexp used to parse the note name
 *
 * The note string should have the form `letter[accidentals][octave][element]`
 * where:
 *
 * - letter: (Required) is a letter from A to G either upper or lower case
 * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).
 * They can NOT be mixed.
 * - octave: (Optional) a positive or negative integer
 * - element: (Optional) additionally anything after the duration is considered to
 * be the element name (for example: 'C2 dorian')
 *
 * The executed regex contains (by array index):
 *
 * - 0: the complete string
 * - 1: the note letter
 * - 2: the optional accidentals
 * - 3: the optional octave
 * - 4: the rest of the string (trimmed)
 *
 * @example
 * var parser = require('note-parser')
 * parser.regex.exec('c#4')
 * // => ['c#4', 'c', '#', '4', '']
 * parser.regex.exec('c#4 major')
 * // => ['c#4major', 'c', '#', '4', 'major']
 * parser.regex().exec('CMaj7')
 * // => ['CMaj7', 'C', '', '', 'Maj7']
 */
function regex () { return REGEX }

var SEMITONES = [0, 2, 4, 5, 7, 9, 11]
/**
 * Parse a note name in scientific notation an return it's components,
 * and some numeric properties including midi number and frequency.
 *
 * @name parse
 * @function
 * @param {String} note - the note string to be parsed
 * @param {Boolean} isTonic - true the strings it's supposed to contain a note number
 * and some category (for example an scale: 'C# major'). It's false by default,
 * but when true, en extra tonicOf property is returned with the category ('major')
 * @param {Float} tunning - The frequency of A4 note to calculate frequencies.
 * By default it 440.
 * @return {Object} the parsed note name or null if not a valid note
 *
 * The parsed note name object will ALWAYS contains:
 * - letter: the uppercase letter of the note
 * - acc: the accidentals of the note (only sharps or flats)
 * - pc: the pitch class (letter + acc)
 * - step: s a numeric representation of the letter. It's an integer from 0 to 6
 * where 0 = C, 1 = D ... 6 = B
 * - alt: a numeric representation of the accidentals. 0 means no alteration,
 * positive numbers are for sharps and negative for flats
 * - chroma: a numeric representation of the pitch class. It's like midi for
 * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics
 * since, for example, chroma of 'Cb' and 'B' are both 11
 *
 * If the note has octave, the parser object will contain:
 * - oct: the octave number (as integer)
 * - midi: the midi number
 * - freq: the frequency (using tuning parameter as base)
 *
 * If the parameter `isTonic` is set to true, the parsed object will contain:
 * - tonicOf: the rest of the string that follows note name (left and right trimmed)
 *
 * @example
 * var parse = require('note-parser').parse
 * parse('Cb4')
 * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,
 *         oct: 4, midi: 59, freq: 246.94165062806206 }
 * // if no octave, no midi, no freq
 * parse('fx')
 * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })
 */
function parse (str, isTonic, tuning) {
  if (typeof str !== 'string') return null
  var m = REGEX.exec(str)
  if (!m || (!isTonic && m[4])) return null

  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }
  p.pc = p.letter + p.acc
  p.step = (p.letter.charCodeAt(0) + 3) % 7
  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length
  var pos = SEMITONES[p.step] + p.alt
  p.chroma = pos < 0 ? 12 + pos : pos % 12
  if (m[3]) { // has octave
    p.oct = +m[3]
    p.midi = pos + 12 * (p.oct + 1)
    p.freq = midiToFreq(p.midi, tuning)
  }
  if (isTonic) p.tonicOf = m[4]
  return p
}

var LETTERS = 'CDEFGAB'
function accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }
function octStr (n) { return !isNum(n) ? '' : '' + n }

/**
 * Create a string from a parsed object or `step, alteration, octave` parameters
 * @param {Object} obj - the parsed data object
 * @return {String} a note string or null if not valid parameters
 * @since 1.2
 * @example
 * parser.build(parser.parse('cb2')) // => 'Cb2'
 *
 * @example
 * // it accepts (step, alteration, octave) parameters:
 * parser.build(3) // => 'F'
 * parser.build(3, -1) // => 'Fb'
 * parser.build(3, -1, 4) // => 'Fb4'
 */
function build (s, a, o) {
  if (s === null || typeof s === 'undefined') return null
  if (s.step) return build(s.step, s.alt, s.oct)
  if (s < 0 || s > 6) return null
  return LETTERS.charAt(s) + accStr(a) + octStr(o)
}

/**
 * Get midi of a note
 *
 * @name midi
 * @function
 * @param {String|Integer} note - the note name or midi number
 * @return {Integer} the midi number of the note or null if not a valid note
 * or the note does NOT contains octave
 * @example
 * var parser = require('note-parser')
 * parser.midi('A4') // => 69
 * parser.midi('A') // => null
 * @example
 * // midi numbers are bypassed (even as strings)
 * parser.midi(60) // => 60
 * parser.midi('60') // => 60
 */
function midi (note) {
  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note
  var p = parse(note)
  return p && isDef(p.midi) ? p.midi : null
}

/**
 * Get freq of a note in hertzs (in a well tempered 440Hz A4)
 *
 * @name freq
 * @function
 * @param {String} note - the note name or note midi number
 * @param {String} tuning - (Optional) the A4 frequency (440 by default)
 * @return {Float} the freq of the number if hertzs or null if not valid note
 * @example
 * var parser = require('note-parser')
 * parser.freq('A4') // => 440
 * parser.freq('A') // => null
 * @example
 * // can change tuning (440 by default)
 * parser.freq('A4', 444) // => 444
 * parser.freq('A3', 444) // => 222
 * @example
 * // it accepts midi numbers (as numbers and as strings)
 * parser.freq(69) // => 440
 * parser.freq('69', 442) // => 442
 */
function freq (note, tuning) {
  var m = midi(note)
  return m === null ? null : midiToFreq(m, tuning)
}

function letter (src) { return (parse(src) || {}).letter }
function acc (src) { return (parse(src) || {}).acc }
function pc (src) { return (parse(src) || {}).pc }
function step (src) { return (parse(src) || {}).step }
function alt (src) { return (parse(src) || {}).alt }
function chroma (src) { return (parse(src) || {}).chroma }
function oct (src) { return (parse(src) || {}).oct }


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/sample-player/lib/events.js":
/*!**************************************************!*\
  !*** ./node_modules/sample-player/lib/events.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


module.exports = function (player) {
  /**
   * Adds a listener of an event
   * @chainable
   * @param {String} event - the event name
   * @param {Function} callback - the event handler
   * @return {SamplePlayer} the player
   * @example
   * player.on('start', function(time, note) {
   *   console.log(time, note)
   * })
   */
  player.on = function (event, cb) {
    if (arguments.length === 1 && typeof event === 'function') return player.on('event', event)
    var prop = 'on' + event
    var old = player[prop]
    player[prop] = old ? chain(old, cb) : cb
    return player
  }
  return player
}

function chain (fn1, fn2) {
  return function (a, b, c, d) { fn1(a, b, c, d); fn2(a, b, c, d) }
}


/***/ }),

/***/ "./node_modules/sample-player/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sample-player/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var player = __webpack_require__(/*! ./player */ "./node_modules/sample-player/lib/player.js")
var events = __webpack_require__(/*! ./events */ "./node_modules/sample-player/lib/events.js")
var notes = __webpack_require__(/*! ./notes */ "./node_modules/sample-player/lib/notes.js")
var scheduler = __webpack_require__(/*! ./scheduler */ "./node_modules/sample-player/lib/scheduler.js")
var midi = __webpack_require__(/*! ./midi */ "./node_modules/sample-player/lib/midi.js")

function SamplePlayer (ac, source, options) {
  return midi(scheduler(notes(events(player(ac, source, options)))))
}

if ( true && module.exports) module.exports = SamplePlayer
if (typeof window !== 'undefined') window.SamplePlayer = SamplePlayer


/***/ }),

/***/ "./node_modules/sample-player/lib/midi.js":
/*!************************************************!*\
  !*** ./node_modules/sample-player/lib/midi.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var midimessage = __webpack_require__(/*! midimessage */ "./node_modules/midimessage/dist/index.min.js")

module.exports = function (player) {
  /**
  * Connect a player to a midi input
  *
  * The options accepts:
  *
  * - channel: the channel to listen to. Listen to all channels by default.
  *
  * @param {MIDIInput} input
  * @param {Object} options - (Optional)
  * @return {SamplePlayer} the player
  * @example
  * var piano = player(...)
  * window.navigator.requestMIDIAccess().then(function (midiAccess) {
  *   midiAccess.inputs.forEach(function (midiInput) {
  *     piano.listenToMidi(midiInput)
  *   })
  * })
  */
  player.listenToMidi = function (input, options) {
    var started = {}
    var opts = options || {}
    var gain = opts.gain || function (vel) { return vel / 127 }

    input.onmidimessage = function (msg) {
      var mm = msg.messageType ? msg : midimessage(msg)
      if (mm.messageType === 'noteon' && mm.velocity === 0) {
        mm.messageType = 'noteoff'
      }
      if (opts.channel && mm.channel !== opts.channel) return

      switch (mm.messageType) {
        case 'noteon':
          started[mm.key] = player.play(mm.key, 0, { gain: gain(mm.velocity) })
          break
        case 'noteoff':
          if (started[mm.key]) {
            started[mm.key].stop()
            delete started[mm.key]
          }
          break
      }
    }
    return player
  }
  return player
}


/***/ }),

/***/ "./node_modules/sample-player/lib/notes.js":
/*!*************************************************!*\
  !*** ./node_modules/sample-player/lib/notes.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var note = __webpack_require__(/*! note-parser */ "./node_modules/sample-player/node_modules/note-parser/index.js")
var isMidi = function (n) { return n !== null && n !== [] && n >= 0 && n < 129 }
var toMidi = function (n) { return isMidi(n) ? +n : note.midi(n) }

// Adds note name to midi conversion
module.exports = function (player) {
  if (player.buffers) {
    var map = player.opts.map
    var toKey = typeof map === 'function' ? map : toMidi
    var mapper = function (name) {
      return name ? toKey(name) || name : null
    }

    player.buffers = mapBuffers(player.buffers, mapper)
    var start = player.start
    player.start = function (name, when, options) {
      var key = mapper(name)
      var dec = key % 1
      if (dec) {
        key = Math.floor(key)
        options = Object.assign(options || {}, { cents: Math.floor(dec * 100) })
      }
      return start(key, when, options)
    }
  }
  return player
}

function mapBuffers (buffers, toKey) {
  return Object.keys(buffers).reduce(function (mapped, name) {
    mapped[toKey(name)] = buffers[name]
    return mapped
  }, {})
}


/***/ }),

/***/ "./node_modules/sample-player/lib/player.js":
/*!**************************************************!*\
  !*** ./node_modules/sample-player/lib/player.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global AudioBuffer */


var ADSR = __webpack_require__(/*! adsr */ "./node_modules/adsr/index.js")

var EMPTY = {}
var DEFAULTS = {
  gain: 1,
  attack: 0.01,
  decay: 0.1,
  sustain: 0.9,
  release: 0.3,
  loop: false,
  cents: 0,
  loopStart: 0,
  loopEnd: 0
}

/**
 * Create a sample player.
 *
 * @param {AudioContext} ac - the audio context
 * @param {ArrayBuffer|Object<String,ArrayBuffer>} source
 * @param {Onject} options - (Optional) an options object
 * @return {player} the player
 * @example
 * var SamplePlayer = require('sample-player')
 * var ac = new AudioContext()
 * var snare = SamplePlayer(ac, <AudioBuffer>)
 * snare.play()
 */
function SamplePlayer (ac, source, options) {
  var connected = false
  var nextId = 0
  var tracked = {}
  var out = ac.createGain()
  out.gain.value = 1

  var opts = Object.assign({}, DEFAULTS, options)

  /**
   * @namespace
   */
  var player = { context: ac, out: out, opts: opts }
  if (source instanceof AudioBuffer) player.buffer = source
  else player.buffers = source

  /**
   * Start a sample buffer.
   *
   * The returned object has a function `stop(when)` to stop the sound.
   *
   * @param {String} name - the name of the buffer. If the source of the
   * SamplePlayer is one sample buffer, this parameter is not required
   * @param {Float} when - (Optional) when to start (current time if by default)
   * @param {Object} options - additional sample playing options
   * @return {AudioNode} an audio node with a `stop` function
   * @example
   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)
   * sample.start()
   * sample.start(5, { gain: 0.7 }) // name not required since is only one AudioBuffer
   * @example
   * var drums = player(ac, { snare: <AudioBuffer>, kick: <AudioBuffer>, ... }).connect(ac.destination)
   * drums.start('snare')
   * drums.start('snare', 0, { gain: 0.3 })
   */
  player.start = function (name, when, options) {
    // if only one buffer, reorder arguments
    if (player.buffer && name !== null) return player.start(null, name, when)

    var buffer = name ? player.buffers[name] : player.buffer
    if (!buffer) {
      console.warn('Buffer ' + name + ' not found.')
      return
    } else if (!connected) {
      console.warn('SamplePlayer not connected to any node.')
      return
    }

    var opts = options || EMPTY
    when = Math.max(ac.currentTime, when || 0)
    player.emit('start', when, name, opts)
    var node = createNode(name, buffer, opts)
    node.id = track(name, node)
    node.env.start(when)
    node.source.start(when)
    player.emit('started', when, node.id, node)
    if (opts.duration) node.stop(when + opts.duration)
    return node
  }

  // NOTE: start will be override so we can't copy the function reference
  // this is obviously not a good design, so this code will be gone soon.
  /**
   * An alias for `player.start`
   * @see player.start
   * @since 0.3.0
   */
  player.play = function (name, when, options) {
    return player.start(name, when, options)
  }

  /**
   * Stop some or all samples
   *
   * @param {Float} when - (Optional) an absolute time in seconds (or currentTime
   * if not specified)
   * @param {Array} nodes - (Optional) an array of nodes or nodes ids to stop
   * @return {Array} an array of ids of the stoped samples
   *
   * @example
   * var longSound = player(ac, <AudioBuffer>).connect(ac.destination)
   * longSound.start(ac.currentTime)
   * longSound.start(ac.currentTime + 1)
   * longSound.start(ac.currentTime + 2)
   * longSound.stop(ac.currentTime + 3) // stop the three sounds
   */
  player.stop = function (when, ids) {
    var node
    ids = ids || Object.keys(tracked)
    return ids.map(function (id) {
      node = tracked[id]
      if (!node) return null
      node.stop(when)
      return node.id
    })
  }
  /**
   * Connect the player to a destination node
   *
   * @param {AudioNode} destination - the destination node
   * @return {AudioPlayer} the player
   * @chainable
   * @example
   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)
   */
  player.connect = function (dest) {
    connected = true
    out.connect(dest)
    return player
  }

  player.emit = function (event, when, obj, opts) {
    if (player.onevent) player.onevent(event, when, obj, opts)
    var fn = player['on' + event]
    if (fn) fn(when, obj, opts)
  }

  return player

  // =============== PRIVATE FUNCTIONS ============== //

  function track (name, node) {
    node.id = nextId++
    tracked[node.id] = node
    node.source.onended = function () {
      var now = ac.currentTime
      node.source.disconnect()
      node.env.disconnect()
      node.disconnect()
      player.emit('ended', now, node.id, node)
    }
    return node.id
  }

  function createNode (name, buffer, options) {
    var node = ac.createGain()
    node.gain.value = 0 // the envelope will control the gain
    node.connect(out)

    node.env = envelope(ac, options, opts)
    node.env.connect(node.gain)

    node.source = ac.createBufferSource()
    node.source.buffer = buffer
    node.source.connect(node)
    node.source.loop = options.loop || opts.loop
    node.source.playbackRate.value = centsToRate(options.cents || opts.cents)
    node.source.loopStart = options.loopStart || opts.loopStart
    node.source.loopEnd = options.loopEnd || opts.loopEnd
    node.stop = function (when) {
      var time = when || ac.currentTime
      player.emit('stop', time, name)
      var stopAt = node.env.stop(time)
      node.source.stop(stopAt)
    }
    return node
  }
}

function isNum (x) { return typeof x === 'number' }
var PARAMS = ['attack', 'decay', 'sustain', 'release']
function envelope (ac, options, opts) {
  var env = ADSR(ac)
  var adsr = options.adsr || opts.adsr
  PARAMS.forEach(function (name, i) {
    if (adsr) env[name] = adsr[i]
    else env[name] = options[name] || opts[name]
  })
  env.value.value = isNum(options.gain) ? options.gain
    : isNum(opts.gain) ? opts.gain : 1
  return env
}

/*
 * Get playback rate for a given pitch change (in cents)
 * Basic [math](http://www.birdsoft.demon.co.uk/music/samplert.htm):
 * f2 = f1 * 2^( C / 1200 )
 */
function centsToRate (cents) { return cents ? Math.pow(2, cents / 1200) : 1 }

module.exports = SamplePlayer


/***/ }),

/***/ "./node_modules/sample-player/lib/scheduler.js":
/*!*****************************************************!*\
  !*** ./node_modules/sample-player/lib/scheduler.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArr = Array.isArray
var isObj = function (o) { return o && typeof o === 'object' }
var OPTS = {}

module.exports = function (player) {
  /**
   * Schedule a list of events to be played at specific time.
   *
   * It supports three formats of events for the events list:
   *
   * - An array with [time, note]
   * - An array with [time, object]
   * - An object with { time: ?, [name|note|midi|key]: ? }
   *
   * @param {Float} time - an absolute time to start (or AudioContext's
   * currentTime if provided number is 0)
   * @param {Array} events - the events list.
   * @return {Array} an array of ids
   *
   * @example
   * // Event format: [time, note]
   * var piano = player(ac, ...).connect(ac.destination)
   * piano.schedule(0, [ [0, 'C2'], [0.5, 'C3'], [1, 'C4'] ])
   *
   * @example
   * // Event format: an object { time: ?, name: ? }
   * var drums = player(ac, ...).connect(ac.destination)
   * drums.schedule(0, [
   *   { name: 'kick', time: 0 },
   *   { name: 'snare', time: 0.5 },
   *   { name: 'kick', time: 1 },
   *   { name: 'snare', time: 1.5 }
   * ])
   */
  player.schedule = function (time, events) {
    var now = player.context.currentTime
    var when = time < now ? now : time
    player.emit('schedule', when, events)
    var t, o, note, opts
    return events.map(function (event) {
      if (!event) return null
      else if (isArr(event)) {
        t = event[0]; o = event[1]
      } else {
        t = event.time; o = event
      }

      if (isObj(o)) {
        note = o.name || o.key || o.note || o.midi || null
        opts = o
      } else {
        note = o
        opts = OPTS
      }

      return player.start(note, when + (t || 0), opts)
    })
  }
  return player
}


/***/ }),

/***/ "./node_modules/sample-player/node_modules/note-parser/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sample-player/node_modules/note-parser/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/
/**
 * A regex for matching note strings in scientific notation.
 *
 * @name regex
 * @function
 * @return {RegExp} the regexp used to parse the note name
 *
 * The note string should have the form `letter[accidentals][octave][element]`
 * where:
 *
 * - letter: (Required) is a letter from A to G either upper or lower case
 * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).
 * They can NOT be mixed.
 * - octave: (Optional) a positive or negative integer
 * - element: (Optional) additionally anything after the duration is considered to
 * be the element name (for example: 'C2 dorian')
 *
 * The executed regex contains (by array index):
 *
 * - 0: the complete string
 * - 1: the note letter
 * - 2: the optional accidentals
 * - 3: the optional octave
 * - 4: the rest of the string (trimmed)
 *
 * @example
 * var parser = require('note-parser')
 * parser.regex.exec('c#4')
 * // => ['c#4', 'c', '#', '4', '']
 * parser.regex.exec('c#4 major')
 * // => ['c#4major', 'c', '#', '4', 'major']
 * parser.regex().exec('CMaj7')
 * // => ['CMaj7', 'C', '', '', 'Maj7']
 */
function regex () { return REGEX }

var SEMITONES = [0, 2, 4, 5, 7, 9, 11]
/**
 * Parse a note name in scientific notation an return it's components,
 * and some numeric properties including midi number and frequency.
 *
 * @name parse
 * @function
 * @param {String} note - the note string to be parsed
 * @param {Boolean} isTonic - true if the note is the tonic of something.
 * If true, en extra tonicOf property is returned. It's false by default.
 * @param {Float} tunning - The frequency of A4 note to calculate frequencies.
 * By default it 440.
 * @return {Object} the parsed note name or null if not a valid note
 *
 * The parsed note name object will ALWAYS contains:
 * - letter: the uppercase letter of the note
 * - acc: the accidentals of the note (only sharps or flats)
 * - pc: the pitch class (letter + acc)
 * - step: s a numeric representation of the letter. It's an integer from 0 to 6
 * where 0 = C, 1 = D ... 6 = B
 * - alt: a numeric representation of the accidentals. 0 means no alteration,
 * positive numbers are for sharps and negative for flats
 * - chroma: a numeric representation of the pitch class. It's like midi for
 * pitch classes. 0 = C, 1 = C#, 2 = D ... It can have negative values: -1 = Cb.
 * Can detect pitch class enhramonics.
 *
 * If the note has octave, the parser object will contain:
 * - oct: the octave number (as integer)
 * - midi: the midi number
 * - freq: the frequency (using tuning parameter as base)
 *
 * If the parameter `isTonic` is set to true, the parsed object will contain:
 * - tonicOf: the rest of the string that follows note name (left and right trimmed)
 *
 * @example
 * var parse = require('note-parser').parse
 * parse('Cb4')
 * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,
 *         oct: 4, midi: 59, freq: 246.94165062806206 }
 * // if no octave, no midi, no freq
 * parse('fx')
 * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })
 */
function parse (str, isTonic, tuning) {
  if (typeof str !== 'string') return null
  var m = REGEX.exec(str)
  if (!m || !isTonic && m[4]) return null

  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }
  p.pc = p.letter + p.acc
  p.step = (p.letter.charCodeAt(0) + 3) % 7
  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length
  p.chroma = SEMITONES[p.step] + p.alt
  if (m[3]) {
    p.oct = +m[3]
    p.midi = p.chroma + 12 * (p.oct + 1)
    p.freq = midiToFreq(p.midi, tuning)
  }
  if (isTonic) p.tonicOf = m[4]
  return p
}

/**
 * Given a midi number, return its frequency
 * @param {Integer} midi - midi note number
 * @param {Float} tuning - (Optional) the A4 tuning (440Hz by default)
 * @return {Float} frequency in hertzs
 */
function midiToFreq (midi, tuning) {
  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)
}

var parser = { parse: parse, regex: regex, midiToFreq: midiToFreq }
var FNS = ['letter', 'acc', 'pc', 'step', 'alt', 'chroma', 'oct', 'midi', 'freq']
FNS.forEach(function (name) {
  parser[name] = function (src) {
    var p = parse(src)
    return p && (typeof p[name] !== 'undefined') ? p[name] : null
  }
})

module.exports = parser

// extra API docs
/**
 * Get midi of a note
 *
 * @name midi
 * @function
 * @param {String} note - the note name
 * @return {Integer} the midi number of the note or null if not a valid note
 * or the note does NOT contains octave
 * @example
 * var parser = require('note-parser')
 * parser.midi('A4') // => 69
 * parser.midi('A') // => null
 */
/**
 * Get freq of a note in hertzs (in a well tempered 440Hz A4)
 *
 * @name freq
 * @function
 * @param {String} note - the note name
 * @return {Float} the freq of the number if hertzs or null if not valid note
 * or the note does NOT contains octave
 * @example
 * var parser = require('note-parser')
 * parser.freq('A4') // => 440
 * parser.freq('A') // => null
 */


/***/ }),

/***/ "./node_modules/soundfont-player/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/soundfont-player/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var load = __webpack_require__(/*! audio-loader */ "./node_modules/audio-loader/lib/index.js")
var player = __webpack_require__(/*! sample-player */ "./node_modules/sample-player/lib/index.js")

/**
 * Load a soundfont instrument. It returns a promise that resolves to a
 * instrument object.
 *
 * The instrument object returned by the promise has the following properties:
 *
 * - name: the instrument name
 * - play: A function to play notes from the buffer with the signature
 * `play(note, time, duration, options)`
 *
 *
 * The valid options are:
 *
 * - `format`: the soundfont format. 'mp3' by default. Can be 'ogg'
 * - `soundfont`: the soundfont name. 'MusyngKite' by default. Can be 'FluidR3_GM'
 * - `nameToUrl` <Function>: a function to convert from instrument names to URL
 * - `destination`: by default Soundfont uses the `audioContext.destination` but you can override it.
 * - `gain`: the gain of the player (1 by default)
 * - `notes`: an array of the notes to decode. It can be an array of strings
 * with note names or an array of numbers with midi note numbers. This is a
 * performance option: since decoding mp3 is a cpu intensive process, you can limit
 * limit the number of notes you want and reduce the time to load the instrument.
 *
 * @param {AudioContext} ac - the audio context
 * @param {String} name - the instrument name. For example: 'acoustic_grand_piano'
 * @param {Object} options - (Optional) the same options as Soundfont.loadBuffers
 * @return {Promise}
 *
 * @example
 * var Soundfont = require('sounfont-player')
 * Soundfont.instrument('marimba').then(function (marimba) {
 *   marimba.play('C4')
 * })
 */
function instrument (ac, name, options) {
  if (arguments.length === 1) return function (n, o) { return instrument(ac, n, o) }
  var opts = options || {}
  var isUrl = opts.isSoundfontURL || isSoundfontURL
  var toUrl = opts.nameToUrl || nameToUrl
  var url = isUrl(name) ? name : toUrl(name, opts.soundfont, opts.format)

  return load(ac, url, { only: opts.only || opts.notes }).then(function (buffers) {
    var p = player(ac, buffers, opts).connect(opts.destination ? opts.destination : ac.destination)
    p.url = url
    p.name = name
    return p
  })
}

function isSoundfontURL (name) {
  return /\.js(\?.*)?$/i.test(name)
}

/**
 * Given an instrument name returns a URL to to the Benjamin Gleitzman's
 * package of [pre-rendered sound fonts](https://github.com/gleitz/midi-js-soundfonts)
 *
 * @param {String} name - instrument name
 * @param {String} soundfont - (Optional) the soundfont name. One of 'FluidR3_GM'
 * or 'MusyngKite' ('MusyngKite' by default)
 * @param {String} format - (Optional) Can be 'mp3' or 'ogg' (mp3 by default)
 * @returns {String} the Soundfont file url
 * @example
 * var Soundfont = require('soundfont-player')
 * Soundfont.nameToUrl('marimba', 'mp3')
 */
function nameToUrl (name, sf, format) {
  format = format === 'ogg' ? format : 'mp3'
  sf = sf === 'FluidR3_GM' ? sf : 'MusyngKite'
  return 'https://gleitz.github.io/midi-js-soundfonts/' + sf + '/' + name + '-' + format + '.js'
}

// In the 1.0.0 release it will be:
// var Soundfont = {}
var Soundfont = __webpack_require__(/*! ./legacy */ "./node_modules/soundfont-player/lib/legacy.js")
Soundfont.instrument = instrument
Soundfont.nameToUrl = nameToUrl

if ( true && module.exports) module.exports = Soundfont
if (typeof window !== 'undefined') window.Soundfont = Soundfont


/***/ }),

/***/ "./node_modules/soundfont-player/lib/legacy.js":
/*!*****************************************************!*\
  !*** ./node_modules/soundfont-player/lib/legacy.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parser = __webpack_require__(/*! note-parser */ "./node_modules/note-parser/index.js")

/**
 * Create a Soundfont object
 *
 * @param {AudioContext} context - the [audio context](https://developer.mozilla.org/en/docs/Web/API/AudioContext)
 * @param {Function} nameToUrl - (Optional) a function that maps the sound font name to the url
 * @return {Soundfont} a soundfont object
 */
function Soundfont (ctx, nameToUrl) {
  console.warn('new Soundfont() is deprected')
  console.log('Please use Soundfont.instrument() instead of new Soundfont().instrument()')
  if (!(this instanceof Soundfont)) return new Soundfont(ctx)

  this.nameToUrl = nameToUrl || Soundfont.nameToUrl
  this.ctx = ctx
  this.instruments = {}
  this.promises = []
}

Soundfont.prototype.onready = function (callback) {
  console.warn('deprecated API')
  console.log('Please use Promise.all(Soundfont.instrument(), Soundfont.instrument()).then() instead of new Soundfont().onready()')
  Promise.all(this.promises).then(callback)
}

Soundfont.prototype.instrument = function (name, options) {
  console.warn('new Soundfont().instrument() is deprecated.')
  console.log('Please use Soundfont.instrument() instead.')
  var ctx = this.ctx
  name = name || 'default'
  if (name in this.instruments) return this.instruments[name]
  var inst = {name: name, play: oscillatorPlayer(ctx, options)}
  this.instruments[name] = inst
  if (name !== 'default') {
    var promise = Soundfont.instrument(ctx, name, options).then(function (instrument) {
      inst.play = instrument.play
      return inst
    })
    this.promises.push(promise)
    inst.onready = function (cb) {
      console.warn('onready is deprecated. Use Soundfont.instrument().then()')
      promise.then(cb)
    }
  } else {
    inst.onready = function (cb) {
      console.warn('onready is deprecated. Use Soundfont.instrument().then()')
      cb()
    }
  }
  return inst
}

/*
 * Load the buffers of a given instrument name. It returns a promise that resolves
 * to a hash with midi note numbers as keys, and audio buffers as values.
 *
 * @param {AudioContext} ac - the audio context
 * @param {String} name - the instrument name (it accepts an url if starts with "http")
 * @param {Object} options - (Optional) options object
 * @return {Promise} a promise that resolves to a Hash of { midiNoteNum: <AudioBuffer> }
 *
 * The options object accepts the following keys:
 *
 * - nameToUrl {Function}: a function to convert from instrument names to urls.
 * By default it uses Benjamin Gleitzman's package of
 * [pre-rendered sound fonts](https://github.com/gleitz/midi-js-soundfonts)
 * - notes {Array}: the list of note names to be decoded (all by default)
 *
 * @example
 * var Soundfont = require('soundfont-player')
 * Soundfont.loadBuffers(ctx, 'acoustic_grand_piano').then(function(buffers) {
 *  buffers[60] // => An <AudioBuffer> corresponding to note C4
 * })
 */
function loadBuffers (ac, name, options) {
  console.warn('Soundfont.loadBuffers is deprecate.')
  console.log('Use Soundfont.instrument(..) and get buffers properties from the result.')
  return Soundfont.instrument(ac, name, options).then(function (inst) {
    return inst.buffers
  })
}
Soundfont.loadBuffers = loadBuffers

/**
 * Returns a function that plays an oscillator
 *
 * @param {AudioContext} ac - the audio context
 * @param {Hash} defaultOptions - (Optional) a hash of options:
 * - vcoType: the oscillator type (default: 'sine')
 * - gain: the output gain value (default: 0.4)
  * - destination: the player destination (default: ac.destination)
 */
function oscillatorPlayer (ctx, defaultOptions) {
  defaultOptions = defaultOptions || {}
  return function (note, time, duration, options) {
    console.warn('The oscillator player is deprecated.')
    console.log('Starting with version 0.9.0 you will have to wait until the soundfont is loaded to play sounds.')
    var midi = note > 0 && note < 129 ? +note : parser.midi(note)
    var freq = midi ? parser.midiToFreq(midi, 440) : null
    if (!freq) return

    duration = duration || 0.2

    options = options || {}
    var destination = options.destination || defaultOptions.destination || ctx.destination
    var vcoType = options.vcoType || defaultOptions.vcoType || 'sine'
    var gain = options.gain || defaultOptions.gain || 0.4

    var vco = ctx.createOscillator()
    vco.type = vcoType
    vco.frequency.value = freq

    /* VCA */
    var vca = ctx.createGain()
    vca.gain.value = gain

    /* Connections */
    vco.connect(vca)
    vca.connect(destination)

    vco.start(time)
    if (duration > 0) vco.stop(time + duration)
    return vco
  }
}

/**
 * Given a note name, return the note midi number
 *
 * @name noteToMidi
 * @function
 * @param {String} noteName
 * @return {Integer} the note midi number or null if not a valid note name
 */
Soundfont.noteToMidi = parser.midi

module.exports = Soundfont


/***/ }),

/***/ "./node_modules/tonal-array/build/es6.js":
/*!***********************************************!*\
  !*** ./node_modules/tonal-array/build/es6.js ***!
  \***********************************************/
/*! exports provided: range, rotate, compact, sort, unique, shuffle, permutations */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compact", function() { return compact; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sort", function() { return sort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unique", function() { return unique; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "permutations", function() { return permutations; });
/* harmony import */ var tonal_note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tonal-note */ "./node_modules/tonal-note/build/es6.js");
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-array.svg?style=flat-square)](https://www.npmjs.com/package/tonal-array)
 *
 * Tonal array utilities. Create ranges, sort notes, ...
 *
 * @example
 * import * as Array;
 * Array.sort(["f", "a", "c"]) // => ["C", "F", "A"]
 *
 * @example
 * const Array = require("tonal-array")
 * Array.range(1, 4) // => [1, 2, 3, 4]
 *
 * @module Array
 */


// ascending range
function ascR(b, n) {
  for (var a = []; n--; a[n] = n + b){ ; }
  return a;
}
// descending range
function descR(b, n) {
  for (var a = []; n--; a[n] = b - n){ ; }
  return a;
}

/**
 * Create a numeric range
 *
 * @param {Number} from
 * @param {Number} to
 * @return {Array}
 *
 * @example
 * Array.range(-2, 2) // => [-2, -1, 0, 1, 2]
 * Array.range(2, -2) // => [2, 1, 0, -1, -2]
 */
function range(a, b) {
  return a === null || b === null
    ? []
    : a < b
      ? ascR(a, b - a + 1)
      : descR(a, a - b + 1);
}
/**
 *
 * Rotates a list a number of times. It"s completly agnostic about the
 * contents of the list.
 *
 * @param {Integer} times - the number of rotations
 * @param {Array} array
 * @return {Array} the rotated array
 * @example
 * Array.rotate(1, [1, 2, 3]) // => [2, 3, 1]
 */
function rotate(times, arr) {
  var len = arr.length;
  var n = ((times % len) + len) % len;
  return arr.slice(n, len).concat(arr.slice(0, n));
}

/**
 * Return a copy of the array with the null values removed
 * @function
 * @param {Array} array
 * @return {Array}
 *
 * @example
 * Array.compact(["a", "b", null, "c"]) // => ["a", "b", "c"]
 */
var compact = function (arr) { return arr.filter(function (n) { return n === 0 || n; }); };

// a function that get note heights (with negative number for pitch classes)
var height = function (name) {
  var m = Object(tonal_note__WEBPACK_IMPORTED_MODULE_0__["props"])(name).midi;
  return m !== null ? m : Object(tonal_note__WEBPACK_IMPORTED_MODULE_0__["props"])(name + "-100").midi;
};

/**
 * Sort an array of notes in ascending order
 *
 * @param {String|Array} notes
 * @return {Array} sorted array of notes
 */
function sort(src) {
  return compact(src.map(tonal_note__WEBPACK_IMPORTED_MODULE_0__["name"])).sort(function (a, b) { return height(a) > height(b); });
}

/**
 * Get sorted notes with duplicates removed
 *
 * @function
 * @param {Array} notes
 */
function unique(arr) {
  return sort(arr).filter(function (n, i, a) { return i === 0 || n !== a[i - 1]; });
}

/**
 * Randomizes the order of the specified array in-place, using the Fisher–Yates shuffle.
 *
 * @private
 * @function
 * @param {Array|String} arr - the array
 * @return {Array} the shuffled array
 *
 * @example
 * Array.shuffle(["C", "D", "E", "F"])
 */
var shuffle = function (arr, rnd) {
  if ( rnd === void 0 ) rnd = Math.random;

  var i, t;
  var m = arr.length;
  while (m) {
    i = (rnd() * m--) | 0;
    t = arr[m];
    arr[m] = arr[i];
    arr[i] = t;
  }
  return arr;
};

/**
 * Get all permutations of an array
 * http://stackoverflow.com/questions/9960908/permutations-in-javascript
 *
 * @param {Array} array - the array
 * @return {Array<Array>} an array with all the permutations
 */
var permutations = function (arr) {
  if (arr.length === 0) { return [[]]; }
  return permutations(arr.slice(1)).reduce(function(acc, perm) {
    return acc.concat(
      arr.map(function(e, pos) {
        var newPerm = perm.slice();
        newPerm.splice(pos, 0, arr[0]);
        return newPerm;
      })
    );
  }, []);
};


/***/ }),

/***/ "./node_modules/tonal-chord/build/es6.js":
/*!***********************************************!*\
  !*** ./node_modules/tonal-chord/build/es6.js ***!
  \***********************************************/
/*! exports provided: names, props, intervals, notes, exists, supersets, subsets, tokenize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "props", function() { return props; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intervals", function() { return intervals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notes", function() { return notes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exists", function() { return exists; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supersets", function() { return supersets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subsets", function() { return subsets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenize", function() { return tokenize; });
/* harmony import */ var tonal_note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tonal-note */ "./node_modules/tonal-note/build/es6.js");
/* harmony import */ var tonal_distance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tonal-distance */ "./node_modules/tonal-distance/build/es6.js");
/* harmony import */ var tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tonal-dictionary */ "./node_modules/tonal-dictionary/build/es6.js");
/* harmony import */ var tonal_pcset__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tonal-pcset */ "./node_modules/tonal-pcset/build/es6.js");
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-chord.svg)](https://www.npmjs.com/package/tonal-chord)
 * [![tonal](https://img.shields.io/badge/tonal-chord-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)
 *
 * `tonal-chord` is a collection of functions to manipulate musical chords
 *
 * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.
 *
 * @example
 * // es6
 * import * as Chord from "tonal-chord"
 * // es5
 * const Chord = require("tonal-chord")
 *
 * @example
 * Chord.notes("CMaj7") // => ["C", "E", "G", "B"]
 *
 * @module Chord
 */





/**
 * Return the available chord names
 *
 * @function
 * @param {boolean} aliases - true to include aliases
 * @return {Array} the chord names
 *
 * @example
 * Chord.names() // => ["maj7", ...]
 */
var names = tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__["chord"].names;

var NO_CHORD = Object.freeze({
  name: null,
  names: [],
  intervals: [],
  chroma: null,
  setnum: null
});

var properties = function (name) {
  var intervals = Object(tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__["chord"])(name);
  if (!intervals) { return NO_CHORD; }
  var s = { intervals: intervals, name: name };
  s.chroma = Object(tonal_pcset__WEBPACK_IMPORTED_MODULE_3__["chroma"])(intervals);
  s.setnum = parseInt(s.chroma, 2);
  s.names = tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__["chord"].names(s.chroma);
  return s;
};

var memo = function (fn, cache) {
  if ( cache === void 0 ) cache = {};

  return function (str) { return cache[str] || (cache[str] = fn(str)); };
};

/**
 * Get chord properties. It returns an object with:
 *
 * - name: the chord name
 * - names: a list with all possible names (includes the current)
 * - intervals: an array with the chord intervals
 * - chroma:  chord croma (see pcset)
 * - setnum: chord chroma number
 *
 * @function
 * @param {string} name - the chord name (without tonic)
 * @return {Object} an object with the properties or a object with all properties
 * set to null if not valid chord name
 */
var props = memo(properties);

/**
 * Get chord intervals. It always returns an array
 *
 * @function
 * @param {string} name - the chord name (optionally a tonic and type)
 * @return {Array<String>} a list of intervals or null if the type is not known
 */
var intervals = function (name) { return props(tokenize(name)[1]).intervals; };

/**
 * Get the chord notes of a chord. This function accepts either a chord name
 * (for example: "Cmaj7") or a list of notes.
 *
 * It always returns an array, even if the chord is not found.
 *
 * @function
 * @param {string} nameOrTonic - name of the chord or the tonic (if the second parameter is present)
 * @param {string} [name] - (Optional) name if the first parameter is the tonic
 * @return {Array} an array of notes or an empty array
 *
 * @example
 * Chord.notes("Cmaj7") // => ["C", "E", "G", "B"]
 * Chord.notes("C", "maj7") // => ["C", "E", "G", "B"]
 */
function notes(nameOrTonic, name) {
  if (name) { return props(name).intervals.map(Object(tonal_distance__WEBPACK_IMPORTED_MODULE_1__["transpose"])(nameOrTonic)); }
  var ref = tokenize(nameOrTonic);
  var tonic = ref[0];
  var type = ref[1];
  return props(type).intervals.map(Object(tonal_distance__WEBPACK_IMPORTED_MODULE_1__["transpose"])(tonic));
}

/**
 * Check if a given name correspond to a chord in the dictionary
 *
 * @function
 * @param {string} name
 * @return {Boolean}
 * @example
 * Chord.exists("CMaj7") // => true
 * Chord.exists("Maj7") // => true
 * Chord.exists("Ablah") // => false
 */
var exists = function (name) { return Object(tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__["chord"])(tokenize(name)[1]) !== undefined; };

/**
 * Get all chords names that are a superset of the given one
 * (has the same notes and at least one more)
 *
 * @function
 * @param {string} name
 * @return {Array} a list of chord names
 */
var supersets = function (name) {
  if (!intervals(name).length) { return []; }
  var isSuperset = Object(tonal_pcset__WEBPACK_IMPORTED_MODULE_3__["isSupersetOf"])(intervals(name));
  return tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__["chord"].names().filter(function (name) { return isSuperset(Object(tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__["chord"])(name)); });
};

/**
 * Find all chords names that are a subset of the given one
 * (has less notes but all from the given chord)
 *
 * @function
 * @param {string} name
 * @return {Array} a list of chord names
 */
var subsets = function (name) {
  var isSubset = Object(tonal_pcset__WEBPACK_IMPORTED_MODULE_3__["isSubsetOf"])(intervals(name));
  return tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__["chord"].names().filter(function (name) { return isSubset(Object(tonal_dictionary__WEBPACK_IMPORTED_MODULE_2__["chord"])(name)); });
};

// 6, 64, 7, 9, 11 and 13 are consider part of the chord
// (see https://github.com/danigb/tonal/issues/55)
var NUM_TYPES = /^(6|64|7|9|11|13)$/;
/**
 * Tokenize a chord name. It returns an array with the tonic and chord type
 * If not tonic is found, all the name is considered the chord name.
 *
 * This function does NOT check if the chord type exists or not. It only tries
 * to split the tonic and chord type.
 *
 * @function
 * @param {string} name - the chord name
 * @return {Array} an array with [tonic, type]
 * @example
 * Chord.tokenize("Cmaj7") // => [ "C", "maj7" ]
 * Chord.tokenize("C7") // => [ "C", "7" ]
 * Chord.tokenize("mMaj7") // => [ "", "mMaj7" ]
 * Chord.tokenize("Cnonsense") // => [ "C", "nonsense" ]
 */
function tokenize(name) {
  var p = Object(tonal_note__WEBPACK_IMPORTED_MODULE_0__["tokenize"])(name);
  if (p[0] === "") { return ["", name]; }
  // aug is augmented (see https://github.com/danigb/tonal/issues/55)
  if (p[0] === "A" && p[3] === "ug") { return ["", "aug"]; }

  if (NUM_TYPES.test(p[2])) {
    return [p[0] + p[1], p[2] + p[3]];
  } else {
    return [p[0] + p[1] + p[2], p[3]];
  }
}


/***/ }),

/***/ "./node_modules/tonal-dictionary/build/data/chords.json":
/*!**************************************************************!*\
  !*** ./node_modules/tonal-dictionary/build/data/chords.json ***!
  \**************************************************************/
/*! exports provided: 4, 5, 7, 9, 11, 13, 64, M, M#5, M#5add9, M13, M13#11, M6, M6#11, M69, M69#11, M7#11, M7#5, M7#5sus4, M7#9#11, M7add13, M7b5, M7b6, M7b9, M7sus4, M9, M9#11, M9#5, M9#5sus4, M9b5, M9sus4, Madd9, Maj7, Mb5, Mb6, Msus2, Msus4, Maddb9, 11b9, 13#11, 13#9, 13#9#11, 13b5, 13b9, 13b9#11, 13no5, 13sus4, 69#11, 7#11, 7#11b13, 7#5, 7#5#9, 7#5b9, 7#5b9#11, 7#5sus4, 7#9, 7#9#11, 7#9#11b13, 7#9b13, 7add6, 7b13, 7b5, 7b6, 7b9, 7b9#11, 7b9#9, 7b9b13, 7b9b13#11, 7no5, 7sus4, 7sus4b9, 7sus4b9b13, 9#11, 9#11b13, 9#5, 9#5#11, 9b13, 9b5, 9no5, 9sus4, m, m#5, m11, m11A 5, m11b5, m13, m6, m69, m7, m7#5, m7add11, m7b5, m9, m9#5, m9b5, mMaj7, mMaj7b6, mM9, mM9b6, mb6M7, mb6b9, o, o7, o7M7, oM7, sus24, +add#9, madd4, madd9, default */
/***/ (function(module) {

module.exports = {"4":["1P 4P 7m 10m",["quartal"]],"5":["1P 5P"],"7":["1P 3M 5P 7m",["Dominant","Dom"]],"9":["1P 3M 5P 7m 9M",["79"]],"11":["1P 5P 7m 9M 11P"],"13":["1P 3M 5P 7m 9M 13M",["13_"]],"64":["5P 8P 10M"],"M":["1P 3M 5P",["Major",""]],"M#5":["1P 3M 5A",["augmented","maj#5","Maj#5","+","aug"]],"M#5add9":["1P 3M 5A 9M",["+add9"]],"M13":["1P 3M 5P 7M 9M 13M",["maj13","Maj13"]],"M13#11":["1P 3M 5P 7M 9M 11A 13M",["maj13#11","Maj13#11","M13+4","M13#4"]],"M6":["1P 3M 5P 13M",["6"]],"M6#11":["1P 3M 5P 6M 11A",["M6b5","6#11","6b5"]],"M69":["1P 3M 5P 6M 9M",["69"]],"M69#11":["1P 3M 5P 6M 9M 11A"],"M7#11":["1P 3M 5P 7M 11A",["maj7#11","Maj7#11","M7+4","M7#4"]],"M7#5":["1P 3M 5A 7M",["maj7#5","Maj7#5","maj9#5","M7+"]],"M7#5sus4":["1P 4P 5A 7M"],"M7#9#11":["1P 3M 5P 7M 9A 11A"],"M7add13":["1P 3M 5P 6M 7M 9M"],"M7b5":["1P 3M 5d 7M"],"M7b6":["1P 3M 6m 7M"],"M7b9":["1P 3M 5P 7M 9m"],"M7sus4":["1P 4P 5P 7M"],"M9":["1P 3M 5P 7M 9M",["maj9","Maj9"]],"M9#11":["1P 3M 5P 7M 9M 11A",["maj9#11","Maj9#11","M9+4","M9#4"]],"M9#5":["1P 3M 5A 7M 9M",["Maj9#5"]],"M9#5sus4":["1P 4P 5A 7M 9M"],"M9b5":["1P 3M 5d 7M 9M"],"M9sus4":["1P 4P 5P 7M 9M"],"Madd9":["1P 3M 5P 9M",["2","add9","add2"]],"Maj7":["1P 3M 5P 7M",["maj7","M7"]],"Mb5":["1P 3M 5d"],"Mb6":["1P 3M 13m"],"Msus2":["1P 2M 5P",["add9no3","sus2"]],"Msus4":["1P 4P 5P",["sus","sus4"]],"Maddb9":["1P 3M 5P 9m"],"11b9":["1P 5P 7m 9m 11P"],"13#11":["1P 3M 5P 7m 9M 11A 13M",["13+4","13#4"]],"13#9":["1P 3M 5P 7m 9A 13M",["13#9_"]],"13#9#11":["1P 3M 5P 7m 9A 11A 13M"],"13b5":["1P 3M 5d 6M 7m 9M"],"13b9":["1P 3M 5P 7m 9m 13M"],"13b9#11":["1P 3M 5P 7m 9m 11A 13M"],"13no5":["1P 3M 7m 9M 13M"],"13sus4":["1P 4P 5P 7m 9M 13M",["13sus"]],"69#11":["1P 3M 5P 6M 9M 11A"],"7#11":["1P 3M 5P 7m 11A",["7+4","7#4","7#11_","7#4_"]],"7#11b13":["1P 3M 5P 7m 11A 13m",["7b5b13"]],"7#5":["1P 3M 5A 7m",["+7","7aug","aug7"]],"7#5#9":["1P 3M 5A 7m 9A",["7alt","7#5#9_","7#9b13_"]],"7#5b9":["1P 3M 5A 7m 9m"],"7#5b9#11":["1P 3M 5A 7m 9m 11A"],"7#5sus4":["1P 4P 5A 7m"],"7#9":["1P 3M 5P 7m 9A",["7#9_"]],"7#9#11":["1P 3M 5P 7m 9A 11A",["7b5#9"]],"7#9#11b13":["1P 3M 5P 7m 9A 11A 13m"],"7#9b13":["1P 3M 5P 7m 9A 13m"],"7add6":["1P 3M 5P 7m 13M",["67","7add13"]],"7b13":["1P 3M 7m 13m"],"7b5":["1P 3M 5d 7m"],"7b6":["1P 3M 5P 6m 7m"],"7b9":["1P 3M 5P 7m 9m"],"7b9#11":["1P 3M 5P 7m 9m 11A",["7b5b9"]],"7b9#9":["1P 3M 5P 7m 9m 9A"],"7b9b13":["1P 3M 5P 7m 9m 13m"],"7b9b13#11":["1P 3M 5P 7m 9m 11A 13m",["7b9#11b13","7b5b9b13"]],"7no5":["1P 3M 7m"],"7sus4":["1P 4P 5P 7m",["7sus"]],"7sus4b9":["1P 4P 5P 7m 9m",["susb9","7susb9","7b9sus","7b9sus4","phryg"]],"7sus4b9b13":["1P 4P 5P 7m 9m 13m",["7b9b13sus4"]],"9#11":["1P 3M 5P 7m 9M 11A",["9+4","9#4","9#11_","9#4_"]],"9#11b13":["1P 3M 5P 7m 9M 11A 13m",["9b5b13"]],"9#5":["1P 3M 5A 7m 9M",["9+"]],"9#5#11":["1P 3M 5A 7m 9M 11A"],"9b13":["1P 3M 7m 9M 13m"],"9b5":["1P 3M 5d 7m 9M"],"9no5":["1P 3M 7m 9M"],"9sus4":["1P 4P 5P 7m 9M",["9sus"]],"m":["1P 3m 5P"],"m#5":["1P 3m 5A",["m+","mb6"]],"m11":["1P 3m 5P 7m 9M 11P",["_11"]],"m11A 5":["1P 3m 6m 7m 9M 11P"],"m11b5":["1P 3m 7m 12d 2M 4P",["h11","_11b5"]],"m13":["1P 3m 5P 7m 9M 11P 13M",["_13"]],"m6":["1P 3m 4P 5P 13M",["_6"]],"m69":["1P 3m 5P 6M 9M",["_69"]],"m7":["1P 3m 5P 7m",["minor7","_","_7"]],"m7#5":["1P 3m 6m 7m"],"m7add11":["1P 3m 5P 7m 11P",["m7add4"]],"m7b5":["1P 3m 5d 7m",["half-diminished","h7","_7b5"]],"m9":["1P 3m 5P 7m 9M",["_9"]],"m9#5":["1P 3m 6m 7m 9M"],"m9b5":["1P 3m 7m 12d 2M",["h9","-9b5"]],"mMaj7":["1P 3m 5P 7M",["mM7","_M7"]],"mMaj7b6":["1P 3m 5P 6m 7M",["mM7b6"]],"mM9":["1P 3m 5P 7M 9M",["mMaj9","-M9"]],"mM9b6":["1P 3m 5P 6m 7M 9M",["mMaj9b6"]],"mb6M7":["1P 3m 6m 7M"],"mb6b9":["1P 3m 6m 9m"],"o":["1P 3m 5d",["mb5","dim"]],"o7":["1P 3m 5d 13M",["diminished","m6b5","dim7"]],"o7M7":["1P 3m 5d 6M 7M"],"oM7":["1P 3m 5d 7M"],"sus24":["1P 2M 4P 5P",["sus4add9"]],"+add#9":["1P 3M 5A 9A"],"madd4":["1P 3m 4P 5P"],"madd9":["1P 3m 5P 9M"]};

/***/ }),

/***/ "./node_modules/tonal-dictionary/build/data/scales.json":
/*!**************************************************************!*\
  !*** ./node_modules/tonal-dictionary/build/data/scales.json ***!
  \**************************************************************/
/*! exports provided: chromatic, lydian, major, mixolydian, dorian, aeolian, phrygian, locrian, melodic minor, melodic minor second mode, lydian augmented, lydian dominant, melodic minor fifth mode, locrian #2, altered, harmonic minor, phrygian dominant, half-whole diminished, diminished, major pentatonic, lydian pentatonic, mixolydian pentatonic, locrian pentatonic, minor pentatonic, minor six pentatonic, minor hexatonic, flat three pentatonic, flat six pentatonic, major flat two pentatonic, whole tone pentatonic, ionian pentatonic, lydian #5P pentatonic, lydian dominant pentatonic, minor #7M pentatonic, super locrian pentatonic, in-sen, iwato, hirajoshi, kumoijoshi, pelog, vietnamese 1, vietnamese 2, prometheus, prometheus neopolitan, ritusen, scriabin, piongio, major blues, minor blues, composite blues, augmented, augmented heptatonic, dorian #4, lydian diminished, whole tone, leading whole tone, lydian minor, locrian major, neopolitan, neopolitan minor, neopolitan major, neopolitan major pentatonic, romanian minor, double harmonic lydian, harmonic major, double harmonic major, egyptian, hungarian minor, hungarian major, oriental, spanish heptatonic, flamenco, balinese, todi raga, malkos raga, kafi raga, purvi raga, persian, bebop, bebop dominant, bebop minor, bebop major, bebop locrian, minor bebop, mystery #1, enigmatic, minor six diminished, ionian augmented, lydian #9, ichikosucho, six tone symmetric, default */
/***/ (function(module) {

module.exports = {"chromatic":["1P 2m 2M 3m 3M 4P 4A 5P 6m 6M 7m 7M"],"lydian":["1P 2M 3M 4A 5P 6M 7M"],"major":["1P 2M 3M 4P 5P 6M 7M",["ionian"]],"mixolydian":["1P 2M 3M 4P 5P 6M 7m",["dominant"]],"dorian":["1P 2M 3m 4P 5P 6M 7m"],"aeolian":["1P 2M 3m 4P 5P 6m 7m",["minor"]],"phrygian":["1P 2m 3m 4P 5P 6m 7m"],"locrian":["1P 2m 3m 4P 5d 6m 7m"],"melodic minor":["1P 2M 3m 4P 5P 6M 7M"],"melodic minor second mode":["1P 2m 3m 4P 5P 6M 7m"],"lydian augmented":["1P 2M 3M 4A 5A 6M 7M"],"lydian dominant":["1P 2M 3M 4A 5P 6M 7m",["lydian b7"]],"melodic minor fifth mode":["1P 2M 3M 4P 5P 6m 7m",["hindu","mixolydian b6M"]],"locrian #2":["1P 2M 3m 4P 5d 6m 7m",["half-diminished"]],"altered":["1P 2m 3m 3M 5d 6m 7m",["super locrian","diminished whole tone","pomeroy"]],"harmonic minor":["1P 2M 3m 4P 5P 6m 7M"],"phrygian dominant":["1P 2m 3M 4P 5P 6m 7m",["spanish","phrygian major"]],"half-whole diminished":["1P 2m 3m 3M 4A 5P 6M 7m",["dominant diminished"]],"diminished":["1P 2M 3m 4P 5d 6m 6M 7M",["whole-half diminished"]],"major pentatonic":["1P 2M 3M 5P 6M",["pentatonic"]],"lydian pentatonic":["1P 3M 4A 5P 7M",["chinese"]],"mixolydian pentatonic":["1P 3M 4P 5P 7m",["indian"]],"locrian pentatonic":["1P 3m 4P 5d 7m",["minor seven flat five pentatonic"]],"minor pentatonic":["1P 3m 4P 5P 7m"],"minor six pentatonic":["1P 3m 4P 5P 6M"],"minor hexatonic":["1P 2M 3m 4P 5P 7M"],"flat three pentatonic":["1P 2M 3m 5P 6M",["kumoi"]],"flat six pentatonic":["1P 2M 3M 5P 6m"],"major flat two pentatonic":["1P 2m 3M 5P 6M"],"whole tone pentatonic":["1P 3M 5d 6m 7m"],"ionian pentatonic":["1P 3M 4P 5P 7M"],"lydian #5P pentatonic":["1P 3M 4A 5A 7M"],"lydian dominant pentatonic":["1P 3M 4A 5P 7m"],"minor #7M pentatonic":["1P 3m 4P 5P 7M"],"super locrian pentatonic":["1P 3m 4d 5d 7m"],"in-sen":["1P 2m 4P 5P 7m"],"iwato":["1P 2m 4P 5d 7m"],"hirajoshi":["1P 2M 3m 5P 6m"],"kumoijoshi":["1P 2m 4P 5P 6m"],"pelog":["1P 2m 3m 5P 6m"],"vietnamese 1":["1P 3m 4P 5P 6m"],"vietnamese 2":["1P 3m 4P 5P 7m"],"prometheus":["1P 2M 3M 4A 6M 7m"],"prometheus neopolitan":["1P 2m 3M 4A 6M 7m"],"ritusen":["1P 2M 4P 5P 6M"],"scriabin":["1P 2m 3M 5P 6M"],"piongio":["1P 2M 4P 5P 6M 7m"],"major blues":["1P 2M 3m 3M 5P 6M"],"minor blues":["1P 3m 4P 5d 5P 7m",["blues"]],"composite blues":["1P 2M 3m 3M 4P 5d 5P 6M 7m"],"augmented":["1P 2A 3M 5P 5A 7M"],"augmented heptatonic":["1P 2A 3M 4P 5P 5A 7M"],"dorian #4":["1P 2M 3m 4A 5P 6M 7m"],"lydian diminished":["1P 2M 3m 4A 5P 6M 7M"],"whole tone":["1P 2M 3M 4A 5A 7m"],"leading whole tone":["1P 2M 3M 4A 5A 7m 7M"],"lydian minor":["1P 2M 3M 4A 5P 6m 7m"],"locrian major":["1P 2M 3M 4P 5d 6m 7m",["arabian"]],"neopolitan":["1P 2m 3m 4P 5P 6m 7M"],"neopolitan minor":["1P 2m 3m 4P 5P 6m 7M"],"neopolitan major":["1P 2m 3m 4P 5P 6M 7M",["dorian b2"]],"neopolitan major pentatonic":["1P 3M 4P 5d 7m"],"romanian minor":["1P 2M 3m 5d 5P 6M 7m"],"double harmonic lydian":["1P 2m 3M 4A 5P 6m 7M"],"harmonic major":["1P 2M 3M 4P 5P 6m 7M"],"double harmonic major":["1P 2m 3M 4P 5P 6m 7M",["gypsy"]],"egyptian":["1P 2M 4P 5P 7m"],"hungarian minor":["1P 2M 3m 4A 5P 6m 7M"],"hungarian major":["1P 2A 3M 4A 5P 6M 7m"],"oriental":["1P 2m 3M 4P 5d 6M 7m"],"spanish heptatonic":["1P 2m 3m 3M 4P 5P 6m 7m"],"flamenco":["1P 2m 3m 3M 4A 5P 7m"],"balinese":["1P 2m 3m 4P 5P 6m 7M"],"todi raga":["1P 2m 3m 4A 5P 6m 7M"],"malkos raga":["1P 3m 4P 6m 7m"],"kafi raga":["1P 3m 3M 4P 5P 6M 7m 7M"],"purvi raga":["1P 2m 3M 4P 4A 5P 6m 7M"],"persian":["1P 2m 3M 4P 5d 6m 7M"],"bebop":["1P 2M 3M 4P 5P 6M 7m 7M"],"bebop dominant":["1P 2M 3M 4P 5P 6M 7m 7M"],"bebop minor":["1P 2M 3m 3M 4P 5P 6M 7m"],"bebop major":["1P 2M 3M 4P 5P 5A 6M 7M"],"bebop locrian":["1P 2m 3m 4P 5d 5P 6m 7m"],"minor bebop":["1P 2M 3m 4P 5P 6m 7m 7M"],"mystery #1":["1P 2m 3M 5d 6m 7m"],"enigmatic":["1P 2m 3M 5d 6m 7m 7M"],"minor six diminished":["1P 2M 3m 4P 5P 6m 6M 7M"],"ionian augmented":["1P 2M 3M 4P 5A 6M 7M"],"lydian #9":["1P 2m 3M 4A 5P 6M 7M"],"ichikosucho":["1P 2M 3M 4P 5d 5P 6M 7M"],"six tone symmetric":["1P 2m 3M 4P 5A 6M"]};

/***/ }),

/***/ "./node_modules/tonal-dictionary/build/es6.js":
/*!****************************************************!*\
  !*** ./node_modules/tonal-dictionary/build/es6.js ***!
  \****************************************************/
/*! exports provided: dictionary, combine, scale, chord, pcset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dictionary", function() { return dictionary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combine", function() { return combine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chord", function() { return chord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pcset", function() { return pcset; });
/* harmony import */ var _data_scales_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data/scales.json */ "./node_modules/tonal-dictionary/build/data/scales.json");
var _data_scales_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./data/scales.json */ "./node_modules/tonal-dictionary/build/data/scales.json", 1);
/* harmony import */ var _data_chords_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data/chords.json */ "./node_modules/tonal-dictionary/build/data/chords.json");
var _data_chords_json__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./data/chords.json */ "./node_modules/tonal-dictionary/build/data/chords.json", 1);
/* harmony import */ var tonal_pcset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tonal-pcset */ "./node_modules/tonal-pcset/build/es6.js");
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-dictionary.svg)](https://www.npmjs.com/package/tonal-dictionary)
 *
 * `tonal-dictionary` contains a dictionary of musical scales and chords
 *
 * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.
 *
 * @example
 * // es6
 * import * as Dictionary from "tonal-dictionary"
 * // es5
 * const Dictionary = require("tonal-dictionary")
 *
 * @example
 * Dictionary.chord("Maj7") // => ["1P", "3M", "5P", "7M"]
 *
 * @module Dictionary
 */




var dictionary = function (raw) {
  var keys = Object.keys(raw).sort();
  var data = [];
  var index = [];

  var add = function (name, ivls, chroma) {
    data[name] = ivls;
    index[chroma] = index[chroma] || [];
    index[chroma].push(name);
  };

  keys.forEach(function (key) {
    var ivls = raw[key][0].split(" ");
    var alias = raw[key][1];
    var chr = Object(tonal_pcset__WEBPACK_IMPORTED_MODULE_2__["chroma"])(ivls);

    add(key, ivls, chr);
    if (alias) { alias.forEach(function (a) { return add(a, ivls, chr); }); }
  });
  var allKeys = Object.keys(data).sort();

  var dict = function (name) { return data[name]; };
  dict.names = function (p) {
    if (typeof p === "string") { return (index[p] || []).slice(); }
    else { return (p === true ? allKeys : keys).slice(); }
  };
  return dict;
};

var combine = function (a, b) {
  var dict = function (name) { return a(name) || b(name); };
  dict.names = function (p) { return a.names(p).concat(b.names(p)); };
  return dict;
};

/**
 * A dictionary of scales: a function that given a scale name (without tonic)
 * returns an array of intervals
 *
 * @function
 * @param {string} name
 * @return {Array} intervals
 * @example
 * import { scale } from "tonal-dictionary"
 * scale("major") // => ["1P", "2M", ...]
 * scale.names(); // => ["major", ...]
 */
var scale = dictionary(_data_scales_json__WEBPACK_IMPORTED_MODULE_0__);

/**
 * A dictionary of chords: a function that given a chord type
 * returns an array of intervals
 *
 * @function
 * @param {string} type
 * @return {Array} intervals
 * @example
 * import { chord } from "tonal-dictionary"
 * chord("Maj7") // => ["1P", "3M", ...]
 * chord.names(); // => ["Maj3", ...]
 */
var chord = dictionary(_data_chords_json__WEBPACK_IMPORTED_MODULE_1__);
var pcset = combine(scale, chord);


/***/ }),

/***/ "./node_modules/tonal-distance/build/es6.js":
/*!**************************************************!*\
  !*** ./node_modules/tonal-distance/build/es6.js ***!
  \**************************************************/
/*! exports provided: transpose, trFifths, fifths, transposeBy, addIntervals, add, subtract, interval, semitones */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trFifths", function() { return trFifths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fifths", function() { return fifths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transposeBy", function() { return transposeBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addIntervals", function() { return addIntervals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return interval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "semitones", function() { return semitones; });
/* harmony import */ var tonal_note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tonal-note */ "./node_modules/tonal-note/build/es6.js");
/* harmony import */ var tonal_interval__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tonal-interval */ "./node_modules/tonal-interval/build/es6.js");
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-distance.svg)](https://www.npmjs.com/package/tonal-distance)
 * [![tonal](https://img.shields.io/badge/tonal-distance-yellow.svg)](https://github.com/danigb/tonal/tree/master/packages/tonal/distance)
 *
 * Transpose notes by intervals and find distances between notes
 *
 * @example
 * // es6
 * import * as Distance from "tonal-distance"
 * Distance.interval("C3", "C4") // => "1P"
 *
 * @example
 * // es6 import selected functions
 * import { interval, semitones, transpose } from "tonal-distance"
 *
 * semitones("C" ,"D") // => 2
 * interval("C4", "G4") // => "5P"
 * transpose("C4", "P5") // => "G4"
 *
 * @example
 * // included in tonal facade
 * const Tonal = require("tonal");
 * Tonal.Distance.transpose("C4", "P5")
 * Tonal.Distance.transposeBy("P5", "C4")
 *
 * @module Distance
 */



// Map from letter step to number of fifths starting from "C":
// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }
var FIFTHS = [0, 2, 4, -1, 1, 3, 5];

// Given a number of fifths, return the octaves they span
var fOcts = function (f) { return Math.floor((f * 7) / 12); };

// Get the number of octaves it span each step
var FIFTH_OCTS = FIFTHS.map(fOcts);

var encode = function (ref) {
  var step = ref.step;
  var alt = ref.alt;
  var oct = ref.oct;
  var dir = ref.dir; if ( dir === void 0 ) dir = 1;

  var f = FIFTHS[step] + 7 * alt;
  if (oct === null) { return [dir * f]; }
  var o = oct - FIFTH_OCTS[step] - 4 * alt;
  return [dir * f, dir * o];
};

// We need to get the steps from fifths
// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]
// We add 1 to fifths to avoid negative numbers, so:
// for ["F", "C", "G", "D", "A", "E", "B"] we have:
var STEPS = [3, 0, 4, 1, 5, 2, 6];

// Return the number of fifths as if it were unaltered
function unaltered(f) {
  var i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

var decode = function (f, o, dir) {
  var step = STEPS[unaltered(f)];
  var alt = Math.floor((f + 1) / 7);
  if (o === undefined) { return { step: step, alt: alt, dir: dir }; }
  var oct = o + 4 * alt + FIFTH_OCTS[step];
  return { step: step, alt: alt, oct: oct, dir: dir };
};

var memo = function (fn, cache) {
  if ( cache === void 0 ) cache = {};

  return function (str) { return cache[str] || (cache[str] = fn(str)); };
};

var encoder = function (props) { return memo(function (str) {
    var p = props(str);
    return p.name === null ? null : encode(p);
  }); };

var encodeNote = encoder(tonal_note__WEBPACK_IMPORTED_MODULE_0__["props"]);
var encodeIvl = encoder(tonal_interval__WEBPACK_IMPORTED_MODULE_1__["props"]);

/**
 * Transpose a note by an interval. The note can be a pitch class.
 *
 * This function can be partially applied.
 *
 * @param {string} note
 * @param {string} interval
 * @return {string} the transposed note
 * @example
 * import { tranpose } from "tonal-distance"
 * transpose("d3", "3M") // => "F#3"
 * // it works with pitch classes
 * transpose("D", "3M") // => "F#"
 * // can be partially applied
 * ["C", "D", "E", "F", "G"].map(transpose("M3)) // => ["E", "F#", "G#", "A", "B"]
 */
function transpose(note, interval) {
  if (arguments.length === 1) { return function (i) { return transpose(note, i); }; }
  var n = encodeNote(note);
  var i = encodeIvl(interval);
  if (n === null || i === null) { return null; }
  var tr = n.length === 1 ? [n[0] + i[0]] : [n[0] + i[0], n[1] + i[1]];
  return Object(tonal_note__WEBPACK_IMPORTED_MODULE_0__["build"])(decode(tr[0], tr[1]));
}

/**
 * Transpose a pitch class by a number of perfect fifths.
 *
 * It can be partially applied.
 *
 * @function
 * @param {string} pitchClass - the pitch class
 * @param {Integer} fifhts - the number of fifths
 * @return {string} the transposed pitch class
 *
 * @example
 * import { trFifths } from "tonal-transpose"
 * [0, 1, 2, 3, 4].map(trFifths("C")) // => ["C", "G", "D", "A", "E"]
 * // or using tonal
 * Distance.trFifths("G4", 1) // => "D"
 */

function trFifths(note, fifths) {
  if (arguments.length === 1) { return function (f) { return trFifths(note, f); }; }
  var n = encodeNote(note);
  if (n === null) { return null; }
  return Object(tonal_note__WEBPACK_IMPORTED_MODULE_0__["build"])(decode(n[0] + fifths));
}

/**
 * Get the distance in fifths between pitch classes
 *
 * Can be partially applied.
 *
 * @param {string} to - note or pitch class
 * @param {string} from - note or pitch class
 */
function fifths(from, to) {
  if (arguments.length === 1) { return function (to) { return fifths(from, to); }; }
  var f = encodeNote(from);
  var t = encodeNote(to);
  if (t === null || f === null) { return null; }
  return t[0] - f[0];
}

/**
 * The same as transpose with the arguments inverted.
 *
 * Can be partially applied.
 *
 * @param {string} note
 * @param {string} interval
 * @return {string} the transposed note
 * @example
 * import { tranposeBy } from "tonal-distance"
 * transposeBy("3m", "5P") // => "7m"
 */
function transposeBy(interval, note) {
  if (arguments.length === 1) { return function (n) { return transpose(n, interval); }; }
  return transpose(note, interval);
}

var isDescending = function (e) { return e[0] * 7 + e[1] * 12 < 0; };
var decodeIvl = function (i) { return isDescending(i) ? decode(-i[0], -i[1], -1) : decode(i[0], i[1], 1); };

function addIntervals(ivl1, ivl2, dir) {
  var i1 = encodeIvl(ivl1);
  var i2 = encodeIvl(ivl2);
  if (i1 === null || i2 === null) { return null; }
  var i = [i1[0] + dir * i2[0], i1[1] + dir * i2[1]];
  return Object(tonal_interval__WEBPACK_IMPORTED_MODULE_1__["build"])(decodeIvl(i));
}

/**
 * Add two intervals
 *
 * Can be partially applied.
 *
 * @param {string} interval1
 * @param {string} interval2
 * @return {string} the resulting interval
 * @example
 * import { add } from "tonal-distance"
 * add("3m", "5P") // => "7m"
 */
function add(ivl1, ivl2) {
  if (arguments.length === 1) { return function (i2) { return add(ivl1, i2); }; }
  return addIntervals(ivl1, ivl2, 1);
}

/**
 * Subtract two intervals
 *
 * Can be partially applied
 *
 * @param {string} minuend
 * @param {string} subtrahend
 * @return {string} interval diference
 */
function subtract(ivl1, ivl2) {
  if (arguments.length === 1) { return function (i2) { return add(ivl1, i2); }; }
  return addIntervals(ivl1, ivl2, -1);
}

/**
 * Find the interval between two pitches. It works with pitch classes
 * (both must be pitch classes and the interval is always ascending)
 *
 * Can be partially applied
 *
 * @param {string} from - distance from
 * @param {string} to - distance to
 * @return {string} the interval distance
 *
 * @example
 * import { interval } from "tonal-distance"
 * interval("C2", "C3") // => "P8"
 * interval("G", "B") // => "M3"
 *
 * @example
 * import * as Distance from "tonal-distance"
 * Distance.interval("M2", "P5") // => "P4"
 */
function interval(from, to) {
  if (arguments.length === 1) { return function (t) { return interval(from, t); }; }
  var f = encodeNote(from);
  var t = encodeNote(to);
  if (f === null || t === null || f.length !== t.length) { return null; }
  var d =
    f.length === 1
      ? [t[0] - f[0], -Math.floor(((t[0] - f[0]) * 7) / 12)]
      : [t[0] - f[0], t[1] - f[1]];
  return Object(tonal_interval__WEBPACK_IMPORTED_MODULE_1__["build"])(decodeIvl(d));
}

/**
 * Get the distance between two notes in semitones
 *
 * @param {String|Pitch} from - first note
 * @param {String|Pitch} to - last note
 * @return {Integer} the distance in semitones or null if not valid notes
 * @example
 * import { semitones } from "tonal-distance"
 * semitones("C3", "A2") // => -3
 * // or use tonal
 * Tonal.Distance.semitones("C3", "G3") // => 7
 */
function semitones(from, to) {
  if (arguments.length === 1) { return function (t) { return semitones(from, t); }; }
  var f = Object(tonal_note__WEBPACK_IMPORTED_MODULE_0__["props"])(from);
  var t = Object(tonal_note__WEBPACK_IMPORTED_MODULE_0__["props"])(to);
  return f.midi !== null && t.midi !== null
    ? t.midi - f.midi
    : f.chroma !== null && t.chroma !== null
      ? (t.chroma - f.chroma + 12) % 12
      : null;
}


/***/ }),

/***/ "./node_modules/tonal-interval/build/es6.js":
/*!**************************************************!*\
  !*** ./node_modules/tonal-interval/build/es6.js ***!
  \**************************************************/
/*! exports provided: names, tokenize, qToAlt, altToQ, props, num, name, semitones, chroma, ic, build, simplify, invert, fromSemitones */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenize", function() { return tokenize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "qToAlt", function() { return qToAlt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "altToQ", function() { return altToQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "props", function() { return props; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "num", function() { return num; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "name", function() { return name; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "semitones", function() { return semitones; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chroma", function() { return chroma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ic", function() { return ic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "build", function() { return build; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplify", function() { return simplify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromSemitones", function() { return fromSemitones; });
var IVL_TNL = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var IVL_STR = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX = new RegExp("^" + IVL_TNL + "|" + IVL_STR + "$");
var SIZES = [0, 2, 4, 5, 7, 9, 11];
var TYPES = "PMMPPMM";
var CLASSES = [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1];
var NAMES = "1P 2m 2M 3m 3M 4P 5P 6m 6M 7m 7M 8P".split(" ");
var names = function (types) {
    return typeof types !== "string"
        ? NAMES.slice()
        : NAMES.filter(function (n) { return types.indexOf(n[1]) !== -1; });
};
var tokenize = function (str) {
    var m = REGEX.exec("" + str);
    if (m === null)
        return null;
    return (m[1] ? [m[1], m[2]] : [m[4], m[3]]);
};
var NO_IVL = Object.freeze({
    name: null,
    num: null,
    q: null,
    step: null,
    alt: null,
    dir: null,
    type: null,
    simple: null,
    semitones: null,
    chroma: null,
    oct: null
});
var fillStr = function (s, n) { return Array(Math.abs(n) + 1).join(s); };
var qToAlt = function (type, q) {
    if (q === "M" && type === "M")
        return 0;
    if (q === "P" && type === "P")
        return 0;
    if (q === "m" && type === "M")
        return -1;
    if (/^A+$/.test(q))
        return q.length;
    if (/^d+$/.test(q))
        return type === "P" ? -q.length : -q.length - 1;
    return null;
};
var altToQ = function (type, alt) {
    if (alt === 0)
        return type === "M" ? "M" : "P";
    else if (alt === -1 && type === "M")
        return "m";
    else if (alt > 0)
        return fillStr("A", alt);
    else if (alt < 0)
        return fillStr("d", type === "P" ? alt : alt + 1);
    else
        return null;
};
var numToStep = function (num) { return (Math.abs(num) - 1) % 7; };
var properties = function (str) {
    var t = tokenize(str);
    if (t === null)
        return NO_IVL;
    var p = {
        num: 0,
        q: "d",
        name: "",
        type: "M",
        step: 0,
        dir: -1,
        simple: 1,
        alt: 0,
        oct: 0,
        semitones: 0,
        chroma: 0,
        ic: 0
    };
    p.num = +t[0];
    p.q = t[1];
    p.step = numToStep(p.num);
    p.type = TYPES[p.step];
    if (p.type === "M" && p.q === "P")
        return NO_IVL;
    p.name = "" + p.num + p.q;
    p.dir = p.num < 0 ? -1 : 1;
    p.simple = (p.num === 8 || p.num === -8
        ? p.num
        : p.dir * (p.step + 1));
    p.alt = qToAlt(p.type, p.q);
    p.oct = Math.floor((Math.abs(p.num) - 1) / 7);
    p.semitones = p.dir * (SIZES[p.step] + p.alt + 12 * p.oct);
    p.chroma = ((((p.dir * (SIZES[p.step] + p.alt)) % 12) + 12) %
        12);
    return Object.freeze(p);
};
var cache = {};
function props(str) {
    if (typeof str !== "string")
        return NO_IVL;
    return cache[str] || (cache[str] = properties(str));
}
var num = function (str) { return props(str).num; };
var name = function (str) { return props(str).name; };
var semitones = function (str) { return props(str).semitones; };
var chroma = function (str) { return props(str).chroma; };
var ic = function (ivl) {
    if (typeof ivl === "string")
        ivl = props(ivl).chroma;
    return typeof ivl === "number" ? CLASSES[ivl % 12] : null;
};
var build = function (_a) {
    var _b = _a === void 0 ? {} : _a, num = _b.num, step = _b.step, alt = _b.alt, _c = _b.oct, oct = _c === void 0 ? 1 : _c, dir = _b.dir;
    if (step !== undefined)
        num = step + 1 + 7 * oct;
    if (num === undefined)
        return null;
    if (typeof alt !== "number")
        return null;
    var d = typeof dir !== "number" ? "" : dir < 0 ? "-" : "";
    var type = TYPES[numToStep(num)];
    return (d + num + altToQ(type, alt));
};
var simplify = function (str) {
    var p = props(str);
    if (p === NO_IVL)
        return null;
    var intervalProps = p;
    return intervalProps.simple + intervalProps.q;
};
var invert = function (str) {
    var p = props(str);
    if (p === NO_IVL)
        return null;
    var intervalProps = p;
    var step = (7 - intervalProps.step) % 7;
    var alt = intervalProps.type === "P" ? -intervalProps.alt : -(intervalProps.alt + 1);
    return build({ step: step, alt: alt, oct: intervalProps.oct, dir: intervalProps.dir });
};
var IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];
var IQ = "P m M m M P d P m M m M".split(" ");
var fromSemitones = function (num) {
    var d = num < 0 ? -1 : 1;
    var n = Math.abs(num);
    var c = n % 12;
    var o = Math.floor(n / 12);
    return d * (IN[c] + 7 * o) + IQ[c];
};




/***/ }),

/***/ "./node_modules/tonal-midi/index.js":
/*!******************************************!*\
  !*** ./node_modules/tonal-midi/index.js ***!
  \******************************************/
/*! exports provided: toMidi, note */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toMidi", function() { return toMidi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "note", function() { return note; });
/* harmony import */ var note_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! note-parser */ "./node_modules/note-parser/index.js");
/**
 * A midi note number is a number representation of a note pitch. It can be
 * integers so it's equal tempered tuned, or float to indicate it's not
 * tuned into equal temepered scale.
 *
 * This module contains functions to convert to and from midi notes.
 *
 * @example
 * var midi = require('tonal-midi')
 * midi.toMidi('A4') // => 69
 * midi.note(69) // => 'A4'
 * midi.note(61) // => 'Db4'
 * midi.note(61, true) // => 'C#4'
 *
 * @module midi
 */



/**
 * Convert the given note to a midi note number. If you pass a midi number it
 * will returned as is.
 *
 * @param {Array|String|Number} note - the note to get the midi number from
 * @return {Integer} the midi number or null if not valid pitch
 * @example
 * midi.toMidi('C4') // => 60
 * midi.toMidi(60) // => 60
 * midi.toMidi('60') // => 60
 */
function toMidi (val) {
  if (Array.isArray(val) && val.length === 2) return val[0] * 7 + val[1] * 12 + 12
  return Object(note_parser__WEBPACK_IMPORTED_MODULE_0__["midi"])(val)
}

var FLATS = 'C Db D Eb E F Gb G Ab A Bb B'.split(' ')
var SHARPS = 'C C# D D# E F F# G G# A A# B'.split(' ')

/**
 * Given a midi number, returns a note name. The altered notes will have
 * flats unless explicitly set with the optional `useSharps` parameter.
 *
 * @function
 * @param {Integer} midi - the midi note number
 * @param {Boolean} useSharps - (Optional) set to true to use sharps instead of flats
 * @return {String} the note name
 * @example
 * var midi = require('tonal-midi')
 * midi.note(61) // => 'Db4'
 * midi.note(61, true) // => 'C#4'
 * // it rounds to nearest note
 * midi.note(61.7) // => 'D4'
 */
function note (num, sharps) {
  if (num === true || num === false) return function (m) { return note(m, num) }
  num = Math.round(num)
  var pcs = sharps === true ? SHARPS : FLATS
  var pc = pcs[num % 12]
  var o = Math.floor(num / 12) - 1
  return pc + o
}


/***/ }),

/***/ "./node_modules/tonal-note/build/es6.js":
/*!**********************************************!*\
  !*** ./node_modules/tonal-note/build/es6.js ***!
  \**********************************************/
/*! exports provided: names, tokenize, props, name, pc, midi, midiToFreq, freq, freqToMidi, chroma, oct, stepToLetter, altToAcc, from, build, fromMidi, simplify, enharmonic */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenize", function() { return tokenize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "props", function() { return props; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "name", function() { return name; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pc", function() { return pc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "midi", function() { return midi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "midiToFreq", function() { return midiToFreq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "freq", function() { return freq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "freqToMidi", function() { return freqToMidi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chroma", function() { return chroma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oct", function() { return oct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stepToLetter", function() { return stepToLetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "altToAcc", function() { return altToAcc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "from", function() { return from; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "build", function() { return build; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMidi", function() { return fromMidi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplify", function() { return simplify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enharmonic", function() { return enharmonic; });
var NAMES = "C C# Db D D# Eb E F F# Gb G G# Ab A A# Bb B".split(" ");
var names = function (accTypes) {
    return typeof accTypes !== "string"
        ? NAMES.slice()
        : NAMES.filter(function (n) {
            var acc = n[1] || " ";
            return accTypes.indexOf(acc) !== -1;
        });
};
var SHARPS = names(" #");
var FLATS = names(" b");
var REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function tokenize(str) {
    if (typeof str !== "string")
        str = "";
    var m = REGEX.exec(str);
    return [m[1].toUpperCase(), m[2].replace(/x/g, "##"), m[3], m[4]];
}
var NO_NOTE = Object.freeze({
    pc: null,
    name: null,
    step: null,
    alt: null,
    oct: null,
    octStr: null,
    chroma: null,
    midi: null,
    freq: null
});
var SEMI = [0, 2, 4, 5, 7, 9, 11];
var properties = function (str) {
    var tokens = tokenize(str);
    if (tokens[0] === "" || tokens[3] !== "")
        return NO_NOTE;
    var letter = tokens[0], acc = tokens[1], octStr = tokens[2];
    var p = {
        letter: letter,
        acc: acc,
        octStr: octStr,
        pc: letter + acc,
        name: letter + acc + octStr,
        step: (letter.charCodeAt(0) + 3) % 7,
        alt: acc[0] === "b" ? -acc.length : acc.length,
        oct: octStr.length ? +octStr : null,
        chroma: 0,
        midi: null,
        freq: null
    };
    p.chroma = (SEMI[p.step] + p.alt + 120) % 12;
    p.midi = p.oct !== null ? SEMI[p.step] + p.alt + 12 * (p.oct + 1) : null;
    p.freq = midiToFreq(p.midi);
    return Object.freeze(p);
};
var memo = function (fn, cache) {
    if (cache === void 0) { cache = {}; }
    return function (str) { return cache[str] || (cache[str] = fn(str)); };
};
var props = memo(properties);
var name = function (str) { return props(str).name; };
var pc = function (str) { return props(str).pc; };
var isMidiRange = function (m) { return m >= 0 && m <= 127; };
var midi = function (note) {
    if (typeof note !== "number" && typeof note !== "string") {
        return null;
    }
    var midi = props(note).midi;
    var value = midi || midi === 0 ? midi : +note;
    return isMidiRange(value) ? value : null;
};
var midiToFreq = function (midi, tuning) {
    if (tuning === void 0) { tuning = 440; }
    return typeof midi === "number" ? Math.pow(2, (midi - 69) / 12) * tuning : null;
};
var freq = function (note) { return props(note).freq || midiToFreq(note); };
var L2 = Math.log(2);
var L440 = Math.log(440);
var freqToMidi = function (freq) {
    var v = (12 * (Math.log(freq) - L440)) / L2 + 69;
    return Math.round(v * 100) / 100;
};
var chroma = function (str) { return props(str).chroma; };
var oct = function (str) { return props(str).oct; };
var LETTERS = "CDEFGAB";
var stepToLetter = function (step) { return LETTERS[step]; };
var fillStr = function (s, n) { return Array(n + 1).join(s); };
var numToStr = function (num, op) {
    return typeof num !== "number" ? "" : op(num);
};
var altToAcc = function (alt) {
    return numToStr(alt, function (alt) { return (alt < 0 ? fillStr("b", -alt) : fillStr("#", alt)); });
};
var from = function (fromProps, baseNote) {
    if (fromProps === void 0) { fromProps = {}; }
    if (baseNote === void 0) { baseNote = null; }
    var _a = baseNote
        ? Object.assign({}, props(baseNote), fromProps)
        : fromProps, step = _a.step, alt = _a.alt, oct = _a.oct;
    if (typeof step !== "number")
        return null;
    var letter = stepToLetter(step);
    if (!letter)
        return null;
    var pc = letter + altToAcc(alt);
    return oct || oct === 0 ? pc + oct : pc;
};
var build = from;
function fromMidi(num, sharps) {
    if (sharps === void 0) { sharps = false; }
    num = Math.round(num);
    var pcs = sharps === true ? SHARPS : FLATS;
    var pc = pcs[num % 12];
    var o = Math.floor(num / 12) - 1;
    return pc + o;
}
var simplify = function (note, sameAcc) {
    if (sameAcc === void 0) { sameAcc = true; }
    var _a = props(note), alt = _a.alt, chroma = _a.chroma, midi = _a.midi;
    if (chroma === null)
        return null;
    var alteration = alt;
    var useSharps = sameAcc === false ? alteration < 0 : alteration > 0;
    return midi === null
        ? pc(fromMidi(chroma, useSharps))
        : fromMidi(midi, useSharps);
};
var enharmonic = function (note) { return simplify(note, false); };




/***/ }),

/***/ "./node_modules/tonal-pcset/build/es6.js":
/*!***********************************************!*\
  !*** ./node_modules/tonal-pcset/build/es6.js ***!
  \***********************************************/
/*! exports provided: chroma, chromas, modes, isChroma, intervals, isEqual, isSubsetOf, isSupersetOf, includes, filter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chroma", function() { return chroma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chromas", function() { return chromas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modes", function() { return modes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isChroma", function() { return isChroma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intervals", function() { return intervals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return isEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSubsetOf", function() { return isSubsetOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSupersetOf", function() { return isSupersetOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony import */ var tonal_note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tonal-note */ "./node_modules/tonal-note/build/es6.js");
/* harmony import */ var tonal_interval__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tonal-interval */ "./node_modules/tonal-interval/build/es6.js");
/* harmony import */ var tonal_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tonal-array */ "./node_modules/tonal-array/build/es6.js");
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-pcset.svg?style=flat-square)](https://www.npmjs.com/package/tonal-pcset)
 * [![tonal](https://img.shields.io/badge/tonal-pcset-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)
 *
 * `tonal-pcset` is a collection of functions to work with pitch class sets, oriented
 * to make comparations (isEqual, isSubset, isSuperset)
 *
 * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.
 *
 * You can install via npm: `npm i --save tonal-pcset`
 *
 * ```js
 * // es6
 * import PcSet from "tonal-pcset"
 * var PcSet = require("tonal-pcset")
 *
 * PcSet.isEqual("c2 d5 e6", "c6 e3 d1") // => true
 * ```
 *
 * ## API documentation
 *
 * @module PcSet
 */




var chr = function (str) { return Object(tonal_note__WEBPACK_IMPORTED_MODULE_0__["chroma"])(str) || Object(tonal_interval__WEBPACK_IMPORTED_MODULE_1__["chroma"])(str) || 0; };
var pcsetNum = function (set) { return parseInt(chroma(set), 2); };
var clen = function (chroma) { return chroma.replace(/0/g, "").length; };

/**
 * Get chroma of a pitch class set. A chroma identifies each set uniquely.
 * It"s a 12-digit binary each presenting one semitone of the octave.
 *
 * Note that this function accepts a chroma as parameter and return it
 * without modification.
 *
 * @param {Array|String} set - the pitch class set
 * @return {string} a binary representation of the pitch class set
 * @example
 * PcSet.chroma(["C", "D", "E"]) // => "1010100000000"
 */
function chroma(set) {
  if (isChroma(set)) { return set; }
  if (!Array.isArray(set)) { return ""; }
  var b = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  set.map(chr).forEach(function (i) {
    b[i] = 1;
  });
  return b.join("");
}

var all = null;
/**
 * Get a list of all possible chromas (all possible scales)
 * More information: http://allthescales.org/
 * @return {Array} an array of possible chromas from '10000000000' to '11111111111'
 *
 */
function chromas(n) {
  all = all || Object(tonal_array__WEBPACK_IMPORTED_MODULE_2__["range"])(2048, 4095).map(function (n) { return n.toString(2); });
  return typeof n === "number"
    ? all.filter(function (chroma) { return clen(chroma) === n; })
    : all.slice();
}

/**
 * Given a a list of notes or a pcset chroma, produce the rotations
 * of the chroma discarding the ones that starts with "0"
 *
 * This is used, for example, to get all the modes of a scale.
 *
 * @param {Array|String} set - the list of notes or pitchChr of the set
 * @param {Boolean} normalize - (Optional, true by default) remove all
 * the rotations that starts with "0"
 * @return {Array<String>} an array with all the modes of the chroma
 *
 * @example
 * PcSet.modes(["C", "D", "E"]).map(PcSet.intervals)
 */
function modes(set, normalize) {
  normalize = normalize !== false;
  var binary = chroma(set).split("");
  return Object(tonal_array__WEBPACK_IMPORTED_MODULE_2__["compact"])(
    binary.map(function(_, i) {
      var r = Object(tonal_array__WEBPACK_IMPORTED_MODULE_2__["rotate"])(i, binary);
      return normalize && r[0] === "0" ? null : r.join("");
    })
  );
}

var REGEX = /^[01]{12}$/;
/**
 * Test if the given string is a pitch class set chroma.
 * @param {string} chroma - the pitch class set chroma
 * @return {Boolean} true if its a valid pcset chroma
 * @example
 * PcSet.isChroma("101010101010") // => true
 * PcSet.isChroma("101001") // => false
 */
function isChroma(set) {
  return REGEX.test(set);
}

var IVLS = "1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M".split(" ");
/**
 * Given a pcset (notes or chroma) return it"s intervals
 * @param {String|Array} pcset - the pitch class set (notes or chroma)
 * @return {Array} intervals or empty array if not valid pcset
 * @example
 * PcSet.intervals("1010100000000") => ["1P", "2M", "3M"]
 */
function intervals(set) {
  if (!isChroma(set)) { return []; }
  return Object(tonal_array__WEBPACK_IMPORTED_MODULE_2__["compact"])(
    set.split("").map(function(d, i) {
      return d === "1" ? IVLS[i] : null;
    })
  );
}

/**
 * Test if two pitch class sets are identical
 *
 * @param {Array|String} set1 - one of the pitch class sets
 * @param {Array|String} set2 - the other pitch class set
 * @return {Boolean} true if they are equal
 * @example
 * PcSet.isEqual(["c2", "d3"], ["c5", "d2"]) // => true
 */
function isEqual(s1, s2) {
  if (arguments.length === 1) { return function (s) { return isEqual(s1, s); }; }
  return chroma(s1) === chroma(s2);
}

/**
 * Create a function that test if a collection of notes is a
 * subset of a given set
 *
 * The function can be partially applied
 *
 * @param {Array|String} set - an array of notes or a chroma set string to test against
 * @param {Array|String} notes - an array of notes or a chroma set
 * @return {boolean} true if notes is a subset of set, false otherwise
 * @example
 * const inCMajor = PcSet.isSubsetOf(["C", "E", "G"])
 * inCMajor(["e6", "c4"]) // => true
 * inCMajor(["e6", "c4", "d3"]) // => false
 */
function isSubsetOf(set, notes) {
  if (arguments.length > 1) { return isSubsetOf(set)(notes); }
  set = pcsetNum(set);
  return function(notes) {
    notes = pcsetNum(notes);
    return notes !== set && (notes & set) === notes;
  };
}

/**
 * Create a function that test if a collectio of notes is a
 * superset of a given set (it contains all notes and at least one more)
 *
 * @param {Array|String} set - an array of notes or a chroma set string to test against
 * @param {Array|String} notes - an array of notes or a chroma set
 * @return {boolean} true if notes is a superset of set, false otherwise
 * @example
 * const extendsCMajor = PcSet.isSupersetOf(["C", "E", "G"])
 * extendsCMajor(["e6", "a", "c4", "g2"]) // => true
 * extendsCMajor(["c6", "e4", "g3"]) // => false
 */
function isSupersetOf(set, notes) {
  if (arguments.length > 1) { return isSupersetOf(set)(notes); }
  set = pcsetNum(set);
  return function(notes) {
    notes = pcsetNum(notes);
    return notes !== set && (notes | set) === notes;
  };
}

/**
 * Test if a given pitch class set includes a note
 * @param {Array|String} set - the base set to test against
 * @param {String|Pitch} note - the note to test
 * @return {Boolean} true if the note is included in the pcset
 * @example
 * PcSet.includes(["C", "D", "E"], "C4") // => true
 * PcSet.includes(["C", "D", "E"], "C#4") // => false
 */
function includes(set, note) {
  if (arguments.length > 1) { return includes(set)(note); }
  set = chroma(set);
  return function(note) {
    return set[chr(note)] === "1";
  };
}

/**
 * Filter a list with a pitch class set
 *
 * @param {Array|String} set - the pitch class set notes
 * @param {Array|String} notes - the note list to be filtered
 * @return {Array} the filtered notes
 *
 * @example
 * PcSet.filter(["C", "D", "E"], ["c2", "c#2", "d2", "c3", "c#3", "d3"]) // => [ "c2", "d2", "c3", "d3" ])
 * PcSet.filter(["C2"], ["c2", "c#2", "d2", "c3", "c#3", "d3"]) // => [ "c2", "c3" ])
 */
function filter(set, notes) {
  if (arguments.length === 1) { return function (n) { return filter(set, n); }; }
  return notes.filter(includes(set));
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWRzci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVkaW8tbG9hZGVyL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1ZGlvLWxvYWRlci9saWIvZmV0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1ZGlvLWxvYWRlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taWRpLXBsYXllci1qcy9icm93c2VyL21pZGlwbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pZGktd3JpdGVyLWpzL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taWRpbWVzc2FnZS9kaXN0L2luZGV4Lm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm90ZS1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FtcGxlLXBsYXllci9saWIvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYW1wbGUtcGxheWVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FtcGxlLXBsYXllci9saWIvbWlkaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FtcGxlLXBsYXllci9saWIvbm90ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhbXBsZS1wbGF5ZXIvbGliL3BsYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FtcGxlLXBsYXllci9saWIvc2NoZWR1bGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYW1wbGUtcGxheWVyL25vZGVfbW9kdWxlcy9ub3RlLXBhcnNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291bmRmb250LXBsYXllci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdW5kZm9udC1wbGF5ZXIvbGliL2xlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uYWwtYXJyYXkvYnVpbGQvZXM2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25hbC1jaG9yZC9idWlsZC9lczYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmFsLWRpY3Rpb25hcnkvYnVpbGQvZXM2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25hbC1kaXN0YW5jZS9idWlsZC9lczYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmFsLWludGVydmFsL2J1aWxkL2VzNi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uYWwtbWlkaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uYWwtbm90ZS9idWlsZC9lczYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmFsLXBjc2V0L2J1aWxkL2VzNi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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QUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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MENBQTBDLFVBQVU7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0EsY0FBYztBQUNkOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUwscURBQXFELGtCQUFrQjtBQUN2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVLDRDQUE0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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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LEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7O0FBRVo7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUErQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwrQkFBK0Isc0JBQXNCLHVCQUF1QixHQUFHO0FBQy9FO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25OQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiLi9qcy9tYWluLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vanMvbWFpbi5qc1wiKTtcbiIsImNvbnN0IGNob3JkID0gcmVxdWlyZSgndG9uYWwtY2hvcmQnKTsgLy8gVHVybiBjaG9yZHMgaW50byBub3Rlc1xyXG5jb25zdCBNaWRpV3JpdGVyID0gcmVxdWlyZSgnbWlkaS13cml0ZXItanMnKTsgLy8gVHVybiBub3RlcyBpbnRvIG1pZGkgZXZlbnRzXHJcbmNvbnN0IE1pZGlQbGF5ZXIgPSByZXF1aXJlKCdtaWRpLXBsYXllci1qcycpOyAvLyBQbGF5IE1pZGkgZXZlbnRzXHJcbmNvbnN0IFNvdW5kZm9udCA9IHJlcXVpcmUoJ3NvdW5kZm9udC1wbGF5ZXInKTsgLy8gQXR0YWNoIGF1ZGlvIHRvIG1pZGkgZXZlbnRzXHJcblxyXG5mdW5jdGlvbiBnZXROb3RlcygpIHtcclxuICAgIGxldCBub3RlcyA9IFtdO1xyXG5cclxuICAgIGxldCBjaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPWNob3Jkc10nKS52YWx1ZTtcclxuICAgIGlmKGNpbnB1dCA9PSBudWxsKSByZXR1cm4gbnVsbFxyXG5cclxuICAgIGNpbnB1dC5zcGxpdCgnICcpLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgbm90ZXMucHVzaChjaG9yZC5ub3RlcyhjKSlcclxuICAgIH0pO1xyXG5cclxuICAgIG5vdGVzLmZvckVhY2goKGl0ZW0sIGkpPT4ge1xyXG4gICAgICAgIG5vdGVzW2ldID0gaXRlbS5tYXAobiA9PiBuICs9ICc0JylcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIG5vdGVzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERhdGFVcmkoKSB7XHJcbiAgICBsZXQgdHJhY2sgPSBuZXcgTWlkaVdyaXRlci5UcmFjaygpO1xyXG4gICAgdHJhY2suYWRkRXZlbnQobmV3IE1pZGlXcml0ZXIuUHJvZ3JhbUNoYW5nZUV2ZW50KHtpbnN0cnVtZW50IDogMX0pKTtcclxuICAgIFxyXG4gICAgbGV0IG5vdGVMaXN0ID0gZ2V0Tm90ZXMoKVxyXG4gICAgaWYobm90ZUxpc3QgPT0gbnVsbCl7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIG5vdGVMaXN0LmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgIHZhciBub3RlID0gbmV3IE1pZGlXcml0ZXIuTm90ZUV2ZW50KHtwaXRjaDogZWwsIGR1cmF0aW9uOiAnZDInfSk7XHJcbiAgICAgICAgdHJhY2suYWRkRXZlbnQobm90ZSk7XHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICB2YXIgd3JpdGUgPSBuZXcgTWlkaVdyaXRlci5Xcml0ZXIodHJhY2spO1xyXG4gICAgcmV0dXJuIHdyaXRlLmRhdGFVcmkoKVxyXG59XHJcblxyXG5mdW5jdGlvbiBwbGF5KCkge1xyXG4gICAgbGV0IGFjID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xyXG4gICAgU291bmRmb250Lmluc3RydW1lbnQoYWMsICdhY291c3RpY19ncmFuZF9waWFubycpLnRoZW4oZnVuY3Rpb24gKHBpYW5vKSB7XHJcbiAgICAgICAgdmFyIFBsYXllciA9IG5ldyBNaWRpUGxheWVyLlBsYXllcihmdW5jdGlvbihldmVudCkgeyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihldmVudC5uYW1lID09ICdOb3RlIG9uJykge1xyXG4gICAgICAgICAgICAgICAgcGlhbm8ucGxheShldmVudC5ub3RlTmFtZSwgYWMuY3VycmVudFRpbWUsIHtnYWluOmV2ZW50LnZlbG9jaXR5LzEwMH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgUGxheWVyLmxvYWREYXRhVXJpKGdldERhdGFVcmkoKSlcclxuICAgICAgICBQbGF5ZXIucGxheSgpO1xyXG4gICAgfSlcclxufVxyXG5cclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwbGF5KTsiLCJtb2R1bGUuZXhwb3J0cyA9IEFEU1JcblxuZnVuY3Rpb24gQURTUihhdWRpb0NvbnRleHQpe1xuICB2YXIgbm9kZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKClcblxuICB2YXIgdm9sdGFnZSA9IG5vZGUuX3ZvbHRhZ2UgPSBnZXRWb2x0YWdlKGF1ZGlvQ29udGV4dClcbiAgdmFyIHZhbHVlID0gc2NhbGUodm9sdGFnZSlcbiAgdmFyIHN0YXJ0VmFsdWUgPSBzY2FsZSh2b2x0YWdlKVxuICB2YXIgZW5kVmFsdWUgPSBzY2FsZSh2b2x0YWdlKVxuXG4gIG5vZGUuX3N0YXJ0QW1vdW50ID0gc2NhbGUoc3RhcnRWYWx1ZSlcbiAgbm9kZS5fZW5kQW1vdW50ID0gc2NhbGUoZW5kVmFsdWUpXG5cbiAgbm9kZS5fbXVsdGlwbGllciA9IHNjYWxlKHZhbHVlKVxuICBub2RlLl9tdWx0aXBsaWVyLmNvbm5lY3Qobm9kZSlcbiAgbm9kZS5fc3RhcnRBbW91bnQuY29ubmVjdChub2RlKVxuICBub2RlLl9lbmRBbW91bnQuY29ubmVjdChub2RlKVxuXG4gIG5vZGUudmFsdWUgPSB2YWx1ZS5nYWluXG4gIG5vZGUuc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWUuZ2FpblxuICBub2RlLmVuZFZhbHVlID0gZW5kVmFsdWUuZ2FpblxuXG4gIG5vZGUuc3RhcnRWYWx1ZS52YWx1ZSA9IDBcbiAgbm9kZS5lbmRWYWx1ZS52YWx1ZSA9IDBcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhub2RlLCBwcm9wcylcbiAgcmV0dXJuIG5vZGVcbn1cblxudmFyIHByb3BzID0ge1xuXG4gIGF0dGFjazogeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSxcbiAgZGVjYXk6IHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0sXG4gIHN1c3RhaW46IHsgdmFsdWU6IDEsIHdyaXRhYmxlOiB0cnVlIH0sXG4gIHJlbGVhc2U6IHt2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSxcblxuICBnZXRSZWxlYXNlRHVyYXRpb246IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLnJlbGVhc2VcbiAgICB9XG4gIH0sXG5cbiAgc3RhcnQ6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYXQpe1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX211bHRpcGxpZXIuZ2FpblxuICAgICAgdmFyIHN0YXJ0QW1vdW50ID0gdGhpcy5fc3RhcnRBbW91bnQuZ2FpblxuICAgICAgdmFyIGVuZEFtb3VudCA9IHRoaXMuX2VuZEFtb3VudC5nYWluXG5cbiAgICAgIHRoaXMuX3ZvbHRhZ2Uuc3RhcnQoYXQpXG4gICAgICB0aGlzLl9kZWNheUZyb20gPSB0aGlzLl9kZWNheUZyb20gPSBhdCt0aGlzLmF0dGFja1xuICAgICAgdGhpcy5fc3RhcnRlZEF0ID0gYXRcblxuICAgICAgdmFyIHN1c3RhaW4gPSB0aGlzLnN1c3RhaW5cblxuICAgICAgdGFyZ2V0LmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhdClcbiAgICAgIHN0YXJ0QW1vdW50LmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhdClcbiAgICAgIGVuZEFtb3VudC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoYXQpXG5cbiAgICAgIGVuZEFtb3VudC5zZXRWYWx1ZUF0VGltZSgwLCBhdClcblxuICAgICAgaWYgKHRoaXMuYXR0YWNrKXtcbiAgICAgICAgdGFyZ2V0LnNldFZhbHVlQXRUaW1lKDAsIGF0KVxuICAgICAgICB0YXJnZXQubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMSwgYXQgKyB0aGlzLmF0dGFjaylcblxuICAgICAgICBzdGFydEFtb3VudC5zZXRWYWx1ZUF0VGltZSgxLCBhdClcbiAgICAgICAgc3RhcnRBbW91bnQubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgYXQgKyB0aGlzLmF0dGFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5zZXRWYWx1ZUF0VGltZSgxLCBhdClcbiAgICAgICAgc3RhcnRBbW91bnQuc2V0VmFsdWVBdFRpbWUoMCwgYXQpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRlY2F5KXtcbiAgICAgICAgdGFyZ2V0LnNldFRhcmdldEF0VGltZShzdXN0YWluLCB0aGlzLl9kZWNheUZyb20sIGdldFRpbWVDb25zdGFudCh0aGlzLmRlY2F5KSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc3RvcDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhdCwgaXNUYXJnZXQpe1xuICAgICAgaWYgKGlzVGFyZ2V0KXtcbiAgICAgICAgYXQgPSBhdCAtIHRoaXMucmVsZWFzZVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5kVGltZSA9IGF0ICsgdGhpcy5yZWxlYXNlXG4gICAgICBpZiAodGhpcy5yZWxlYXNlKXtcblxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fbXVsdGlwbGllci5nYWluXG4gICAgICAgIHZhciBzdGFydEFtb3VudCA9IHRoaXMuX3N0YXJ0QW1vdW50LmdhaW5cbiAgICAgICAgdmFyIGVuZEFtb3VudCA9IHRoaXMuX2VuZEFtb3VudC5nYWluXG5cbiAgICAgICAgdGFyZ2V0LmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhdClcbiAgICAgICAgc3RhcnRBbW91bnQuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGF0KVxuICAgICAgICBlbmRBbW91bnQuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGF0KVxuXG4gICAgICAgIHZhciBleHBGYWxsb2ZmID0gZ2V0VGltZUNvbnN0YW50KHRoaXMucmVsZWFzZSlcblxuICAgICAgICAvLyB0cnVuY2F0ZSBhdHRhY2sgKHJlcXVpcmVkIGFzIGxpbmVhclJhbXAgaXMgcmVtb3ZlZCBieSBjYW5jZWxTY2hlZHVsZWRWYWx1ZXMpXG4gICAgICAgIGlmICh0aGlzLmF0dGFjayAmJiBhdCA8IHRoaXMuX2RlY2F5RnJvbSl7XG4gICAgICAgICAgdmFyIHZhbHVlQXRUaW1lID0gZ2V0VmFsdWUoMCwgMSwgdGhpcy5fc3RhcnRlZEF0LCB0aGlzLl9kZWNheUZyb20sIGF0KVxuICAgICAgICAgIHRhcmdldC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZUF0VGltZSwgYXQpXG4gICAgICAgICAgc3RhcnRBbW91bnQubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMS12YWx1ZUF0VGltZSwgYXQpXG4gICAgICAgICAgc3RhcnRBbW91bnQuc2V0VGFyZ2V0QXRUaW1lKDAsIGF0LCBleHBGYWxsb2ZmKVxuICAgICAgICB9XG5cbiAgICAgICAgZW5kQW1vdW50LnNldFRhcmdldEF0VGltZSgxLCBhdCwgZXhwRmFsbG9mZilcbiAgICAgICAgdGFyZ2V0LnNldFRhcmdldEF0VGltZSgwLCBhdCwgZXhwRmFsbG9mZilcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdm9sdGFnZS5zdG9wKGVuZFRpbWUpXG4gICAgICByZXR1cm4gZW5kVGltZVxuICAgIH1cbiAgfSxcblxuICBvbmVuZGVkOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ZvbHRhZ2Uub25lbmRlZFxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICB0aGlzLl92b2x0YWdlLm9uZW5kZWQgPSB2YWx1ZVxuICAgIH1cbiAgfVxuXG59XG5cbnZhciBmbGF0ID0gbmV3IEZsb2F0MzJBcnJheShbMSwxXSlcbmZ1bmN0aW9uIGdldFZvbHRhZ2UoY29udGV4dCl7XG4gIHZhciB2b2x0YWdlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKVxuICB2YXIgYnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMiwgY29udGV4dC5zYW1wbGVSYXRlKVxuICBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCkuc2V0KGZsYXQpXG4gIHZvbHRhZ2UuYnVmZmVyID0gYnVmZmVyXG4gIHZvbHRhZ2UubG9vcCA9IHRydWVcbiAgcmV0dXJuIHZvbHRhZ2Vcbn1cblxuZnVuY3Rpb24gc2NhbGUobm9kZSl7XG4gIHZhciBnYWluID0gbm9kZS5jb250ZXh0LmNyZWF0ZUdhaW4oKVxuICBub2RlLmNvbm5lY3QoZ2FpbilcbiAgcmV0dXJuIGdhaW5cbn1cblxuZnVuY3Rpb24gZ2V0VGltZUNvbnN0YW50KHRpbWUpe1xuICByZXR1cm4gTWF0aC5sb2codGltZSsxKS9NYXRoLmxvZygxMDApXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKHN0YXJ0LCBlbmQsIGZyb21UaW1lLCB0b1RpbWUsIGF0KXtcbiAgdmFyIGRpZmZlcmVuY2UgPSBlbmQgLSBzdGFydFxuICB2YXIgdGltZSA9IHRvVGltZSAtIGZyb21UaW1lXG4gIHZhciB0cnVuY2F0ZVRpbWUgPSBhdCAtIGZyb21UaW1lXG4gIHZhciBwaGFzZSA9IHRydW5jYXRlVGltZSAvIHRpbWVcbiAgdmFyIHZhbHVlID0gc3RhcnQgKyBwaGFzZSAqIGRpZmZlcmVuY2VcblxuICBpZiAodmFsdWUgPD0gc3RhcnQpIHtcbiAgICAgIHZhbHVlID0gc3RhcnRcbiAgfVxuICBpZiAodmFsdWUgPj0gZW5kKSB7XG4gICAgICB2YWx1ZSA9IGVuZFxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy8gREVDT0RFIFVUSUxJVElFU1xuZnVuY3Rpb24gYjY0VG9VaW50NiAobkNocikge1xuICByZXR1cm4gbkNociA+IDY0ICYmIG5DaHIgPCA5MSA/IG5DaHIgLSA2NVxuICAgIDogbkNociA+IDk2ICYmIG5DaHIgPCAxMjMgPyBuQ2hyIC0gNzFcbiAgICA6IG5DaHIgPiA0NyAmJiBuQ2hyIDwgNTggPyBuQ2hyICsgNFxuICAgIDogbkNociA9PT0gNDMgPyA2MlxuICAgIDogbkNociA9PT0gNDcgPyA2M1xuICAgIDogMFxufVxuXG4vLyBEZWNvZGUgQmFzZTY0IHRvIFVpbnQ4QXJyYXlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZGVjb2RlIChzQmFzZTY0LCBuQmxvY2tzU2l6ZSkge1xuICB2YXIgc0I2NEVuYyA9IHNCYXNlNjQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKVxuICB2YXIgbkluTGVuID0gc0I2NEVuYy5sZW5ndGhcbiAgdmFyIG5PdXRMZW4gPSBuQmxvY2tzU2l6ZVxuICAgID8gTWF0aC5jZWlsKChuSW5MZW4gKiAzICsgMSA+PiAyKSAvIG5CbG9ja3NTaXplKSAqIG5CbG9ja3NTaXplXG4gICAgOiBuSW5MZW4gKiAzICsgMSA+PiAyXG4gIHZhciB0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobk91dExlbilcblxuICBmb3IgKHZhciBuTW9kMywgbk1vZDQsIG5VaW50MjQgPSAwLCBuT3V0SWR4ID0gMCwgbkluSWR4ID0gMDsgbkluSWR4IDwgbkluTGVuOyBuSW5JZHgrKykge1xuICAgIG5Nb2Q0ID0gbkluSWR4ICYgM1xuICAgIG5VaW50MjQgfD0gYjY0VG9VaW50NihzQjY0RW5jLmNoYXJDb2RlQXQobkluSWR4KSkgPDwgMTggLSA2ICogbk1vZDRcbiAgICBpZiAobk1vZDQgPT09IDMgfHwgbkluTGVuIC0gbkluSWR4ID09PSAxKSB7XG4gICAgICBmb3IgKG5Nb2QzID0gMDsgbk1vZDMgPCAzICYmIG5PdXRJZHggPCBuT3V0TGVuOyBuTW9kMysrLCBuT3V0SWR4KyspIHtcbiAgICAgICAgdGFCeXRlc1tuT3V0SWR4XSA9IG5VaW50MjQgPj4+ICgxNiA+Pj4gbk1vZDMgJiAyNCkgJiAyNTVcbiAgICAgIH1cbiAgICAgIG5VaW50MjQgPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0YUJ5dGVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWNvZGU6IGRlY29kZSB9XG4iLCIvKiBnbG9iYWwgWE1MSHR0cFJlcXVlc3QgKi9cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEdpdmVuIGEgdXJsIGFuZCBhIHJldHVybiB0eXBlLCByZXR1cm5zIGEgcHJvbWlzZSB0byB0aGUgY29udGVudCBvZiB0aGUgdXJsXG4gKiBCYXNpY2FsbHkgaXQgd3JhcHMgYSBYTUxIdHRwUmVxdWVzdCBpbnRvIGEgUHJvbWlzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gY2FuIGJlICd0ZXh0JyBvciAnYXJyYXlidWZmZXInXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIHR5cGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChkb25lLCByZWplY3QpIHtcbiAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICBpZiAodHlwZSkgcmVxLnJlc3BvbnNlVHlwZSA9IHR5cGVcblxuICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwpXG4gICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcS5zdGF0dXMgPT09IDIwMCA/IGRvbmUocmVxLnJlc3BvbnNlKSA6IHJlamVjdChFcnJvcihyZXEuc3RhdHVzVGV4dCkpXG4gICAgfVxuICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZWplY3QoRXJyb3IoJ05ldHdvcmsgRXJyb3InKSkgfVxuICAgIHJlcS5zZW5kKClcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKVxudmFyIGZldGNoID0gcmVxdWlyZSgnLi9mZXRjaCcpXG5cbi8vIEdpdmVuIGEgcmVnZXgsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgdGVzdCBpZiBhZ2FpbnN0IGEgc3RyaW5nXG5mdW5jdGlvbiBmcm9tUmVnZXggKHIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbyA9PT0gJ3N0cmluZycgJiYgci50ZXN0KG8pIH1cbn1cbi8vIFRyeSB0byBhcHBseSBhIHByZWZpeCB0byBhIG5hbWVcbmZ1bmN0aW9uIHByZWZpeCAocHJlLCBuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgcHJlID09PSAnc3RyaW5nJyA/IHByZSArIG5hbWVcbiAgICA6IHR5cGVvZiBwcmUgPT09ICdmdW5jdGlvbicgPyBwcmUobmFtZSlcbiAgICA6IG5hbWVcbn1cblxuLyoqXG4gKiBMb2FkIG9uZSBvciBtb3JlIGF1ZGlvIGZpbGVzXG4gKlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbiBrZXlzOlxuICpcbiAqIC0gX19mcm9tX18ge0Z1bmN0aW9ufFN0cmluZ306IGEgZnVuY3Rpb24gb3Igc3RyaW5nIHRvIGNvbnZlcnQgZnJvbSBmaWxlIG5hbWVzIHRvIHVybHMuXG4gKiBJZiBpcyBhIHN0cmluZyBpdCB3aWxsIGJlIHByZWZpeGVkIHRvIHRoZSBuYW1lOlxuICogYGxvYWQoYWMsICdzbmFyZS5tcDMnLCB7IGZyb206ICdodHRwOi8vYXVkaW8ubmV0L3NhbXBsZXMvJyB9KWBcbiAqIElmIGl0J3MgYSBmdW5jdGlvbiBpdCByZWNlaXZlcyB0aGUgZmlsZSBuYW1lIGFuZCBzaG91bGQgcmV0dXJuIHRoZSB1cmwgYXMgc3RyaW5nLlxuICogLSBfX29ubHlfXyB7QXJyYXl9IC0gd2hlbiBsb2FkaW5nIG9iamVjdHMsIGlmIHByb3ZpZGVkLCBvbmx5IHRoZSBnaXZlbiBrZXlzXG4gKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBkZWNvZGVkIG9iamVjdDpcbiAqIGBsb2FkKGFjLCAncGlhbm8uanNvbicsIHsgb25seTogWydDMicsICdEMiddIH0pYFxuICpcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBhYyAtIHRoZSBhdWRpbyBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIC0gdGhlIG9iamVjdCB0byBiZSBsb2FkZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gKE9wdGlvbmFsKSB0aGUgbG9hZCBvcHRpb25zIGZvciB0aGF0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRWYWx1ZSAtIChPcHRpb25hbCkgdGhlIGRlZmF1bHQgdmFsdWUgdG8gcmV0dXJuIGFzXG4gKiBpbiBhIHByb21pc2UgaWYgbm90IHZhbGlkIGxvYWRlciBmb3VuZFxuICovXG5mdW5jdGlvbiBsb2FkIChhYywgc291cmNlLCBvcHRpb25zLCBkZWZWYWwpIHtcbiAgdmFyIGxvYWRlciA9XG4gICAgLy8gQmFzaWMgYXVkaW8gbG9hZGluZ1xuICAgICAgaXNBcnJheUJ1ZmZlcihzb3VyY2UpID8gbG9hZEFycmF5QnVmZmVyXG4gICAgOiBpc0F1ZGlvRmlsZU5hbWUoc291cmNlKSA/IGxvYWRBdWRpb0ZpbGVcbiAgICA6IGlzUHJvbWlzZShzb3VyY2UpID8gbG9hZFByb21pc2VcbiAgICAvLyBDb21wb3VuZCBvYmplY3RzXG4gICAgOiBpc0FycmF5KHNvdXJjZSkgPyBsb2FkQXJyYXlEYXRhXG4gICAgOiBpc09iamVjdChzb3VyY2UpID8gbG9hZE9iamVjdERhdGFcbiAgICA6IGlzSnNvbkZpbGVOYW1lKHNvdXJjZSkgPyBsb2FkSnNvbkZpbGVcbiAgICAvLyBCYXNlNjQgZW5jb2RlZCBhdWRpb1xuICAgIDogaXNCYXNlNjRBdWRpbyhzb3VyY2UpID8gbG9hZEJhc2U2NEF1ZGlvXG4gICAgOiBpc0pzRmlsZU5hbWUoc291cmNlKSA/IGxvYWRNaWRpSlNGaWxlXG4gICAgOiBudWxsXG5cbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9XG4gIHJldHVybiBsb2FkZXIgPyBsb2FkZXIoYWMsIHNvdXJjZSwgb3B0cylcbiAgICA6IGRlZlZhbCA/IFByb21pc2UucmVzb2x2ZShkZWZWYWwpXG4gICAgOiBQcm9taXNlLnJlamVjdCgnU291cmNlIG5vdCB2YWxpZCAoJyArIHNvdXJjZSArICcpJylcbn1cbmxvYWQuZmV0Y2ggPSBmZXRjaFxuXG4vLyBCQVNJQyBBVURJTyBMT0FESU5HXG4vLyA9PT09PT09PT09PT09PT09PT09XG5cbi8vIExvYWQgKGRlY29kZSkgYW4gYXJyYXkgYnVmZmVyXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvKSB7IHJldHVybiBvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfVxuZnVuY3Rpb24gbG9hZEFycmF5QnVmZmVyIChhYywgYXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChkb25lLCByZWplY3QpIHtcbiAgICBhYy5kZWNvZGVBdWRpb0RhdGEoYXJyYXksXG4gICAgICBmdW5jdGlvbiAoYnVmZmVyKSB7IGRvbmUoYnVmZmVyKSB9LFxuICAgICAgZnVuY3Rpb24gKCkgeyByZWplY3QoXCJDYW4ndCBkZWNvZGUgYXVkaW8gZGF0YSAoXCIgKyBhcnJheS5zbGljZSgwLCAzMCkgKyAnLi4uKScpIH1cbiAgICApXG4gIH0pXG59XG5cbi8vIExvYWQgYW4gYXVkaW8gZmlsZW5hbWVcbnZhciBpc0F1ZGlvRmlsZU5hbWUgPSBmcm9tUmVnZXgoL1xcLihtcDN8d2F2fG9nZykoXFw/LiopPyQvaSlcbmZ1bmN0aW9uIGxvYWRBdWRpb0ZpbGUgKGFjLCBuYW1lLCBvcHRpb25zKSB7XG4gIHZhciB1cmwgPSBwcmVmaXgob3B0aW9ucy5mcm9tLCBuYW1lKVxuICByZXR1cm4gbG9hZChhYywgbG9hZC5mZXRjaCh1cmwsICdhcnJheWJ1ZmZlcicpLCBvcHRpb25zKVxufVxuXG4vLyBMb2FkIHRoZSByZXN1bHQgb2YgYSBwcm9taXNlXG5mdW5jdGlvbiBpc1Byb21pc2UgKG8pIHsgcmV0dXJuIG8gJiYgdHlwZW9mIG8udGhlbiA9PT0gJ2Z1bmN0aW9uJyB9XG5mdW5jdGlvbiBsb2FkUHJvbWlzZSAoYWMsIHByb21pc2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gbG9hZChhYywgdmFsdWUsIG9wdGlvbnMpXG4gIH0pXG59XG5cbi8vIENPTVBPVU5EIE9CSkVDVFNcbi8vID09PT09PT09PT09PT09PT1cblxuLy8gVHJ5IHRvIGxvYWQgYWxsIHRoZSBpdGVtcyBvZiBhbiBhcnJheVxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5XG5mdW5jdGlvbiBsb2FkQXJyYXlEYXRhIChhYywgYXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGFycmF5Lm1hcChmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBsb2FkKGFjLCBkYXRhLCBvcHRpb25zLCBkYXRhKVxuICB9KSlcbn1cblxuLy8gVHJ5IHRvIGxvYWQgYWxsIHRoZSB2YWx1ZXMgb2YgYSBrZXkvdmFsdWUgb2JqZWN0XG5mdW5jdGlvbiBpc09iamVjdCAobykgeyByZXR1cm4gbyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgfVxuZnVuY3Rpb24gbG9hZE9iamVjdERhdGEgKGFjLCBvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGRlc3QgPSB7fVxuICB2YXIgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKG9wdGlvbnMub25seSAmJiBvcHRpb25zLm9ubHkuaW5kZXhPZihrZXkpID09PSAtMSkgcmV0dXJuIG51bGxcbiAgICB2YXIgdmFsdWUgPSBvYmpba2V5XVxuICAgIHJldHVybiBsb2FkKGFjLCB2YWx1ZSwgb3B0aW9ucywgdmFsdWUpLnRoZW4oZnVuY3Rpb24gKGF1ZGlvKSB7XG4gICAgICBkZXN0W2tleV0gPSBhdWRpb1xuICAgIH0pXG4gIH0pXG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBkZXN0IH0pXG59XG5cbi8vIExvYWQgdGhlIGNvbnRlbnQgb2YgYSBKU09OIGZpbGVcbnZhciBpc0pzb25GaWxlTmFtZSA9IGZyb21SZWdleCgvXFwuanNvbihcXD8uKik/JC9pKVxuZnVuY3Rpb24gbG9hZEpzb25GaWxlIChhYywgbmFtZSwgb3B0aW9ucykge1xuICB2YXIgdXJsID0gcHJlZml4KG9wdGlvbnMuZnJvbSwgbmFtZSlcbiAgcmV0dXJuIGxvYWQoYWMsIGxvYWQuZmV0Y2godXJsLCAndGV4dCcpLnRoZW4oSlNPTi5wYXJzZSksIG9wdGlvbnMpXG59XG5cbi8vIEJBU0U2NCBFTkNPREVEIEZPUk1BVFNcbi8vID09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gTG9hZCBzdHJpbmdzIHdpdGggQmFzZTY0IGVuY29kZWQgYXVkaW9cbnZhciBpc0Jhc2U2NEF1ZGlvID0gZnJvbVJlZ2V4KC9eZGF0YTphdWRpby8pXG5mdW5jdGlvbiBsb2FkQmFzZTY0QXVkaW8gKGFjLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGkgPSBzb3VyY2UuaW5kZXhPZignLCcpXG4gIHJldHVybiBsb2FkKGFjLCBiYXNlNjQuZGVjb2RlKHNvdXJjZS5zbGljZShpICsgMSkpLmJ1ZmZlciwgb3B0aW9ucylcbn1cblxuLy8gTG9hZCAuanMgZmlsZXMgd2l0aCBNaWRpSlMgc291bmRmb250IHByZXJlbmRlcmVkIGF1ZGlvXG52YXIgaXNKc0ZpbGVOYW1lID0gZnJvbVJlZ2V4KC9cXC5qcyhcXD8uKik/JC9pKVxuZnVuY3Rpb24gbG9hZE1pZGlKU0ZpbGUgKGFjLCBuYW1lLCBvcHRpb25zKSB7XG4gIHZhciB1cmwgPSBwcmVmaXgob3B0aW9ucy5mcm9tLCBuYW1lKVxuICByZXR1cm4gbG9hZChhYywgbG9hZC5mZXRjaCh1cmwsICd0ZXh0JykudGhlbihtaWRpSnNUb0pzb24pLCBvcHRpb25zKVxufVxuXG4vLyBjb252ZXJ0IGEgTUlESS5qcyBqYXZhc2NyaXB0IHNvdW5kZm9udCBmaWxlIHRvIGpzb25cbmZ1bmN0aW9uIG1pZGlKc1RvSnNvbiAoZGF0YSkge1xuICB2YXIgYmVnaW4gPSBkYXRhLmluZGV4T2YoJ01JREkuU291bmRmb250LicpXG4gIGlmIChiZWdpbiA8IDApIHRocm93IEVycm9yKCdJbnZhbGlkIE1JREkuanMgU291bmRmb250IGZvcm1hdCcpXG4gIGJlZ2luID0gZGF0YS5pbmRleE9mKCc9JywgYmVnaW4pICsgMlxuICB2YXIgZW5kID0gZGF0YS5sYXN0SW5kZXhPZignLCcpXG4gIHJldHVybiBKU09OLnBhcnNlKGRhdGEuc2xpY2UoYmVnaW4sIGVuZCkgKyAnfScpXG59XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBsb2FkXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHdpbmRvdy5sb2FkQXVkaW8gPSBsb2FkXG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuTWlkaVBsYXllciA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcob2JqKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWVcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHN0cmluZykgfHwgaXNBcnJheUJ1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogbmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVycyBmcm9tIGFub3RoZXIgY29udGV4dCAoaS5lLiBhbiBpZnJhbWUpIGRvIG5vdCBwYXNzIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2tcbi8vIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIgKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiZcbiAgICAgIHR5cGVvZiBvYmouYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpXG59XG5cbi8vIE5vZGUgMC4xMCBzdXBwb3J0cyBgQXJyYXlCdWZmZXJgIGJ1dCBsYWNrcyBgQXJyYXlCdWZmZXIuaXNWaWV3YFxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcgKG9iaikge1xuICByZXR1cm4gKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpICYmIEFycmF5QnVmZmVyLmlzVmlldyhvYmopXG59XG5cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbn0se1wiYmFzZTY0LWpzXCI6MSxcImllZWU3NTRcIjozfV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29uc3RhbnRzIHVzZWQgaW4gcGxheWVyLlxuICovXG52YXIgQ29uc3RhbnRzID0ge1xuXHRWRVJTSU9OOiAnMi4wLjUnLFxuXHROT1RFUzogW10sXG5cdENJUkNMRV9PRl9GT1VSVEhTOiBbJ0MnLCAnRicsICdCYicsICdFYicsICdBYicsICdEYicsICdHYicsICdDYicsICdGYicsICdCYmInLCAnRWJiJywgJ0FiYiddLFxuXHRDSVJDTEVfT0ZfRklGVEhTOiBbJ0MnLCAnRycsICdEJywgJ0EnLCAnRScsICdCJywgJ0YjJywgJ0MjJywgJ0cjJywgJ0QjJywgJ0EjJywgJ0UjJ11cbn07XG5cbi8vIEJ1aWxkcyBub3RlcyBvYmplY3QgZm9yIHJlZmVyZW5jZSBhZ2FpbnN0IGJpbmFyeSB2YWx1ZXMuXG52YXIgYWxsTm90ZXMgPSBbWydDJ10sIFsnQyMnLCAnRGInXSwgWydEJ10sIFsnRCMnLCAnRWInXSwgWydFJ10sIFsnRiddLCBbJ0YjJywgJ0diJ10sIFsnRyddLCBbJ0cjJywgJ0FiJ10sIFsnQSddLCBbJ0EjJywgJ0JiJ10sIFsnQiddXTtcbnZhciBjb3VudGVyID0gMDtcblxuLy8gQWxsIGF2YWlsYWJsZSBvY3RhdmVzLlxuXG52YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG5cdGFsbE5vdGVzLmZvckVhY2goZnVuY3Rpb24gKG5vdGVHcm91cCkge1xuXHRcdG5vdGVHcm91cC5mb3JFYWNoKGZ1bmN0aW9uIChub3RlKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RhbnRzLk5PVEVTW2NvdW50ZXJdID0gbm90ZSArIGk7XG5cdFx0fSk7XG5cdFx0Y291bnRlcisrO1xuXHR9KTtcbn07XG5cbmZvciAodmFyIGkgPSAtMTsgaSA8PSA5OyBpKyspIHtcblx0X2xvb3AoaSk7XG59XG5cbmV4cG9ydHMuQ29uc3RhbnRzID0gQ29uc3RhbnRzO1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgUGxheWVyID0gcmVxdWlyZShcIi4vcGxheWVyXCIpO1xudmFyIFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQbGF5ZXI6IFBsYXllci5QbGF5ZXIsXG4gICAgVXRpbHM6IFV0aWxzLlV0aWxzLFxuICAgIENvbnN0YW50czogQ29uc3RhbnRzLkNvbnN0YW50c1xufTtcblxufSx7XCIuL2NvbnN0YW50c1wiOjQsXCIuL3BsYXllclwiOjYsXCIuL3V0aWxzXCI6OH1dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIikuVXRpbHM7XG52YXIgVHJhY2sgPSByZXF1aXJlKFwiLi90cmFja1wiKS5UcmFjaztcblxuLy8gUG9seWZpbGwgVWludDhBcnJheS5mb3JFYWNoOiBEb2Vzbid0IGV4aXN0IG9uIFNhZmFyaSA8MTBcbmlmICghVWludDhBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDhBcnJheS5wcm90b3R5cGUsICdmb3JFYWNoJywge1xuXHRcdHZhbHVlOiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaFxuXHR9KTtcbn1cblxuLyoqXG4gKiBNYWluIHBsYXllciBjbGFzcy4gIENvbnRhaW5zIG1ldGhvZHMgdG8gbG9hZCBmaWxlcywgc3RhcnQsIHN0b3AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAtIENhbGxiYWNrIHRvIGZpcmUgZm9yIGVhY2ggTUlESSBldmVudC4gIENhbiBhbHNvIGJlIGFkZGVkIHdpdGggb24oJ21pZGlFdmVudCcsIGZuKVxuICogQHBhcmFtIHthcnJheX0gLSBBcnJheSBidWZmZXIgb2YgTUlESSBmaWxlIChvcHRpb25hbCkuXG4gKi9cblxudmFyIFBsYXllciA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gUGxheWVyKGV2ZW50SGFuZGxlciwgYnVmZmVyKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXllcik7XG5cblx0XHR0aGlzLnNhbXBsZVJhdGUgPSA1OyAvLyBtaWxsaXNlY29uZHNcblx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdFx0dGhpcy5idWZmZXIgPSBidWZmZXIgfHwgbnVsbDtcblx0XHR0aGlzLmRpdmlzaW9uO1xuXHRcdHRoaXMuZm9ybWF0O1xuXHRcdHRoaXMuc2V0SW50ZXJ2YWxJZCA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tzID0gW107XG5cdFx0dGhpcy5pbnN0cnVtZW50cyA9IFtdO1xuXHRcdHRoaXMuZGVmYXVsdFRlbXBvID0gMTIwO1xuXHRcdHRoaXMudGVtcG8gPSBudWxsO1xuXHRcdHRoaXMuc3RhcnRUaWNrID0gMDtcblx0XHR0aGlzLnRpY2sgPSAwO1xuXHRcdHRoaXMubGFzdFRpY2sgPSBudWxsO1xuXHRcdHRoaXMuaW5Mb29wID0gZmFsc2U7XG5cdFx0dGhpcy50b3RhbFRpY2tzID0gMDtcblx0XHR0aGlzLmV2ZW50cyA9IFtdO1xuXHRcdHRoaXMudG90YWxFdmVudHMgPSAwO1xuXHRcdHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblxuXHRcdGlmICh0eXBlb2YgZXZlbnRIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB0aGlzLm9uKCdtaWRpRXZlbnQnLCBldmVudEhhbmRsZXIpO1xuXHR9XG5cblx0LyoqXG4gICogTG9hZCBhIGZpbGUgaW50byB0aGUgcGxheWVyIChOb2RlLmpzIG9ubHkpLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gUGF0aCBvZiBmaWxlLlxuICAqIEByZXR1cm4ge1BsYXllcn1cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhQbGF5ZXIsIFt7XG5cdFx0a2V5OiBcImxvYWRGaWxlXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGxvYWRGaWxlKHBhdGgpIHtcblx0XHRcdHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGZzLnJlYWRGaWxlU3luYyhwYXRoKTtcblx0XHRcdHJldHVybiB0aGlzLmZpbGVMb2FkZWQoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogTG9hZCBhbiBhcnJheSBidWZmZXIgaW50byB0aGUgcGxheWVyLlxuICAgKiBAcGFyYW0ge2FycmF5fSBhcnJheUJ1ZmZlciAtIEFycmF5IGJ1ZmZlciBvZiBmaWxlIHRvIGJlIGxvYWRlZC5cbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImxvYWRBcnJheUJ1ZmZlclwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBsb2FkQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZmlsZUxvYWRlZCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBMb2FkIGEgZGF0YSBVUkkgaW50byB0aGUgcGxheWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVyaSAtIERhdGEgVVJJIHRvIGJlIGxvYWRlZC5cbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImxvYWREYXRhVXJpXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGxvYWREYXRhVXJpKGRhdGFVcmkpIHtcblx0XHRcdC8vIGNvbnZlcnQgYmFzZTY0IHRvIHJhdyBiaW5hcnkgZGF0YSBoZWxkIGluIGEgc3RyaW5nLlxuXHRcdFx0Ly8gZG9lc24ndCBoYW5kbGUgVVJMRW5jb2RlZCBEYXRhVVJJcyAtIHNlZSBTTyBhbnN3ZXIgIzY4NTAyNzYgZm9yIGNvZGUgdGhhdCBkb2VzIHRoaXNcblx0XHRcdHZhciBieXRlU3RyaW5nID0gVXRpbHMuYXRvYihkYXRhVXJpLnNwbGl0KCcsJylbMV0pO1xuXG5cdFx0XHQvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlclxuXHRcdFx0dmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGlhO1xuXHRcdFx0cmV0dXJuIHRoaXMuZmlsZUxvYWRlZCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXQgZmlsZXNpemUgb2YgbG9hZGVkIGZpbGUgaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGZpbGVzaXplLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImdldEZpbGVzaXplXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEZpbGVzaXplKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIubGVuZ3RoIDogMDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyBkZWZhdWx0IHRlbXBvLCBwYXJzZXMgZmlsZSBmb3IgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLCBhbmQgZG9lcyBhIGRyeSBydW4gdG8gY2FsY3VsYXRlIHRvdGFsIGxlbmd0aC5cbiAgICogUG9wdWxhdGVzIHRoaXMuZXZlbnRzICYgdGhpcy50b3RhbFRpY2tzLlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZmlsZUxvYWRlZFwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmaWxlTG9hZGVkKCkge1xuXHRcdFx0aWYgKCF0aGlzLnZhbGlkYXRlKCkpIHRocm93ICdJbnZhbGlkIE1JREkgZmlsZTsgc2hvdWxkIHN0YXJ0IHdpdGggTVRoZCc7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRUZW1wbyh0aGlzLmRlZmF1bHRUZW1wbykuZ2V0RGl2aXNpb24oKS5nZXRGb3JtYXQoKS5nZXRUcmFja3MoKS5kcnlSdW4oKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVmFsaWRhdGVzIGZpbGUgdXNpbmcgc2ltcGxlIG1lYW5zIC0gZmlyc3QgZm91ciBieXRlcyBzaG91bGQgPT0gTVRoZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJ2YWxpZGF0ZVwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcblx0XHRcdHJldHVybiBVdGlscy5ieXRlc1RvTGV0dGVycyh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCA0KSkgPT09ICdNVGhkJztcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyBNSURJIGZpbGUgZm9ybWF0IGZvciBsb2FkZWQgZmlsZS5cbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImdldEZvcm1hdFwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXQoKSB7XG5cdFx0XHQvKlxuICAgTUlESSBmaWxlcyBjb21lIGluIDMgdmFyaWF0aW9uczpcbiAgIEZvcm1hdCAwIHdoaWNoIGNvbnRhaW4gYSBzaW5nbGUgdHJhY2tcbiAgIEZvcm1hdCAxIHdoaWNoIGNvbnRhaW4gb25lIG9yIG1vcmUgc2ltdWx0YW5lb3VzIHRyYWNrc1xuICAgKGllIGFsbCB0cmFja3MgYXJlIHRvIGJlIHBsYXllZCBzaW11bHRhbmVvdXNseSkuXG4gICBGb3JtYXQgMiB3aGljaCBjb250YWluIG9uZSBvciBtb3JlIGluZGVwZW5kYW50IHRyYWNrc1xuICAgKGllIGVhY2ggdHJhY2sgaXMgdG8gYmUgcGxheWVkIGluZGVwZW5kYW50bHkgb2YgdGhlIG90aGVycykuXG4gICByZXR1cm4gVXRpbHMuYnl0ZXNUb051bWJlcih0aGlzLmJ1ZmZlci5zdWJhcnJheSg4LCAxMCkpO1xuICAgKi9cblxuXHRcdFx0dGhpcy5mb3JtYXQgPSBVdGlscy5ieXRlc1RvTnVtYmVyKHRoaXMuYnVmZmVyLnN1YmFycmF5KDgsIDEwKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogUGFyc2VzIG91dCB0cmFja3MsIHBsYWNlcyB0aGVtIGluIHRoaXMudHJhY2tzIGFuZCBpbml0aWFsaXplcyB0aGlzLnBvaW50ZXJzXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJnZXRUcmFja3NcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhY2tzKCkge1xuXHRcdFx0dGhpcy50cmFja3MgPSBbXTtcblx0XHRcdHZhciB0cmFja09mZnNldCA9IDA7XG5cdFx0XHR3aGlsZSAodHJhY2tPZmZzZXQgPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKFV0aWxzLmJ5dGVzVG9MZXR0ZXJzKHRoaXMuYnVmZmVyLnN1YmFycmF5KHRyYWNrT2Zmc2V0LCB0cmFja09mZnNldCArIDQpKSA9PSAnTVRyaycpIHtcblx0XHRcdFx0XHR2YXIgdHJhY2tMZW5ndGggPSBVdGlscy5ieXRlc1RvTnVtYmVyKHRoaXMuYnVmZmVyLnN1YmFycmF5KHRyYWNrT2Zmc2V0ICsgNCwgdHJhY2tPZmZzZXQgKyA4KSk7XG5cdFx0XHRcdFx0dGhpcy50cmFja3MucHVzaChuZXcgVHJhY2sodGhpcy50cmFja3MubGVuZ3RoLCB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0cmFja09mZnNldCArIDgsIHRyYWNrT2Zmc2V0ICsgOCArIHRyYWNrTGVuZ3RoKSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJhY2tPZmZzZXQgKz0gVXRpbHMuYnl0ZXNUb051bWJlcih0aGlzLmJ1ZmZlci5zdWJhcnJheSh0cmFja09mZnNldCArIDQsIHRyYWNrT2Zmc2V0ICsgOCkpICsgODtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFbmFibGVzIGEgdHJhY2sgZm9yIHBsYXlpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFja051bWJlciAtIFRyYWNrIG51bWJlclxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZW5hYmxlVHJhY2tcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW5hYmxlVHJhY2sodHJhY2tOdW1iZXIpIHtcblx0XHRcdHRoaXMudHJhY2tzW3RyYWNrTnVtYmVyIC0gMV0uZW5hYmxlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogRGlzYWJsZXMgYSB0cmFjayBmb3IgcGxheWluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IC0gVHJhY2sgbnVtYmVyXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJkaXNhYmxlVHJhY2tcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVRyYWNrKHRyYWNrTnVtYmVyKSB7XG5cdFx0XHR0aGlzLnRyYWNrc1t0cmFja051bWJlciAtIDFdLmRpc2FibGUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHF1YXJ0ZXIgbm90ZSBkaXZpc2lvbiBvZiBsb2FkZWQgTUlESSBmaWxlLlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZ2V0RGl2aXNpb25cIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0RGl2aXNpb24oKSB7XG5cdFx0XHR0aGlzLmRpdmlzaW9uID0gVXRpbHMuYnl0ZXNUb051bWJlcih0aGlzLmJ1ZmZlci5zdWJhcnJheSgxMiwgMTQpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBUaGUgbWFpbiBwbGF5IGxvb3AuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gLSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyBiZWluZyBjYWxsZWQgc2ltcGx5IGZvciBwYXJzaW5nIHB1cnBvc2VzLiAgRGlzcmVnYXJkcyB0aW1pbmcgaWYgc28uXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJwbGF5TG9vcFwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwbGF5TG9vcChkcnlSdW4pIHtcblx0XHRcdGlmICghdGhpcy5pbkxvb3ApIHtcblx0XHRcdFx0dGhpcy5pbkxvb3AgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnRpY2sgPSB0aGlzLmdldEN1cnJlbnRUaWNrKCk7XG5cblx0XHRcdFx0dGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdFx0XHQvLyBIYW5kbGUgbmV4dCBldmVudFxuXHRcdFx0XHRcdGlmICghZHJ5UnVuICYmIHRoaXMuZW5kT2ZGaWxlKCkpIHtcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2VuZCBvZiBmaWxlJylcblx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlclBsYXllckV2ZW50KCdlbmRPZkZpbGUnKTtcblx0XHRcdFx0XHRcdHRoaXMuc3RvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgZXZlbnQgPSB0cmFjay5oYW5kbGVFdmVudCh0aGlzLnRpY2ssIGRyeVJ1bik7XG5cblx0XHRcdFx0XHRcdGlmIChkcnlSdW4gJiYgZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCduYW1lJykgJiYgZXZlbnQubmFtZSA9PT0gJ1NldCBUZW1wbycpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBHcmFiIHRlbXBvIGlmIGF2YWlsYWJsZS5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRlZmF1bHRUZW1wbyA9IGV2ZW50LmRhdGE7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXRUZW1wbyhldmVudC5kYXRhKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoZXZlbnQuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBldmVudC5uYW1lID09PSAnUHJvZ3JhbSBDaGFuZ2UnKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLmluc3RydW1lbnRzLmluY2x1ZGVzKGV2ZW50LnZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5pbnN0cnVtZW50cy5wdXNoKGV2ZW50LnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXZlbnQpIHRoaXMuZW1pdEV2ZW50KGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRcdGlmICghZHJ5UnVuKSB0aGlzLnRyaWdnZXJQbGF5ZXJFdmVudCgncGxheWluZycsIHsgdGljazogdGhpcy50aWNrIH0pO1xuXHRcdFx0XHR0aGlzLmluTG9vcCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRlbXBvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUZW1wbyBpbiBicG0gKGRlZmF1bHRzIHRvIDEyMClcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJzZXRUZW1wb1wiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRUZW1wbyh0ZW1wbykge1xuXHRcdFx0dGhpcy50ZW1wbyA9IHRlbXBvO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHRlciBmb3Igc3RhcnRUaW1lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBVVEMgdGltZXN0YW1wXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwic2V0U3RhcnRUaW1lXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFN0YXJ0VGltZShzdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTdGFydCBwbGF5aW5nIGxvYWRlZCBNSURJIGZpbGUgaWYgbm90IGFscmVhZHkgcGxheWluZy5cbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcInBsYXlcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcblx0XHRcdGlmICh0aGlzLmlzUGxheWluZygpKSB0aHJvdyAnQWxyZWFkeSBwbGF5aW5nLi4uJztcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZVxuXHRcdFx0aWYgKCF0aGlzLnN0YXJ0VGltZSkgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHRcdFx0Ly8gU3RhcnQgcGxheSBsb29wXG5cdFx0XHQvL3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5wbGF5TG9vcC5iaW5kKHRoaXMpKTtcblx0XHRcdHRoaXMuc2V0SW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRoaXMucGxheUxvb3AuYmluZCh0aGlzKSwgdGhpcy5zYW1wbGVSYXRlKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFBhdXNlcyBwbGF5YmFjayBpZiBwbGF5aW5nLlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwicGF1c2VcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuc2V0SW50ZXJ2YWxJZCk7XG5cdFx0XHR0aGlzLnNldEludGVydmFsSWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuc3RhcnRUaWNrID0gdGhpcy50aWNrO1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN0b3BzIHBsYXliYWNrIGlmIHBsYXlpbmcuXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJzdG9wXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuc2V0SW50ZXJ2YWxJZCk7XG5cdFx0XHR0aGlzLnNldEludGVydmFsSWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuc3RhcnRUaWNrID0gMDtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gMDtcblx0XHRcdHRoaXMucmVzZXRUcmFja3MoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTa2lwcyBwbGF5ZXIgcG9pbnRlciB0byBzcGVjaWZpZWQgdGljay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IC0gVGljayB0byBza2lwIHRvLlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwic2tpcFRvVGlja1wiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBza2lwVG9UaWNrKHRpY2spIHtcblx0XHRcdHRoaXMuc3RvcCgpO1xuXHRcdFx0dGhpcy5zdGFydFRpY2sgPSB0aWNrO1xuXG5cdFx0XHQvLyBOZWVkIHRvIHNldCB0cmFjayBldmVudCBpbmRleGVzIHRvIHRoZSBuZWFyZXN0IHBvc3NpYmxlIGV2ZW50IHRvIHRoZSBzcGVjaWZpZWQgdGljay5cblx0XHRcdHRoaXMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG5cdFx0XHRcdHRyYWNrLnNldEV2ZW50SW5kZXhCeVRpY2sodGljayk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTa2lwcyBwbGF5ZXIgcG9pbnRlciB0byBzcGVjaWZpZWQgcGVyY2VudGFnZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IC0gUGVyY2VudCB2YWx1ZSBpbiBpbnRlZ2VyIGZvcm1hdC5cbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcInNraXBUb1BlcmNlbnRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2tpcFRvUGVyY2VudChwZXJjZW50KSB7XG5cdFx0XHRpZiAocGVyY2VudCA8IDAgfHwgcGVyY2VudCA+IDEwMCkgdGhyb3cgXCJQZXJjZW50IG11c3QgYmUgbnVtYmVyIGJldHdlZW4gMSBhbmQgMTAwLlwiO1xuXHRcdFx0dGhpcy5za2lwVG9UaWNrKE1hdGgucm91bmQocGVyY2VudCAvIDEwMCAqIHRoaXMudG90YWxUaWNrcykpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNraXBzIHBsYXllciBwb2ludGVyIHRvIHNwZWNpZmllZCBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBTZWNvbmRzIHRvIHNraXAgdG8uXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJza2lwVG9TZWNvbmRzXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNraXBUb1NlY29uZHMoc2Vjb25kcykge1xuXHRcdFx0dmFyIHNvbmdUaW1lID0gdGhpcy5nZXRTb25nVGltZSgpO1xuXHRcdFx0aWYgKHNlY29uZHMgPCAwIHx8IHNlY29uZHMgPiBzb25nVGltZSkgdGhyb3cgc2Vjb25kcyArIFwiIHNlY29uZHMgbm90IHdpdGhpbiBzb25nIHRpbWUgb2YgXCIgKyBzb25nVGltZTtcblx0XHRcdHRoaXMuc2tpcFRvUGVyY2VudChzZWNvbmRzIC8gc29uZ1RpbWUgKiAxMDApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiBwbGF5ZXIgaXMgcGxheWluZ1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImlzUGxheWluZ1wiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc1BsYXlpbmcoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRJbnRlcnZhbElkID4gMCB8fCBfdHlwZW9mKHRoaXMuc2V0SW50ZXJ2YWxJZCkgPT09ICdvYmplY3QnO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBQbGF5cyB0aGUgbG9hZGVkIE1JREkgZmlsZSB3aXRob3V0IHJlZ2FyZCBmb3IgdGltaW5nIGFuZCBzYXZlcyBldmVudHMgaW4gdGhpcy5ldmVudHMuICBFc3NlbnRpYWxseSB1c2VkIGFzIGEgcGFyc2VyLlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZHJ5UnVuXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRyeVJ1bigpIHtcblx0XHRcdC8vIFJlc2V0IHRyYWNrcyBmaXJzdFxuXHRcdFx0dGhpcy5yZXNldFRyYWNrcygpO1xuXHRcdFx0d2hpbGUgKCF0aGlzLmVuZE9mRmlsZSgpKSB7XG5cdFx0XHRcdHRoaXMucGxheUxvb3AodHJ1ZSk7XG5cdFx0XHR9dGhpcy5ldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0dGhpcy50b3RhbEV2ZW50cyA9IHRoaXMuZ2V0VG90YWxFdmVudHMoKTtcblx0XHRcdHRoaXMudG90YWxUaWNrcyA9IHRoaXMuZ2V0VG90YWxUaWNrcygpO1xuXHRcdFx0dGhpcy5zdGFydFRpY2sgPSAwO1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXG5cdFx0XHQvLyBMZWF2ZSB0cmFja3MgaW4gcHJpc3RpbmUgY29uZGlzaFxuXHRcdFx0dGhpcy5yZXNldFRyYWNrcygpO1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdTb25nIHRpbWU6ICcgKyB0aGlzLmdldFNvbmdUaW1lKCkgKyAnIHNlY29uZHMgLyAnICsgdGhpcy50b3RhbFRpY2tzICsgJyB0aWNrcy4nKTtcblxuXHRcdFx0dGhpcy50cmlnZ2VyUGxheWVyRXZlbnQoJ2ZpbGVMb2FkZWQnLCB0aGlzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXNldHMgcGxheSBwb2ludGVycyBmb3IgYWxsIHRyYWNrcy5cbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcInJlc2V0VHJhY2tzXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlc2V0VHJhY2tzKCkge1xuXHRcdFx0dGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdFx0cmV0dXJuIHRyYWNrLnJlc2V0KCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IG9mIGV2ZW50cyBncm91cGVkIGJ5IHRyYWNrLlxuICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJnZXRFdmVudHNcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0RXZlbnRzKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdFx0cmV0dXJuIHRyYWNrLmV2ZW50cztcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRvdGFsIG51bWJlciBvZiB0aWNrcyBpbiB0aGUgbG9hZGVkIE1JREkgZmlsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImdldFRvdGFsVGlja3NcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0VG90YWxUaWNrcygpIHtcblx0XHRcdHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLnRyYWNrcy5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7XG5cdFx0XHRcdHJldHVybiB0cmFjay5kZWx0YTtcblx0XHRcdH0pKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0b3RhbCBudW1iZXIgb2YgZXZlbnRzIGluIHRoZSBsb2FkZWQgTUlESSBmaWxlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZ2V0VG90YWxFdmVudHNcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0VG90YWxFdmVudHMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmFja3MucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdHJldHVybiB7IGV2ZW50czogeyBsZW5ndGg6IGEuZXZlbnRzLmxlbmd0aCArIGIuZXZlbnRzLmxlbmd0aCB9IH07XG5cdFx0XHR9LCB7IGV2ZW50czogeyBsZW5ndGg6IDAgfSB9KS5ldmVudHMubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHNvbmcgZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImdldFNvbmdUaW1lXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFNvbmdUaW1lKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaWNrcyAvIHRoaXMuZGl2aXNpb24gLyB0aGlzLnRlbXBvICogNjA7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgcmVtYWluaW5nIG51bWJlciBvZiBzZWNvbmRzIGluIHBsYXliYWNrLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZ2V0U29uZ1RpbWVSZW1haW5pbmdcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U29uZ1RpbWVSZW1haW5pbmcoKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCgodGhpcy50b3RhbFRpY2tzIC0gdGhpcy5nZXRDdXJyZW50VGljaygpKSAvIHRoaXMuZGl2aXNpb24gLyB0aGlzLnRlbXBvICogNjApO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHJlbWFpbmluZyBwZXJjZW50IG9mIHBsYXliYWNrLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZ2V0U29uZ1BlcmNlbnRSZW1haW5pbmdcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U29uZ1BlcmNlbnRSZW1haW5pbmcoKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmdldFNvbmdUaW1lUmVtYWluaW5nKCkgLyB0aGlzLmdldFNvbmdUaW1lKCkgKiAxMDApO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBOdW1iZXIgb2YgYnl0ZXMgcHJvY2Vzc2VkIGluIHRoZSBsb2FkZWQgTUlESSBmaWxlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiYnl0ZXNQcm9jZXNzZWRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gYnl0ZXNQcm9jZXNzZWQoKSB7XG5cdFx0XHQvLyBDdXJyZW50bHkgYXNzdW1lIGhlYWRlciBjaHVuayBpcyBzdHJpY3RseSAxNCBieXRlc1xuXHRcdFx0cmV0dXJuIDE0ICsgdGhpcy50cmFja3MubGVuZ3RoICogOCArIHRoaXMudHJhY2tzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4geyBwb2ludGVyOiBhLnBvaW50ZXIgKyBiLnBvaW50ZXIgfTtcblx0XHRcdH0sIHsgcG9pbnRlcjogMCB9KS5wb2ludGVyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBOdW1iZXIgb2YgZXZlbnRzIHBsYXllZCB1cCB0byB0aGlzIHBvaW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZXZlbnRzUGxheWVkXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGV2ZW50c1BsYXllZCgpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIHsgZXZlbnRJbmRleDogYS5ldmVudEluZGV4ICsgYi5ldmVudEluZGV4IH07XG5cdFx0XHR9LCB7IGV2ZW50SW5kZXg6IDAgfSkuZXZlbnRJbmRleDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgcGxheWVyIHBvaW50ZXIgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbG9hZGVkIE1JREkgZmlsZS5cbiAgICogVXNlZCBpbiB0d28gd2F5czpcbiAgICogMS4gSWYgcGxheWluZyByZXN1bHQgaXMgYmFzZWQgb24gbG9hZGVkIEpTT04gZXZlbnRzLlxuICAgKiAyLiBJZiBwYXJzaW5nIChkcnlSdW4pIGl0J3MgYmFzZWQgb24gdGhlIGFjdHVhbCBidWZmZXIgbGVuZ3RoIHZzIGJ5dGVzIHByb2Nlc3NlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJlbmRPZkZpbGVcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuXHRcdFx0aWYgKHRoaXMuaXNQbGF5aW5nKCkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaWNrcyAtIHRoaXMudGljayA8PSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5ieXRlc1Byb2Nlc3NlZCgpID09IHRoaXMuYnVmZmVyLmxlbmd0aDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB0aWNrIG51bWJlciBpbiBwbGF5YmFjay5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImdldEN1cnJlbnRUaWNrXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUaWNrKCkge1xuXHRcdFx0aWYgKCF0aGlzLnN0YXJ0VGltZSAmJiB0aGlzLnRpY2spIHJldHVybiB0aGlzLnN0YXJ0VGljaztlbHNlIGlmICghdGhpcy5zdGFydFRpbWUpIHJldHVybiAwO1xuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5zdGFydFRpbWUpIC8gMTAwMCAqICh0aGlzLmRpdmlzaW9uICogKHRoaXMudGVtcG8gLyA2MCkpKSArIHRoaXMuc3RhcnRUaWNrO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZW5kcyBNSURJIGV2ZW50IG91dCB0byBsaXN0ZW5lci5cbiAgICogQHBhcmFtIHtvYmplY3R9XG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJlbWl0RXZlbnRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW1pdEV2ZW50KGV2ZW50KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXJQbGF5ZXJFdmVudCgnbWlkaUV2ZW50JywgZXZlbnQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN1YnNjcmliZXMgZXZlbnRzIHRvIGxpc3RlbmVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gLSBOYW1lIG9mIGV2ZW50IHRvIHN1YnNjcmliZSB0by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gLSBDYWxsYmFjayB0byBmaXJlIHdoZW4gZXZlbnQgaXMgYnJvYWRjYXN0LlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwib25cIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gb24ocGxheWVyRXZlbnQsIGZuKSB7XG5cdFx0XHRpZiAoIXRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkocGxheWVyRXZlbnQpKSB0aGlzLmV2ZW50TGlzdGVuZXJzW3BsYXllckV2ZW50XSA9IFtdO1xuXHRcdFx0dGhpcy5ldmVudExpc3RlbmVyc1twbGF5ZXJFdmVudF0ucHVzaChmbik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQnJvYWRjYXN0cyBldmVudCB0byB0cmlnZ2VyIHN1YnNjcmliZWQgY2FsbGJhY2tzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gLSBOYW1lIG9mIGV2ZW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gLSBEYXRhIHRvIGJlIHBhc3NlZCB0byBzdWJzY3JpYmVyIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwidHJpZ2dlclBsYXllckV2ZW50XCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXJQbGF5ZXJFdmVudChwbGF5ZXJFdmVudCwgZGF0YSkge1xuXHRcdFx0aWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkocGxheWVyRXZlbnQpKSB0aGlzLmV2ZW50TGlzdGVuZXJzW3BsYXllckV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuXHRcdFx0XHRyZXR1cm4gZm4oZGF0YSB8fCB7fSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBQbGF5ZXI7XG59KCk7XG5cbmV4cG9ydHMuUGxheWVyID0gUGxheWVyO1xuXG59LHtcIi4vdHJhY2tcIjo3LFwiLi91dGlsc1wiOjgsXCJmc1wiOlwiZnNcIn1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIikuQ29uc3RhbnRzO1xudmFyIFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIikuVXRpbHM7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgdHJhY2suICBDb250YWlucyBtZXRob2RzIGZvciBwYXJzaW5nIGV2ZW50cyBhbmQga2VlcGluZyB0cmFjayBvZiBwb2ludGVyLlxuICovXG5cbnZhciBUcmFjayA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gVHJhY2soaW5kZXgsIGRhdGEpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xuXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50SW5kZXggPSAwO1xuXHRcdHRoaXMucG9pbnRlciA9IDA7XG5cdFx0dGhpcy5sYXN0VGljayA9IDA7XG5cdFx0dGhpcy5sYXN0U3RhdHVzID0gbnVsbDtcblx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHR0aGlzLmRlbHRhID0gMDtcblx0XHR0aGlzLnJ1bm5pbmdEZWx0YSA9IDA7XG5cdFx0dGhpcy5ldmVudHMgPSBbXTtcblx0fVxuXG5cdC8qKlxuICAqIFJlc2V0cyBhbGwgc3RhdGVmdWwgdHJhY2sgaW5mb3JtYWlvbiB1c2VkIGR1cmluZyBwbGF5YmFjay5cbiAgKiBAcmV0dXJuIHtUcmFja31cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhUcmFjaywgW3tcblx0XHRrZXk6IFwicmVzZXRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG5cdFx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5ldmVudEluZGV4ID0gMDtcblx0XHRcdHRoaXMucG9pbnRlciA9IDA7XG5cdFx0XHR0aGlzLmxhc3RUaWNrID0gMDtcblx0XHRcdHRoaXMubGFzdFN0YXR1cyA9IG51bGw7XG5cdFx0XHR0aGlzLmRlbHRhID0gMDtcblx0XHRcdHRoaXMucnVubmluZ0RlbHRhID0gMDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoaXMgdHJhY2sgdG8gYmUgZW5hYmxlZCBkdXJpbmcgcGxheWJhY2suXG4gICAqIEByZXR1cm4ge1RyYWNrfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImVuYWJsZVwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG5cdFx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhpcyB0cmFjayB0byBiZSBkaXNhYmxlZCBkdXJpbmcgcGxheWJhY2suXG4gICAqIEByZXR1cm4ge1RyYWNrfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImRpc2FibGVcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHRyYWNrIGV2ZW50IGluZGV4IHRvIHRoZSBuZWFyZXN0IGV2ZW50IHRvIHRoZSBnaXZlbiB0aWNrLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGlja1xuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogXCJzZXRFdmVudEluZGV4QnlUaWNrXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldEV2ZW50SW5kZXhCeVRpY2sodGljaykge1xuXHRcdFx0dGljayA9IHRpY2sgfHwgMDtcblxuXHRcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLmV2ZW50cykge1xuXHRcdFx0XHRpZiAodGhpcy5ldmVudHNbaV0udGljayA+PSB0aWNrKSB7XG5cdFx0XHRcdFx0dGhpcy5ldmVudEluZGV4ID0gaTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIGJ5dGUgbG9jYXRlZCBhdCBwb2ludGVyIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiZ2V0Q3VycmVudEJ5dGVcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudEJ5dGUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhW3RoaXMucG9pbnRlcl07XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgY291bnQgb2YgZGVsdGEgYnl0ZXMgYW5kIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImdldERlbHRhQnl0ZUNvdW50XCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldERlbHRhQnl0ZUNvdW50KCkge1xuXHRcdFx0Ly8gR2V0IGJ5dGUgY291bnQgb2YgZGVsdGEgVkxWXG5cdFx0XHQvLyBodHRwOi8vd3d3LmNjYXJoLm9yZy9jb3Vyc2VzLzI1My9oYW5kb3V0L3Zsdi9cblx0XHRcdC8vIElmIGJ5dGUgaXMgZ3JlYXRlciBvciBlcXVhbCB0byA4MGggKDEyOCBkZWNpbWFsKSB0aGVuIHRoZSBuZXh0IGJ5dGVcblx0XHRcdC8vIGlzIGFsc28gcGFydCBvZiB0aGUgVkxWLFxuXHRcdFx0Ly8gZWxzZSBieXRlIGlzIHRoZSBsYXN0IGJ5dGUgaW4gYSBWTFYuXG5cdFx0XHR2YXIgY3VycmVudEJ5dGUgPSB0aGlzLmdldEN1cnJlbnRCeXRlKCk7XG5cdFx0XHR2YXIgYnl0ZUNvdW50ID0gMTtcblxuXHRcdFx0d2hpbGUgKGN1cnJlbnRCeXRlID49IDEyOCkge1xuXHRcdFx0XHRjdXJyZW50Qnl0ZSA9IHRoaXMuZGF0YVt0aGlzLnBvaW50ZXIgKyBieXRlQ291bnRdO1xuXHRcdFx0XHRieXRlQ291bnQrKztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ5dGVDb3VudDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0IGRlbHRhIHZhbHVlIGF0IGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImdldERlbHRhXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldERlbHRhKCkge1xuXHRcdFx0cmV0dXJuIFV0aWxzLnJlYWRWYXJJbnQodGhpcy5kYXRhLnN1YmFycmF5KHRoaXMucG9pbnRlciwgdGhpcy5wb2ludGVyICsgdGhpcy5nZXREZWx0YUJ5dGVDb3VudCgpKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEhhbmRsZXMgZXZlbnQgd2l0aGluIGEgZ2l2ZW4gdHJhY2sgc3RhcnRpbmcgYXQgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VGlja1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRyeVJ1biAtIElmIHRydWUgZXZlbnRzIHdpbGwgYmUgcGFyc2VkIGFuZCByZXR1cm5lZCByZWdhcmRsZXNzIG9mIHRpbWUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwiaGFuZGxlRXZlbnRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQoY3VycmVudFRpY2ssIGRyeVJ1bikge1xuXHRcdFx0ZHJ5UnVuID0gZHJ5UnVuIHx8IGZhbHNlO1xuXG5cdFx0XHRpZiAoZHJ5UnVuKSB7XG5cdFx0XHRcdHZhciBlbGFwc2VkVGlja3MgPSBjdXJyZW50VGljayAtIHRoaXMubGFzdFRpY2s7XG5cdFx0XHRcdHZhciBkZWx0YSA9IHRoaXMuZ2V0RGVsdGEoKTtcblx0XHRcdFx0dmFyIGV2ZW50UmVhZHkgPSBlbGFwc2VkVGlja3MgPj0gZGVsdGE7XG5cblx0XHRcdFx0aWYgKHRoaXMucG9pbnRlciA8IHRoaXMuZGF0YS5sZW5ndGggJiYgKGRyeVJ1biB8fCBldmVudFJlYWR5KSkge1xuXHRcdFx0XHRcdHZhciBfZXZlbnQgPSB0aGlzLnBhcnNlRXZlbnQoKTtcblx0XHRcdFx0XHRpZiAodGhpcy5lbmFibGVkKSByZXR1cm4gX2V2ZW50O1xuXHRcdFx0XHRcdC8vIFJlY3Vyc2l2ZWx5IGNhbGwgdGhpcyBmdW5jdGlvbiBmb3IgZWFjaCBldmVudCBhaGVhZCB0aGF0IGhhcyAwIGRlbHRhIHRpbWU/XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIExldCdzIGFjdHVhbGx5IHBsYXkgdGhlIE1JREkgZnJvbSB0aGUgZ2VuZXJhdGVkIEpTT04gZXZlbnRzIGNyZWF0ZWQgYnkgdGhlIGRyeSBydW4uXG5cdFx0XHRcdGlmICh0aGlzLmV2ZW50c1t0aGlzLmV2ZW50SW5kZXhdICYmIHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRJbmRleF0udGljayA8PSBjdXJyZW50VGljaykge1xuXHRcdFx0XHRcdHRoaXMuZXZlbnRJbmRleCsrO1xuXHRcdFx0XHRcdGlmICh0aGlzLmVuYWJsZWQpIHJldHVybiB0aGlzLmV2ZW50c1t0aGlzLmV2ZW50SW5kZXggLSAxXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0IHN0cmluZyBkYXRhIGZyb20gZXZlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFN0YXJ0SW5kZXhcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImdldFN0cmluZ0RhdGFcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U3RyaW5nRGF0YShldmVudFN0YXJ0SW5kZXgpIHtcblx0XHRcdHZhciBjdXJyZW50Qnl0ZSA9IHRoaXMucG9pbnRlcjtcblx0XHRcdHZhciBieXRlQ291bnQgPSAxO1xuXHRcdFx0dmFyIGxlbmd0aCA9IFV0aWxzLnJlYWRWYXJJbnQodGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDIsIGV2ZW50U3RhcnRJbmRleCArIDIgKyBieXRlQ291bnQpKTtcblx0XHRcdHZhciBzdHJpbmdMZW5ndGggPSBsZW5ndGg7XG5cblx0XHRcdHJldHVybiBVdGlscy5ieXRlc1RvTGV0dGVycyh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgYnl0ZUNvdW50ICsgMiwgZXZlbnRTdGFydEluZGV4ICsgYnl0ZUNvdW50ICsgbGVuZ3RoICsgMikpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBQYXJzZXMgZXZlbnQgaW50byBKU09OIGFuZCBhZHZhbmNlcyBwb2ludGVyIGZvciB0aGUgdHJhY2tcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcInBhcnNlRXZlbnRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gcGFyc2VFdmVudCgpIHtcblx0XHRcdHZhciBldmVudFN0YXJ0SW5kZXggPSB0aGlzLnBvaW50ZXIgKyB0aGlzLmdldERlbHRhQnl0ZUNvdW50KCk7XG5cdFx0XHR2YXIgZXZlbnRKc29uID0ge307XG5cdFx0XHR2YXIgZGVsdGFCeXRlQ291bnQgPSB0aGlzLmdldERlbHRhQnl0ZUNvdW50KCk7XG5cdFx0XHRldmVudEpzb24udHJhY2sgPSB0aGlzLmluZGV4ICsgMTtcblx0XHRcdGV2ZW50SnNvbi5kZWx0YSA9IHRoaXMuZ2V0RGVsdGEoKTtcblx0XHRcdHRoaXMubGFzdFRpY2sgPSB0aGlzLmxhc3RUaWNrICsgZXZlbnRKc29uLmRlbHRhO1xuXHRcdFx0dGhpcy5ydW5uaW5nRGVsdGEgKz0gZXZlbnRKc29uLmRlbHRhO1xuXHRcdFx0ZXZlbnRKc29uLnRpY2sgPSB0aGlzLnJ1bm5pbmdEZWx0YTtcblx0XHRcdGV2ZW50SnNvbi5ieXRlSW5kZXggPSB0aGlzLnBvaW50ZXI7XG5cblx0XHRcdC8vZXZlbnRKc29uLnJhdyA9IGV2ZW50O1xuXHRcdFx0aWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdID09IDB4ZmYpIHtcblx0XHRcdFx0Ly8gTWV0YSBFdmVudFxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYSBtZXRhIGV2ZW50IHdlIHNob3VsZCBlbWl0IHRoZSBkYXRhIGFuZCBpbW1lZGlhdGVseSBtb3ZlIHRvIHRoZSBuZXh0IGV2ZW50XG5cdFx0XHRcdC8vIG90aGVyd2lzZSBpZiB3ZSBsZXQgaXQgcnVuIHRocm91Z2ggdGhlIG5leHQgY3ljbGUgYSBzbGlnaHQgZGVsYXkgd2lsbCBhY2N1bXVsYXRlIGlmIG11bHRpcGxlIHRyYWNrc1xuXHRcdFx0XHQvLyBhcmUgYmVpbmcgcGxheWVkIHNpbXVsdGFuZW91c2x5XG5cblx0XHRcdFx0c3dpdGNoICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV0pIHtcblx0XHRcdFx0XHRjYXNlIDB4MDA6XG5cdFx0XHRcdFx0XHQvLyBTZXF1ZW5jZSBOdW1iZXJcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1NlcXVlbmNlIE51bWJlcic7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDB4MDE6XG5cdFx0XHRcdFx0XHQvLyBUZXh0IEV2ZW50XG5cdFx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdUZXh0IEV2ZW50Jztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5zdHJpbmcgPSB0aGlzLmdldFN0cmluZ0RhdGEoZXZlbnRTdGFydEluZGV4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMHgwMjpcblx0XHRcdFx0XHRcdC8vIENvcHlyaWdodCBOb3RpY2Vcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ0NvcHlyaWdodCBOb3RpY2UnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAweDAzOlxuXHRcdFx0XHRcdFx0Ly8gU2VxdWVuY2UvVHJhY2sgTmFtZVxuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnU2VxdWVuY2UvVHJhY2sgTmFtZSc7XG5cdFx0XHRcdFx0XHRldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDB4MDQ6XG5cdFx0XHRcdFx0XHQvLyBJbnN0cnVtZW50IE5hbWVcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ0luc3RydW1lbnQgTmFtZSc7XG5cdFx0XHRcdFx0XHRldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDB4MDU6XG5cdFx0XHRcdFx0XHQvLyBMeXJpY1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnTHlyaWMnO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLnN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nRGF0YShldmVudFN0YXJ0SW5kZXgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAweDA2OlxuXHRcdFx0XHRcdFx0Ly8gTWFya2VyXG5cdFx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdNYXJrZXInO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAweDA3OlxuXHRcdFx0XHRcdFx0Ly8gQ3VlIFBvaW50XG5cdFx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdDdWUgUG9pbnQnO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLnN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nRGF0YShldmVudFN0YXJ0SW5kZXgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAweDA5OlxuXHRcdFx0XHRcdFx0Ly8gRGV2aWNlIE5hbWVcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ0RldmljZSBOYW1lJztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5zdHJpbmcgPSB0aGlzLmdldFN0cmluZ0RhdGEoZXZlbnRTdGFydEluZGV4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMHgyMDpcblx0XHRcdFx0XHRcdC8vIE1JREkgQ2hhbm5lbCBQcmVmaXhcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ01JREkgQ2hhbm5lbCBQcmVmaXgnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAweDIxOlxuXHRcdFx0XHRcdFx0Ly8gTUlESSBQb3J0XG5cdFx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdNSURJIFBvcnQnO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLmRhdGEgPSBVdGlscy5ieXRlc1RvTnVtYmVyKFt0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgM11dKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMHgyRjpcblx0XHRcdFx0XHRcdC8vIEVuZCBvZiBUcmFja1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnRW5kIG9mIFRyYWNrJztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMHg1MTpcblx0XHRcdFx0XHRcdC8vIFNldCBUZW1wb1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnU2V0IFRlbXBvJztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5kYXRhID0gTWF0aC5yb3VuZCg2MDAwMDAwMCAvIFV0aWxzLmJ5dGVzVG9OdW1iZXIodGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDMsIGV2ZW50U3RhcnRJbmRleCArIDYpKSk7XG5cdFx0XHRcdFx0XHR0aGlzLnRlbXBvID0gZXZlbnRKc29uLmRhdGE7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDB4NTQ6XG5cdFx0XHRcdFx0XHQvLyBTTVRQRSBPZmZzZXRcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1NNVFBFIE9mZnNldCc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDB4NTg6XG5cdFx0XHRcdFx0XHQvLyBUaW1lIFNpZ25hdHVyZVxuXHRcdFx0XHRcdFx0Ly8gRkYgNTggMDQgbm4gZGQgY2MgYmJcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1RpbWUgU2lnbmF0dXJlJztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5kYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDMsIGV2ZW50U3RhcnRJbmRleCArIDcpO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLnRpbWVTaWduYXR1cmUgPSBcIlwiICsgZXZlbnRKc29uLmRhdGFbMF0gKyBcIi9cIiArIE1hdGgucG93KDIsIGV2ZW50SnNvbi5kYXRhWzFdKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMHg1OTpcblx0XHRcdFx0XHRcdC8vIEtleSBTaWduYXR1cmVcblx0XHRcdFx0XHRcdC8vIEZGIDU5IDAyIHNmIG1pXG5cdFx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdLZXkgU2lnbmF0dXJlJztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5kYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDMsIGV2ZW50U3RhcnRJbmRleCArIDUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoZXZlbnRKc29uLmRhdGFbMF0gPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRldmVudEpzb24ua2V5U2lnbmF0dXJlID0gQ29uc3RhbnRzLkNJUkNMRV9PRl9GSUZUSFNbZXZlbnRKc29uLmRhdGFbMF1dO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChldmVudEpzb24uZGF0YVswXSA8IDApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnRKc29uLmtleVNpZ25hdHVyZSA9IENvbnN0YW50cy5DSVJDTEVfT0ZfRk9VUlRIU1tNYXRoLmFicyhldmVudEpzb24uZGF0YVswXSldO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoZXZlbnRKc29uLmRhdGFbMV0gPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRldmVudEpzb24ua2V5U2lnbmF0dXJlICs9IFwiIE1ham9yXCI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50SnNvbi5kYXRhWzFdID09IDEpIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnRKc29uLmtleVNpZ25hdHVyZSArPSBcIiBNaW5vclwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDB4N0Y6XG5cdFx0XHRcdFx0XHQvLyBTZXF1ZW5jZXItU3BlY2lmaWMgTWV0YS1ldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnU2VxdWVuY2VyLVNwZWNpZmljIE1ldGEtZXZlbnQnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1Vua25vd246ICcgKyB0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV0udG9TdHJpbmcoMTYpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5kYXRhW3RoaXMucG9pbnRlciArIGRlbHRhQnl0ZUNvdW50ICsgMl07XG5cdFx0XHRcdC8vIFNvbWUgbWV0YSBldmVudHMgd2lsbCBoYXZlIHZsdiB0aGF0IG5lZWRzIHRvIGJlIGhhbmRsZWRcblxuXHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzICsgbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSA9PSAweGYwKSB7XG5cdFx0XHRcdC8vIFN5c2V4XG5cdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1N5c2V4Jztcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuZGF0YVt0aGlzLnBvaW50ZXIgKyBkZWx0YUJ5dGVDb3VudCArIDFdO1xuXHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAyICsgbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVm9pY2UgZXZlbnRcblx0XHRcdFx0aWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDwgMHg4MCkge1xuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgc3RhdHVzXG5cdFx0XHRcdFx0ZXZlbnRKc29uLnJ1bm5pbmcgPSB0cnVlO1xuXHRcdFx0XHRcdGV2ZW50SnNvbi5ub3RlTnVtYmVyID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF07XG5cdFx0XHRcdFx0ZXZlbnRKc29uLm5vdGVOYW1lID0gQ29uc3RhbnRzLk5PVEVTW3RoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdXTtcblx0XHRcdFx0XHRldmVudEpzb24udmVsb2NpdHkgPSB0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV07XG5cblx0XHRcdFx0XHRpZiAodGhpcy5sYXN0U3RhdHVzIDw9IDB4OGYpIHtcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ05vdGUgb2ZmJztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHg4MCArIDE7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmxhc3RTdGF0dXMgPD0gMHg5Zikge1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLm5hbWUgPSAnTm90ZSBvbic7XG5cdFx0XHRcdFx0XHRldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4OTAgKyAxO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMucG9pbnRlciArPSBkZWx0YUJ5dGVDb3VudCArIDI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5sYXN0U3RhdHVzID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF07XG5cblx0XHRcdFx0XHRpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPD0gMHg4Zikge1xuXHRcdFx0XHRcdFx0Ly8gTm90ZSBvZmZcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ05vdGUgb2ZmJztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHg4MCArIDE7XG5cdFx0XHRcdFx0XHRldmVudEpzb24ubm90ZU51bWJlciA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAxXTtcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5ub3RlTmFtZSA9IENvbnN0YW50cy5OT1RFU1t0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV1dO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLnZlbG9jaXR5ID0gTWF0aC5yb3VuZCh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMl0gLyAxMjcgKiAxMDApO1xuXHRcdFx0XHRcdFx0dGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4OWYpIHtcblx0XHRcdFx0XHRcdC8vIE5vdGUgb25cblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ05vdGUgb24nO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLmNoYW5uZWwgPSB0aGlzLmxhc3RTdGF0dXMgLSAweDkwICsgMTtcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5ub3RlTnVtYmVyID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLm5vdGVOYW1lID0gQ29uc3RhbnRzLk5PVEVTW3RoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAxXV07XG5cdFx0XHRcdFx0XHRldmVudEpzb24udmVsb2NpdHkgPSBNYXRoLnJvdW5kKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAyXSAvIDEyNyAqIDEwMCk7XG5cdFx0XHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPD0gMHhhZikge1xuXHRcdFx0XHRcdFx0Ly8gUG9seXBob25pYyBLZXkgUHJlc3N1cmVcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1BvbHlwaG9uaWMgS2V5IFByZXNzdXJlJztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHhhMCArIDE7XG5cdFx0XHRcdFx0XHRldmVudEpzb24ubm90ZSA9IENvbnN0YW50cy5OT1RFU1t0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV1dO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLnByZXNzdXJlID0gZXZlbnRbMl07XG5cdFx0XHRcdFx0XHR0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleF0gPD0gMHhiZikge1xuXHRcdFx0XHRcdFx0Ly8gQ29udHJvbGxlciBDaGFuZ2Vcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ0NvbnRyb2xsZXIgQ2hhbmdlJztcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHhiMCArIDE7XG5cdFx0XHRcdFx0XHRldmVudEpzb24ubnVtYmVyID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLnZhbHVlID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDJdO1xuXHRcdFx0XHRcdFx0dGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4Y2YpIHtcblx0XHRcdFx0XHRcdC8vIFByb2dyYW0gQ2hhbmdlXG5cdFx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdQcm9ncmFtIENoYW5nZSc7XG5cdFx0XHRcdFx0XHRldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4YzAgKyAxO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLnZhbHVlID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdO1xuXHRcdFx0XHRcdFx0dGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4ZGYpIHtcblx0XHRcdFx0XHRcdC8vIENoYW5uZWwgS2V5IFByZXNzdXJlXG5cdFx0XHRcdFx0XHRldmVudEpzb24ubmFtZSA9ICdDaGFubmVsIEtleSBQcmVzc3VyZSc7XG5cdFx0XHRcdFx0XHRldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4ZDAgKyAxO1xuXHRcdFx0XHRcdFx0dGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4ZWYpIHtcblx0XHRcdFx0XHRcdC8vIFBpdGNoIEJlbmRcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1BpdGNoIEJlbmQnO1xuXHRcdFx0XHRcdFx0ZXZlbnRKc29uLmNoYW5uZWwgPSB0aGlzLmxhc3RTdGF0dXMgLSAweGUwICsgMTtcblx0XHRcdFx0XHRcdHRoaXMucG9pbnRlciArPSBkZWx0YUJ5dGVDb3VudCArIDM7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGV2ZW50SnNvbi5uYW1lID0gJ1Vua25vd24uICBQb2ludGVyOiAnICsgdGhpcy5wb2ludGVyLnRvU3RyaW5nKCkgKyAnICcgKyBldmVudFN0YXJ0SW5kZXgudG9TdHJpbmcoKSArICcgJyArIHRoaXMuZGF0YS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZGVsdGEgKz0gZXZlbnRKc29uLmRlbHRhO1xuXHRcdFx0dGhpcy5ldmVudHMucHVzaChldmVudEpzb24pO1xuXG5cdFx0XHRyZXR1cm4gZXZlbnRKc29uO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgcG9pbnRlciBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSB0cmFjay5cbiAgICogQHBhcmFtIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiBcImVuZE9mVHJhY2tcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW5kT2ZUcmFjaygpIHtcblx0XHRcdGlmICh0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgMV0gPT0gMHhmZiAmJiB0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgMl0gPT0gMHgyZiAmJiB0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgM10gPT0gMHgwMCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBUcmFjaztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMuVHJhY2sgPSBUcmFjaztcblxufSx7XCIuL2NvbnN0YW50c1wiOjQsXCIuL3V0aWxzXCI6OH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIENvbnRhaW5zIG1pc2Mgc3RhdGljIHV0aWxpdHkgbWV0aG9kcy5cbiAqL1xudmFyIFV0aWxzID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBVdGlscygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXRpbHMpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFV0aWxzLCBudWxsLCBbe1xuXHRcdGtleTogJ2J5dGVUb0hleCcsXG5cblxuXHRcdC8qKlxuICAgKiBDb252ZXJ0cyBhIHNpbmdsZSBieXRlIHRvIGEgaGV4IHN0cmluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gYnl0ZVRvSGV4KGJ5dGUpIHtcblx0XHRcdC8vIEVuc3VyZSBoZXggc3RyaW5nIGFsd2F5cyBoYXMgdHdvIGNoYXJzXG5cdFx0XHRyZXR1cm4gKCcwJyArIGJ5dGUudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGJ5dGVzIHRvIGEgaGV4IHN0cmluZy5cbiAgICogQHBhcmFtIHthcnJheX0gYnl0ZUFycmF5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2J5dGVzVG9IZXgnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVBcnJheSkge1xuXHRcdFx0dmFyIGhleCA9IFtdO1xuXHRcdFx0Ynl0ZUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGJ5dGUpIHtcblx0XHRcdFx0cmV0dXJuIGhleC5wdXNoKFV0aWxzLmJ5dGVUb0hleChieXRlKSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBoZXguam9pbignJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIG51bWJlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoZXhUb051bWJlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleFN0cmluZykge1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KGhleFN0cmluZywgMTYpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBieXRlcyB0byBhIG51bWJlci5cbiAgICogQHBhcmFtIHthcnJheX0gYnl0ZUFycmF5XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2J5dGVzVG9OdW1iZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVBcnJheSkge1xuXHRcdFx0cmV0dXJuIFV0aWxzLmhleFRvTnVtYmVyKFV0aWxzLmJ5dGVzVG9IZXgoYnl0ZUFycmF5KSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGJ5dGVzIHRvIGxldHRlcnMuXG4gICAqIEBwYXJhbSB7YXJyYXl9IGJ5dGVBcnJheVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdieXRlc1RvTGV0dGVycycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGJ5dGVzVG9MZXR0ZXJzKGJ5dGVBcnJheSkge1xuXHRcdFx0dmFyIGxldHRlcnMgPSBbXTtcblx0XHRcdGJ5dGVBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChieXRlKSB7XG5cdFx0XHRcdHJldHVybiBsZXR0ZXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBsZXR0ZXJzLmpvaW4oJycpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gaXQncyBiaW5hcnkgcmVwcmVzZW50YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGVjVG9CaW5hcnknLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkZWNUb0JpbmFyeShkZWMpIHtcblx0XHRcdHJldHVybiAoZGVjID4+PiAwKS50b1N0cmluZygyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVhZHMgYSB2YXJpYWJsZSBsZW5ndGggdmFsdWUuXG4gICAqIEBwYXJhbSB7YXJyYXl9IGJ5dGVBcnJheVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZWFkVmFySW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVhZFZhckludChieXRlQXJyYXkpIHtcblx0XHRcdHZhciByZXN1bHQgPSAwO1xuXHRcdFx0Ynl0ZUFycmF5LmZvckVhY2goZnVuY3Rpb24gKG51bWJlcikge1xuXHRcdFx0XHR2YXIgYiA9IG51bWJlcjtcblx0XHRcdFx0aWYgKGIgJiAweDgwKSB7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IGIgJiAweDdmO1xuXHRcdFx0XHRcdHJlc3VsdCA8PD0gNztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBiIGlzIHRoZSBsYXN0IGJ5dGUgKi9cblx0XHRcdFx0XHRyZXN1bHQgKz0gYjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIERlY29kZXMgYmFzZS02NCBlbmNvZGVkIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2F0b2InLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoX2F0b2IpIHtcblx0XHRcdGZ1bmN0aW9uIGF0b2IoX3gpIHtcblx0XHRcdFx0cmV0dXJuIF9hdG9iLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdGF0b2IudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfYXRvYi50b1N0cmluZygpO1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIGF0b2I7XG5cdFx0fShmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0XHRpZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHJldHVybiBhdG9iKHN0cmluZyk7XG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlcihzdHJpbmcsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7XG5cdFx0fSlcblx0fV0pO1xuXG5cdHJldHVybiBVdGlscztcbn0oKTtcblxuZXhwb3J0cy5VdGlscyA9IFV0aWxzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG5cbn0se1wiYnVmZmVyXCI6Mn1dfSx7fSxbNV0pKDUpXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlMWEJoWTJzdlgzQnlaV3gxWkdVdWFuTWlMQ0p1YjJSbFgyMXZaSFZzWlhNdlltRnpaVFkwTFdwekwybHVaR1Y0TG1weklpd2libTlrWlY5dGIyUjFiR1Z6TDJKMVptWmxjaTlwYm1SbGVDNXFjeUlzSW01dlpHVmZiVzlrZFd4bGN5OXBaV1ZsTnpVMEwybHVaR1Y0TG1weklpd2ljM0pqTDJOdmJuTjBZVzUwY3k1cWN5SXNJbk55WXk5cGJtUmxlQzVxY3lJc0luTnlZeTl3YkdGNVpYSXVhbk1pTENKemNtTXZkSEpoWTJzdWFuTWlMQ0p6Y21NdmRYUnBiSE11YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRTdRVU5CUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVU5zU0VFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVU5zY2tSQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN08wRkRjRVpCT3pzN1FVRkhRU3hKUVVGSkxGbEJRVms3UVVGRFppeFZRVUZUTEU5QlJFMDdRVUZGWml4UlFVRlBMRVZCUmxFN1FVRkhaaXh2UWtGQmJVSXNRMEZCUXl4SFFVRkVMRVZCUVUwc1IwRkJUaXhGUVVGWExFbEJRVmdzUlVGQmFVSXNTVUZCYWtJc1JVRkJkVUlzU1VGQmRrSXNSVUZCTmtJc1NVRkJOMElzUlVGQmJVTXNTVUZCYmtNc1JVRkJlVU1zU1VGQmVrTXNSVUZCSzBNc1NVRkJMME1zUlVGQmNVUXNTMEZCY2tRc1JVRkJORVFzUzBGQk5VUXNSVUZCYlVVc1MwRkJia1VzUTBGSVNqdEJRVWxtTEcxQ1FVRnJRaXhEUVVGRExFZEJRVVFzUlVGQlRTeEhRVUZPTEVWQlFWY3NSMEZCV0N4RlFVRm5RaXhIUVVGb1FpeEZRVUZ4UWl4SFFVRnlRaXhGUVVFd1FpeEhRVUV4UWl4RlFVRXJRaXhKUVVFdlFpeEZRVUZ4UXl4SlFVRnlReXhGUVVFeVF5eEpRVUV6UXl4RlFVRnBSQ3hKUVVGcVJDeEZRVUYxUkN4SlFVRjJSQ3hGUVVFMlJDeEpRVUUzUkR0QlFVcElMRU5CUVdoQ096dEJRVTlCTzBGQlEwRXNTVUZCU1N4WFFVRlhMRU5CUVVNc1EwRkJReXhIUVVGRUxFTkJRVVFzUlVGQlVTeERRVUZETEVsQlFVUXNSVUZCVFN4SlFVRk9MRU5CUVZJc1JVRkJjVUlzUTBGQlF5eEhRVUZFTEVOQlFYSkNMRVZCUVRSQ0xFTkJRVU1zU1VGQlJDeEZRVUZOTEVsQlFVNHNRMEZCTlVJc1JVRkJlVU1zUTBGQlF5eEhRVUZFTEVOQlFYcERMRVZCUVN0RExFTkJRVU1zUjBGQlJDeERRVUV2UXl4RlFVRnpSQ3hEUVVGRExFbEJRVVFzUlVGQlRTeEpRVUZPTEVOQlFYUkVMRVZCUVcxRkxFTkJRVU1zUjBGQlJDeERRVUZ1UlN4RlFVRXdSU3hEUVVGRExFbEJRVVFzUlVGQlRTeEpRVUZPTEVOQlFURkZMRVZCUVhWR0xFTkJRVU1zUjBGQlJDeERRVUYyUml4RlFVRTRSaXhEUVVGRExFbEJRVVFzUlVGQlRTeEpRVUZPTEVOQlFUbEdMRVZCUVRKSExFTkJRVU1zUjBGQlJDeERRVUV6Unl4RFFVRm1PMEZCUTBFc1NVRkJTU3hWUVVGVkxFTkJRV1E3TzBGQlJVRTdPekpDUVVOVExFTTdRVUZEVWl4VlFVRlRMRTlCUVZRc1EwRkJhVUlzY1VKQlFXRTdRVUZETjBJc1dVRkJWU3hQUVVGV0xFTkJRV3RDTzBGQlFVRXNWVUZCVVN4VlFVRlZMRXRCUVZZc1EwRkJaMElzVDBGQmFFSXNTVUZCTWtJc1QwRkJUeXhEUVVFeFF6dEJRVUZCTEVkQlFXeENPMEZCUTBFN1FVRkRRU3hGUVVoRU96czdRVUZFUkN4TFFVRkxMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRV1FzUlVGQmFVSXNTMEZCU3l4RFFVRjBRaXhGUVVGNVFpeEhRVUY2UWl4RlFVRTRRanRCUVVGQkxFOUJRWEpDTEVOQlFYRkNPMEZCU3pkQ096dEJRVVZFTEZGQlFWRXNVMEZCVWl4SFFVRnZRaXhUUVVGd1FqczdPenM3UVVOMFFrRXNTVUZCVFN4VFFVRlRMRkZCUVZFc1ZVRkJVaXhEUVVGbU8wRkJRMEVzU1VGQlRTeFJRVUZSTEZGQlFWRXNVMEZCVWl4RFFVRmtPMEZCUTBFc1NVRkJUU3haUVVGWkxGRkJRVkVzWVVGQlVpeERRVUZzUWpzN1FVRkZRU3hQUVVGUExFOUJRVkFzUjBGQmFVSTdRVUZEWWl4WlFVRlBMRTlCUVU4c1RVRkVSRHRCUVVWaUxGZEJRVTBzVFVGQlRTeExRVVpETzBGQlIySXNaVUZCVlN4VlFVRlZPMEZCU0ZBc1EwRkJha0k3T3pzN096czdPenM3TzBGRFNrRXNTVUZCVFN4UlFVRlJMRkZCUVZFc1UwRkJVaXhGUVVGdFFpeExRVUZxUXp0QlFVTkJMRWxCUVUwc1VVRkJVU3hSUVVGUkxGTkJRVklzUlVGQmJVSXNTMEZCYWtNN08wRkJSVUU3UVVGRFFTeEpRVUZKTEVOQlFVTXNWMEZCVnl4VFFVRllMRU5CUVhGQ0xFOUJRVEZDTEVWQlFXMURPMEZCUTJ4RExGRkJRVThzWTBGQlVDeERRVUZ6UWl4WFFVRlhMRk5CUVdwRExFVkJRVFJETEZOQlFUVkRMRVZCUVhWRU8wRkJRM1JFTEZOQlFVOHNUVUZCVFN4VFFVRk9MRU5CUVdkQ08wRkJSQ3RDTEVWQlFYWkVPMEZCUjBFN08wRkJSVVE3T3pzN096dEpRVXROTEUwN1FVRkRUQ3hwUWtGQldTeFpRVUZhTEVWQlFUQkNMRTFCUVRGQ0xFVkJRV3RETzBGQlFVRTdPMEZCUTJwRExFOUJRVXNzVlVGQlRDeEhRVUZyUWl4RFFVRnNRaXhEUVVScFF5eERRVU5hTzBGQlEzSkNMRTlCUVVzc1UwRkJUQ3hIUVVGcFFpeERRVUZxUWp0QlFVTkJMRTlCUVVzc1RVRkJUQ3hIUVVGakxGVkJRVlVzU1VGQmVFSTdRVUZEUVN4UFFVRkxMRkZCUVV3N1FVRkRRU3hQUVVGTExFMUJRVXc3UVVGRFFTeFBRVUZMTEdGQlFVd3NSMEZCY1VJc1MwRkJja0k3UVVGRFFTeFBRVUZMTEUxQlFVd3NSMEZCWXl4RlFVRmtPMEZCUTBFc1QwRkJTeXhYUVVGTUxFZEJRVzFDTEVWQlFXNUNPMEZCUTBFc1QwRkJTeXhaUVVGTUxFZEJRVzlDTEVkQlFYQkNPMEZCUTBFc1QwRkJTeXhMUVVGTUxFZEJRV0VzU1VGQllqdEJRVU5CTEU5QlFVc3NVMEZCVEN4SFFVRnBRaXhEUVVGcVFqdEJRVU5CTEU5QlFVc3NTVUZCVEN4SFFVRlpMRU5CUVZvN1FVRkRRU3hQUVVGTExGRkJRVXdzUjBGQlowSXNTVUZCYUVJN1FVRkRRU3hQUVVGTExFMUJRVXdzUjBGQll5eExRVUZrTzBGQlEwRXNUMEZCU3l4VlFVRk1MRWRCUVd0Q0xFTkJRV3hDTzBGQlEwRXNUMEZCU3l4TlFVRk1MRWRCUVdNc1JVRkJaRHRCUVVOQkxFOUJRVXNzVjBGQlRDeEhRVUZ0UWl4RFFVRnVRanRCUVVOQkxFOUJRVXNzWTBGQlRDeEhRVUZ6UWl4RlFVRjBRanM3UVVGRlFTeE5RVUZKTEU5QlFVOHNXVUZCVUN4TFFVRjVRaXhWUVVFM1FpeEZRVUY1UXl4TFFVRkxMRVZCUVV3c1EwRkJVU3hYUVVGU0xFVkJRWEZDTEZsQlFYSkNPMEZCUTNwRE96dEJRVVZFT3pzN096czdPenM3TWtKQlMxTXNTU3hGUVVGTk8wRkJRMlFzVDBGQlNTeExRVUZMTEZGQlFWRXNTVUZCVWl4RFFVRlVPMEZCUTBFc1VVRkJTeXhOUVVGTUxFZEJRV01zUjBGQlJ5eFpRVUZJTEVOQlFXZENMRWxCUVdoQ0xFTkJRV1E3UVVGRFFTeFZRVUZQTEV0QlFVc3NWVUZCVEN4RlFVRlFPMEZCUTBFN08wRkJSVVE3T3pzN096czdPMnREUVV0blFpeFhMRVZCUVdFN1FVRkROVUlzVVVGQlN5eE5RVUZNTEVkQlFXTXNTVUZCU1N4VlFVRktMRU5CUVdVc1YwRkJaaXhEUVVGa08wRkJRMEVzVlVGQlR5eExRVUZMTEZWQlFVd3NSVUZCVUR0QlFVTkJPenRCUVVWRU96czdPenM3T3pzNFFrRkxXU3hQTEVWQlFWTTdRVUZEY0VJN1FVRkRRVHRCUVVOQkxFOUJRVWtzWVVGQllTeE5RVUZOTEVsQlFVNHNRMEZCVnl4UlFVRlJMRXRCUVZJc1EwRkJZeXhIUVVGa0xFVkJRVzFDTEVOQlFXNUNMRU5CUVZnc1EwRkJha0k3TzBGQlJVRTdRVUZEUVN4UFFVRkpMRXRCUVVzc1NVRkJTU3hWUVVGS0xFTkJRV1VzVjBGQlZ5eE5RVUV4UWl4RFFVRlVPMEZCUTBFc1VVRkJTeXhKUVVGSkxFbEJRVWtzUTBGQllpeEZRVUZuUWl4SlFVRkpMRmRCUVZjc1RVRkJMMElzUlVGQmRVTXNSMEZCZGtNc1JVRkJORU03UVVGRE0wTXNUMEZCUnl4RFFVRklMRWxCUVZFc1YwRkJWeXhWUVVGWUxFTkJRWE5DTEVOQlFYUkNMRU5CUVZJN1FVRkRRVHM3UVVGRlJDeFJRVUZMTEUxQlFVd3NSMEZCWXl4RlFVRmtPMEZCUTBFc1ZVRkJUeXhMUVVGTExGVkJRVXdzUlVGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN08yZERRVWxqTzBGQlEySXNWVUZCVHl4TFFVRkxMRTFCUVV3c1IwRkJZeXhMUVVGTExFMUJRVXdzUTBGQldTeE5RVUV4UWl4SFFVRnRReXhEUVVFeFF6dEJRVU5CT3p0QlFVVkVPenM3T3pzN096c3JRa0ZMWVR0QlFVTmFMRTlCUVVrc1EwRkJReXhMUVVGTExGRkJRVXdzUlVGQlRDeEZRVUZ6UWl4TlFVRk5MREpEUVVGT08wRkJRM1JDTEZWQlFVOHNTMEZCU3l4UlFVRk1MRU5CUVdNc1MwRkJTeXhaUVVGdVFpeEZRVUZwUXl4WFFVRnFReXhIUVVFclF5eFRRVUV2UXl4SFFVRXlSQ3hUUVVFelJDeEhRVUYxUlN4TlFVRjJSU3hGUVVGUU8wRkJRMEU3TzBGQlJVUTdPenM3T3pzN05rSkJTVmM3UVVGRFZpeFZRVUZQTEUxQlFVMHNZMEZCVGl4RFFVRnhRaXhMUVVGTExFMUJRVXdzUTBGQldTeFJRVUZhTEVOQlFYRkNMRU5CUVhKQ0xFVkJRWGRDTEVOQlFYaENMRU5CUVhKQ0xFMUJRWEZFTEUxQlFUVkVPMEZCUTBFN08wRkJSVVE3T3pzN096czdPRUpCU1ZrN1FVRkRXRHM3T3pzN096czdPenRCUVZWQkxGRkJRVXNzVFVGQlRDeEhRVUZqTEUxQlFVMHNZVUZCVGl4RFFVRnZRaXhMUVVGTExFMUJRVXdzUTBGQldTeFJRVUZhTEVOQlFYRkNMRU5CUVhKQ0xFVkJRWGRDTEVWQlFYaENMRU5CUVhCQ0xFTkJRV1E3UVVGRFFTeFZRVUZQTEVsQlFWQTdRVUZEUVRzN1FVRkZSRHM3T3pzN096czRRa0ZKV1R0QlFVTllMRkZCUVVzc1RVRkJUQ3hIUVVGakxFVkJRV1E3UVVGRFFTeFBRVUZKTEdOQlFXTXNRMEZCYkVJN1FVRkRRU3hWUVVGUExHTkJRV01zUzBGQlN5eE5RVUZNTEVOQlFWa3NUVUZCYWtNc1JVRkJlVU03UVVGRGVFTXNVVUZCU1N4TlFVRk5MR05CUVU0c1EwRkJjVUlzUzBGQlN5eE5RVUZNTEVOQlFWa3NVVUZCV2l4RFFVRnhRaXhYUVVGeVFpeEZRVUZyUXl4alFVRmpMRU5CUVdoRUxFTkJRWEpDTEV0QlFUUkZMRTFCUVdoR0xFVkJRWGRHTzBGQlEzWkdMRk5CUVVrc1kwRkJZeXhOUVVGTkxHRkJRVTRzUTBGQmIwSXNTMEZCU3l4TlFVRk1MRU5CUVZrc1VVRkJXaXhEUVVGeFFpeGpRVUZqTEVOQlFXNURMRVZCUVhORExHTkJRV01zUTBGQmNFUXNRMEZCY0VJc1EwRkJiRUk3UVVGRFFTeFZRVUZMTEUxQlFVd3NRMEZCV1N4SlFVRmFMRU5CUVdsQ0xFbEJRVWtzUzBGQlNpeERRVUZWTEV0QlFVc3NUVUZCVEN4RFFVRlpMRTFCUVhSQ0xFVkJRVGhDTEV0QlFVc3NUVUZCVEN4RFFVRlpMRkZCUVZvc1EwRkJjVUlzWTBGQll5eERRVUZ1UXl4RlFVRnpReXhqUVVGakxFTkJRV1FzUjBGQmEwSXNWMEZCZUVRc1EwRkJPVUlzUTBGQmFrSTdRVUZEUVRzN1FVRkZSQ3h0UWtGQlpTeE5RVUZOTEdGQlFVNHNRMEZCYjBJc1MwRkJTeXhOUVVGTUxFTkJRVmtzVVVGQldpeERRVUZ4UWl4alFVRmpMRU5CUVc1RExFVkJRWE5ETEdOQlFXTXNRMEZCY0VRc1EwRkJjRUlzU1VGQk9FVXNRMEZCTjBZN1FVRkRRVHRCUVVORUxGVkJRVThzU1VGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN096czRRa0ZMV1N4WExFVkJRV0U3UVVGRGVFSXNVVUZCU3l4TlFVRk1MRU5CUVZrc1kwRkJZeXhEUVVFeFFpeEZRVUUyUWl4TlFVRTNRanRCUVVOQkxGVkJRVThzU1VGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN096c3JRa0ZMWVN4WExFVkJRV0U3UVVGRGVrSXNVVUZCU3l4TlFVRk1MRU5CUVZrc1kwRkJZeXhEUVVFeFFpeEZRVUUyUWl4UFFVRTNRanRCUVVOQkxGVkJRVThzU1VGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN08yZERRVWxqTzBGQlEySXNVVUZCU3l4UlFVRk1MRWRCUVdkQ0xFMUJRVTBzWVVGQlRpeERRVUZ2UWl4TFFVRkxMRTFCUVV3c1EwRkJXU3hSUVVGYUxFTkJRWEZDTEVWQlFYSkNMRVZCUVhsQ0xFVkJRWHBDTEVOQlFYQkNMRU5CUVdoQ08wRkJRMEVzVlVGQlR5eEpRVUZRTzBGQlEwRTdPMEZCUlVRN096czdPenM3T3pKQ1FVdFRMRTBzUlVGQlVUdEJRVU5vUWl4UFFVRkpMRU5CUVVNc1MwRkJTeXhOUVVGV0xFVkJRV3RDTzBGQlEycENMRk5CUVVzc1RVRkJUQ3hIUVVGakxFbEJRV1E3UVVGRFFTeFRRVUZMTEVsQlFVd3NSMEZCV1N4TFFVRkxMR05CUVV3c1JVRkJXanM3UVVGRlFTeFRRVUZMTEUxQlFVd3NRMEZCV1N4UFFVRmFMRU5CUVc5Q0xGVkJRVk1zUzBGQlZDeEZRVUZuUWp0QlFVTnVRenRCUVVOQkxGTkJRVWtzUTBGQlF5eE5RVUZFTEVsQlFWY3NTMEZCU3l4VFFVRk1MRVZCUVdZc1JVRkJhVU03UVVGRGFFTTdRVUZEUVN4WFFVRkxMR3RDUVVGTUxFTkJRWGRDTEZkQlFYaENPMEZCUTBFc1YwRkJTeXhKUVVGTU8wRkJRMEVzVFVGS1JDeE5RVWxQTzBGQlEwNHNWVUZCU1N4UlFVRlJMRTFCUVUwc1YwRkJUaXhEUVVGclFpeExRVUZMTEVsQlFYWkNMRVZCUVRaQ0xFMUJRVGRDTEVOQlFWbzdPMEZCUlVFc1ZVRkJTU3hWUVVGVkxFdEJRV1FzUlVGQmNVSTdRVUZEY0VJc1YwRkJTU3hOUVVGTkxHTkJRVTRzUTBGQmNVSXNUVUZCY2tJc1MwRkJaME1zVFVGQlRTeEpRVUZPTEV0QlFXVXNWMEZCYmtRc1JVRkJaMFU3UVVGREwwUTdRVUZEUVN4aFFVRkxMRmxCUVV3c1IwRkJiMElzVFVGQlRTeEpRVUV4UWp0QlFVTkJMR0ZCUVVzc1VVRkJUQ3hEUVVGakxFMUJRVTBzU1VGQmNFSTdRVUZEUVR0QlFVTkVMRmRCUVVrc1RVRkJUU3hqUVVGT0xFTkJRWEZDTEUxQlFYSkNMRXRCUVdkRExFMUJRVTBzU1VGQlRpeExRVUZsTEdkQ1FVRnVSQ3hGUVVGeFJUdEJRVU53UlN4WlFVRkpMRU5CUVVNc1MwRkJTeXhYUVVGTUxFTkJRV2xDTEZGQlFXcENMRU5CUVRCQ0xFMUJRVTBzUzBGQmFFTXNRMEZCVEN4RlFVRTJRenRCUVVNMVF5eGpRVUZMTEZkQlFVd3NRMEZCYVVJc1NVRkJha0lzUTBGQmMwSXNUVUZCVFN4TFFVRTFRanRCUVVOQk8wRkJRMFE3UVVGRFJDeFBRVmhFTEUxQlYwOHNTVUZCU1N4TFFVRktMRVZCUVZjc1MwRkJTeXhUUVVGTUxFTkJRV1VzUzBGQlpqdEJRVU5zUWp0QlFVVkVMRXRCZGtKRUxFVkJkVUpITEVsQmRrSklPenRCUVhsQ1FTeFJRVUZKTEVOQlFVTXNUVUZCVEN4RlFVRmhMRXRCUVVzc2EwSkJRVXdzUTBGQmQwSXNVMEZCZUVJc1JVRkJiVU1zUlVGQlF5eE5RVUZOTEV0QlFVc3NTVUZCV2l4RlFVRnVRenRCUVVOaUxGTkJRVXNzVFVGQlRDeEhRVUZqTEV0QlFXUTdRVUZEUVR0QlFVTkVPenRCUVVWRU96czdPenM3T3pKQ1FVbFRMRXNzUlVGQlR6dEJRVU5tTEZGQlFVc3NTMEZCVEN4SFFVRmhMRXRCUVdJN1FVRkRRU3hWUVVGUExFbEJRVkE3UVVGRFFUczdRVUZGUkRzN096czdPenNyUWtGSllTeFRMRVZCUVZjN1FVRkRka0lzVVVGQlN5eFRRVUZNTEVkQlFXbENMRk5CUVdwQ08wRkJRMEU3TzBGQlJVUTdPenM3T3pzN2VVSkJTVTg3UVVGRFRpeFBRVUZKTEV0QlFVc3NVMEZCVEN4RlFVRktMRVZCUVhOQ0xFMUJRVTBzYjBKQlFVNDdPMEZCUlhSQ08wRkJRMEVzVDBGQlNTeERRVUZETEV0QlFVc3NVMEZCVml4RlFVRnhRaXhMUVVGTExGTkJRVXdzUjBGQmEwSXNTVUZCU1N4SlFVRktMRVZCUVVRc1EwRkJZU3hQUVVGaUxFVkJRV3BDT3p0QlFVVnlRanRCUVVOQk8wRkJRMEVzVVVGQlN5eGhRVUZNTEVkQlFYRkNMRmxCUVZrc1MwRkJTeXhSUVVGTUxFTkJRV01zU1VGQlpDeERRVUZ0UWl4SlFVRnVRaXhEUVVGYUxFVkJRWE5ETEV0QlFVc3NWVUZCTTBNc1EwRkJja0k3TzBGQlJVRXNWVUZCVHl4SlFVRlFPMEZCUTBFN08wRkJSVVE3T3pzN096czdNRUpCU1ZFN1FVRkRVQ3hwUWtGQll5eExRVUZMTEdGQlFXNUNPMEZCUTBFc1VVRkJTeXhoUVVGTUxFZEJRWEZDTEV0QlFYSkNPMEZCUTBFc1VVRkJTeXhUUVVGTUxFZEJRV2xDTEV0QlFVc3NTVUZCZEVJN1FVRkRRU3hSUVVGTExGTkJRVXdzUjBGQmFVSXNRMEZCYWtJN1FVRkRRU3hWUVVGUExFbEJRVkE3UVVGRFFUczdRVUZGUkRzN096czdPenQ1UWtGSlR6dEJRVU5PTEdsQ1FVRmpMRXRCUVVzc1lVRkJia0k3UVVGRFFTeFJRVUZMTEdGQlFVd3NSMEZCY1VJc1MwRkJja0k3UVVGRFFTeFJRVUZMTEZOQlFVd3NSMEZCYVVJc1EwRkJha0k3UVVGRFFTeFJRVUZMTEZOQlFVd3NSMEZCYVVJc1EwRkJha0k3UVVGRFFTeFJRVUZMTEZkQlFVdzdRVUZEUVN4VlFVRlBMRWxCUVZBN1FVRkRRVHM3UVVGRlJEczdPenM3T3pzN05rSkJTMWNzU1N4RlFVRk5PMEZCUTJoQ0xGRkJRVXNzU1VGQlREdEJRVU5CTEZGQlFVc3NVMEZCVEN4SFFVRnBRaXhKUVVGcVFqczdRVUZGUVR0QlFVTkJMRkZCUVVzc1RVRkJUQ3hEUVVGWkxFOUJRVm9zUTBGQmIwSXNWVUZCVXl4TFFVRlVMRVZCUVdkQ08wRkJRMjVETEZWQlFVMHNiVUpCUVU0c1EwRkJNRUlzU1VGQk1VSTdRVUZEUVN4SlFVWkVPMEZCUjBFc1ZVRkJUeXhKUVVGUU8wRkJRMEU3TzBGQlJVUTdPenM3T3pzN08yZERRVXRqTEU4c1JVRkJVenRCUVVOMFFpeFBRVUZKTEZWQlFWVXNRMEZCVml4SlFVRmxMRlZCUVZVc1IwRkJOMElzUlVGQmEwTXNUVUZCVFN3eVEwRkJUanRCUVVOc1F5eFJRVUZMTEZWQlFVd3NRMEZCWjBJc1MwRkJTeXhMUVVGTUxFTkJRVmNzVlVGQlZTeEhRVUZXTEVkQlFXZENMRXRCUVVzc1ZVRkJhRU1zUTBGQmFFSTdRVUZEUVN4VlFVRlBMRWxCUVZBN1FVRkRRVHM3UVVGRlJEczdPenM3T3pzN1owTkJTMk1zVHl4RlFVRlRPMEZCUTNSQ0xFOUJRVWtzVjBGQlZ5eExRVUZMTEZkQlFVd3NSVUZCWmp0QlFVTkJMRTlCUVVrc1ZVRkJWU3hEUVVGV0xFbEJRV1VzVlVGQlZTeFJRVUUzUWl4RlFVRjFReXhOUVVGTkxGVkJRVlVzYlVOQlFWWXNSMEZCWjBRc1VVRkJkRVE3UVVGRGRrTXNVVUZCU3l4aFFVRk1MRU5CUVcxQ0xGVkJRVlVzVVVGQlZpeEhRVUZ4UWl4SFFVRjRRenRCUVVOQkxGVkJRVThzU1VGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN096aENRVWxaTzBGQlExZ3NWVUZCVHl4TFFVRkxMR0ZCUVV3c1IwRkJjVUlzUTBGQmNrSXNTVUZCTUVJc1VVRkJUeXhMUVVGTExHRkJRVm9zVFVGQk9FSXNVVUZCTDBRN1FVRkRRVHM3UVVGRlJEczdPenM3T3pzeVFrRkpVenRCUVVOU08wRkJRMEVzVVVGQlN5eFhRVUZNTzBGQlEwRXNWVUZCVHl4RFFVRkRMRXRCUVVzc1UwRkJUQ3hGUVVGU08wRkJRVEJDTEZOQlFVc3NVVUZCVEN4RFFVRmpMRWxCUVdRN1FVRkJNVUlzU1VGRFFTeExRVUZMTEUxQlFVd3NSMEZCWXl4TFFVRkxMRk5CUVV3c1JVRkJaRHRCUVVOQkxGRkJRVXNzVjBGQlRDeEhRVUZ0UWl4TFFVRkxMR05CUVV3c1JVRkJia0k3UVVGRFFTeFJRVUZMTEZWQlFVd3NSMEZCYTBJc1MwRkJTeXhoUVVGTUxFVkJRV3hDTzBGQlEwRXNVVUZCU3l4VFFVRk1MRWRCUVdsQ0xFTkJRV3BDTzBGQlEwRXNVVUZCU3l4VFFVRk1MRWRCUVdsQ0xFTkJRV3BDT3p0QlFVVkJPMEZCUTBFc1VVRkJTeXhYUVVGTU96dEJRVVZCT3p0QlFVVkJMRkZCUVVzc2EwSkJRVXdzUTBGQmQwSXNXVUZCZUVJc1JVRkJjME1zU1VGQmRFTTdRVUZEUVN4VlFVRlBMRWxCUVZBN1FVRkRRVHM3UVVGRlJEczdPenM3T3p0blEwRkpZenRCUVVOaUxGRkJRVXNzVFVGQlRDeERRVUZaTEU5QlFWb3NRMEZCYjBJN1FVRkJRU3hYUVVGVExFMUJRVTBzUzBGQlRpeEZRVUZVTzBGQlFVRXNTVUZCY0VJN1FVRkRRU3hWUVVGUExFbEJRVkE3UVVGRFFUczdRVUZGUkRzN096czdPenM0UWtGSldUdEJRVU5ZTEZWQlFVOHNTMEZCU3l4TlFVRk1MRU5CUVZrc1IwRkJXaXhEUVVGblFqdEJRVUZCTEZkQlFWTXNUVUZCVFN4TlFVRm1PMEZCUVVFc1NVRkJhRUlzUTBGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN08ydERRVWxuUWp0QlFVTm1MRlZCUVU4c1MwRkJTeXhIUVVGTUxFTkJRVk1zUzBGQlZDeERRVUZsTEVsQlFXWXNSVUZCY1VJc1MwRkJTeXhOUVVGTUxFTkJRVmtzUjBGQldpeERRVUZuUWp0QlFVRkJMRmRCUVZNc1RVRkJUU3hMUVVGbU8wRkJRVUVzU1VGQmFFSXNRMEZCY2tJc1EwRkJVRHRCUVVOQk96dEJRVVZFT3pzN096czdPMjFEUVVscFFqdEJRVU5vUWl4VlFVRlBMRXRCUVVzc1RVRkJUQ3hEUVVGWkxFMUJRVm9zUTBGQmJVSXNWVUZCUXl4RFFVRkVMRVZCUVVrc1EwRkJTaXhGUVVGVk8wRkJRVU1zVjBGQlR5eEZRVUZETEZGQlFWRXNSVUZCUXl4UlFVRlJMRVZCUVVVc1RVRkJSaXhEUVVGVExFMUJRVlFzUjBGQmEwSXNSVUZCUlN4TlFVRkdMRU5CUVZNc1RVRkJjRU1zUlVGQlZDeEZRVUZRTzBGQlFUWkVMRWxCUVROR0xFVkJRVFpHTEVWQlFVTXNVVUZCVVN4RlFVRkRMRkZCUVZFc1EwRkJWQ3hGUVVGVUxFVkJRVGRHTEVWQlFXOUlMRTFCUVhCSUxFTkJRVEpJTEUxQlFXeEpPMEZCUTBFN08wRkJSVVE3T3pzN096czdaME5CU1dNN1FVRkRZaXhWUVVGUExFdEJRVXNzVlVGQlRDeEhRVUZyUWl4TFFVRkxMRkZCUVhaQ0xFZEJRV3RETEV0QlFVc3NTMEZCZGtNc1IwRkJLME1zUlVGQmRFUTdRVUZEUVRzN1FVRkZSRHM3T3pzN096dDVRMEZKZFVJN1FVRkRkRUlzVlVGQlR5eExRVUZMTEV0QlFVd3NRMEZCVnl4RFFVRkRMRXRCUVVzc1ZVRkJUQ3hIUVVGclFpeExRVUZMTEdOQlFVd3NSVUZCYmtJc1NVRkJORU1zUzBGQlN5eFJRVUZxUkN4SFFVRTBSQ3hMUVVGTExFdEJRV3BGTEVkQlFYbEZMRVZCUVhCR0xFTkJRVkE3UVVGRFFUczdRVUZGUkRzN096czdPenMwUTBGSk1FSTdRVUZEZWtJc1ZVRkJUeXhMUVVGTExFdEJRVXdzUTBGQlZ5eExRVUZMTEc5Q1FVRk1MRXRCUVRoQ0xFdEJRVXNzVjBGQlRDeEZRVUU1UWl4SFFVRnRSQ3hIUVVFNVJDeERRVUZRTzBGQlEwRTdPMEZCUlVRN096czdPenM3YlVOQlNXbENPMEZCUTJoQ08wRkJRMEVzVlVGQlR5eExRVUZMTEV0QlFVc3NUVUZCVEN4RFFVRlpMRTFCUVZvc1IwRkJjVUlzUTBGQk1VSXNSMEZCT0VJc1MwRkJTeXhOUVVGTUxFTkJRVmtzVFVGQldpeERRVUZ0UWl4VlFVRkRMRU5CUVVRc1JVRkJTU3hEUVVGS0xFVkJRVlU3UVVGQlF5eFhRVUZQTEVWQlFVTXNVMEZCVXl4RlFVRkZMRTlCUVVZc1IwRkJXU3hGUVVGRkxFOUJRWGhDTEVWQlFWQTdRVUZCZDBNc1NVRkJkRVVzUlVGQmQwVXNSVUZCUXl4VFFVRlRMRU5CUVZZc1JVRkJlRVVzUlVGQmMwWXNUMEZCTTBnN1FVRkRRVHM3UVVGRlJEczdPenM3T3p0cFEwRkpaVHRCUVVOa0xGVkJRVThzUzBGQlN5eE5RVUZNTEVOQlFWa3NUVUZCV2l4RFFVRnRRaXhWUVVGRExFTkJRVVFzUlVGQlNTeERRVUZLTEVWQlFWVTdRVUZCUXl4WFFVRlBMRVZCUVVNc1dVRkJXU3hGUVVGRkxGVkJRVVlzUjBGQlpTeEZRVUZGTEZWQlFUbENMRVZCUVZBN1FVRkJhVVFzU1VGQkwwVXNSVUZCYVVZc1JVRkJReXhaUVVGWkxFTkJRV0lzUlVGQmFrWXNSVUZCYTBjc1ZVRkJla2M3UVVGRFFUczdRVUZGUkRzN096czdPenM3T3pzNFFrRlBXVHRCUVVOWUxFOUJRVWtzUzBGQlN5eFRRVUZNTEVWQlFVb3NSVUZCYzBJN1FVRkRja0lzVjBGQlR5eExRVUZMTEZWQlFVd3NSMEZCYTBJc1MwRkJTeXhKUVVGMlFpeEpRVUVyUWl4RFFVRjBRenRCUVVOQk96dEJRVVZFTEZWQlFVOHNTMEZCU3l4alFVRk1MRTFCUVhsQ0xFdEJRVXNzVFVGQlRDeERRVUZaTEUxQlFUVkRPMEZCUTBFN08wRkJSVVE3T3pzN096czdiVU5CU1dsQ08wRkJRMmhDTEU5QlFVY3NRMEZCUXl4TFFVRkxMRk5CUVU0c1NVRkJiVUlzUzBGQlN5eEpRVUV6UWl4RlFVRnBReXhQUVVGUExFdEJRVXNzVTBGQldpeERRVUZxUXl4TFFVTkxMRWxCUVVjc1EwRkJReXhMUVVGTExGTkJRVlFzUlVGQmIwSXNUMEZCVHl4RFFVRlFPMEZCUTNwQ0xGVkJRVThzUzBGQlN5eExRVUZNTEVOQlFWY3NRMEZCUlN4SlFVRkpMRWxCUVVvc1JVRkJSQ3hEUVVGaExFOUJRV0lzUzBGQmVVSXNTMEZCU3l4VFFVRXZRaXhKUVVFMFF5eEpRVUUxUXl4SlFVRnZSQ3hMUVVGTExGRkJRVXdzU1VGQmFVSXNTMEZCU3l4TFFVRk1MRWRCUVdFc1JVRkJPVUlzUTBGQmNFUXNRMEZCV0N4SlFVRnhSeXhMUVVGTExGTkJRV3BJTzBGQlEwRTdPMEZCUlVRN096czdPenM3T3pSQ1FVdFZMRXNzUlVGQlR6dEJRVU5vUWl4UlFVRkxMR3RDUVVGTUxFTkJRWGRDTEZkQlFYaENMRVZCUVhGRExFdEJRWEpETzBGQlEwRXNWVUZCVHl4SlFVRlFPMEZCUTBFN08wRkJSVVE3T3pzN096czdPenR4UWtGTlJ5eFhMRVZCUVdFc1JTeEZRVUZKTzBGQlEyNUNMRTlCUVVrc1EwRkJReXhMUVVGTExHTkJRVXdzUTBGQmIwSXNZMEZCY0VJc1EwRkJiVU1zVjBGQmJrTXNRMEZCVEN4RlFVRnpSQ3hMUVVGTExHTkJRVXdzUTBGQmIwSXNWMEZCY0VJc1NVRkJiVU1zUlVGQmJrTTdRVUZEZEVRc1VVRkJTeXhqUVVGTUxFTkJRVzlDTEZkQlFYQkNMRVZCUVdsRExFbEJRV3BETEVOQlFYTkRMRVZCUVhSRE8wRkJRMEVzVlVGQlR5eEpRVUZRTzBGQlEwRTdPMEZCUlVRN096czdPenM3T3p0eFEwRk5iVUlzVnl4RlFVRmhMRWtzUlVGQlRUdEJRVU55UXl4UFFVRkpMRXRCUVVzc1kwRkJUQ3hEUVVGdlFpeGpRVUZ3UWl4RFFVRnRReXhYUVVGdVF5eERRVUZLTEVWQlFYRkVMRXRCUVVzc1kwRkJUQ3hEUVVGdlFpeFhRVUZ3UWl4RlFVRnBReXhQUVVGcVF5eERRVUY1UXp0QlFVRkJMRmRCUVUwc1IwRkJSeXhSUVVGUkxFVkJRVmdzUTBGQlRqdEJRVUZCTEVsQlFYcERPMEZCUTNKRUxGVkJRVThzU1VGQlVEdEJRVU5CT3pzN096czdRVUZKUml4UlFVRlJMRTFCUVZJc1IwRkJhVUlzVFVGQmFrSTdPenM3T3pzN096dEJRek5rUVN4SlFVRk5MRmxCUVZrc1VVRkJVU3hoUVVGU0xFVkJRWFZDTEZOQlFYcERPMEZCUTBFc1NVRkJUU3hSUVVGUkxGRkJRVkVzVTBGQlVpeEZRVUZ0UWl4TFFVRnFRenM3UVVGRlFUczdPenRKUVVkTkxFczdRVUZEVEN4blFrRkJXU3hMUVVGYUxFVkJRVzFDTEVsQlFXNUNMRVZCUVhsQ08wRkJRVUU3TzBGQlEzaENMRTlCUVVzc1QwRkJUQ3hIUVVGbExFbEJRV1k3UVVGRFFTeFBRVUZMTEZWQlFVd3NSMEZCYTBJc1EwRkJiRUk3UVVGRFFTeFBRVUZMTEU5QlFVd3NSMEZCWlN4RFFVRm1PMEZCUTBFc1QwRkJTeXhSUVVGTUxFZEJRV2RDTEVOQlFXaENPMEZCUTBFc1QwRkJTeXhWUVVGTUxFZEJRV3RDTEVsQlFXeENPMEZCUTBFc1QwRkJTeXhMUVVGTUxFZEJRV0VzUzBGQllqdEJRVU5CTEU5QlFVc3NTVUZCVEN4SFFVRlpMRWxCUVZvN1FVRkRRU3hQUVVGTExFdEJRVXdzUjBGQllTeERRVUZpTzBGQlEwRXNUMEZCU3l4WlFVRk1MRWRCUVc5Q0xFTkJRWEJDTzBGQlEwRXNUMEZCU3l4TlFVRk1MRWRCUVdNc1JVRkJaRHRCUVVOQk96dEJRVVZFT3pzN096czdPenN3UWtGSlVUdEJRVU5RTEZGQlFVc3NUMEZCVEN4SFFVRmxMRWxCUVdZN1FVRkRRU3hSUVVGTExGVkJRVXdzUjBGQmEwSXNRMEZCYkVJN1FVRkRRU3hSUVVGTExFOUJRVXdzUjBGQlpTeERRVUZtTzBGQlEwRXNVVUZCU3l4UlFVRk1MRWRCUVdkQ0xFTkJRV2hDTzBGQlEwRXNVVUZCU3l4VlFVRk1MRWRCUVd0Q0xFbEJRV3hDTzBGQlEwRXNVVUZCU3l4TFFVRk1MRWRCUVdFc1EwRkJZanRCUVVOQkxGRkJRVXNzV1VGQlRDeEhRVUZ2UWl4RFFVRndRanRCUVVOQkxGVkJRVThzU1VGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN096SkNRVWxUTzBGQlExSXNVVUZCU3l4UFFVRk1MRWRCUVdVc1NVRkJaanRCUVVOQkxGVkJRVThzU1VGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN096UkNRVWxWTzBGQlExUXNVVUZCU3l4UFFVRk1MRWRCUVdVc1MwRkJaanRCUVVOQkxGVkJRVThzU1VGQlVEdEJRVU5CT3p0QlFVVkVPenM3T3pzN096dHpRMEZMYjBJc1NTeEZRVUZOTzBGQlEzcENMRlZCUVU4c1VVRkJVU3hEUVVGbU96dEJRVVZCTEZGQlFVc3NTVUZCU1N4RFFVRlVMRWxCUVdNc1MwRkJTeXhOUVVGdVFpeEZRVUV5UWp0QlFVTXhRaXhSUVVGSkxFdEJRVXNzVFVGQlRDeERRVUZaTEVOQlFWb3NSVUZCWlN4SlFVRm1MRWxCUVhWQ0xFbEJRVE5DTEVWQlFXbERPMEZCUTJoRExGVkJRVXNzVlVGQlRDeEhRVUZyUWl4RFFVRnNRanRCUVVOQkxGbEJRVThzU1VGQlVEdEJRVU5CTzBGQlEwUTdRVUZEUkRzN1FVRkZSRHM3T3pzN096dHRRMEZKYVVJN1FVRkRhRUlzVlVGQlR5eExRVUZMTEVsQlFVd3NRMEZCVlN4TFFVRkxMRTlCUVdZc1EwRkJVRHRCUVVOQk96dEJRVVZFT3pzN096czdPM05EUVVsdlFqdEJRVU51UWp0QlFVTkJPMEZCUTBFN1FVRkRSenRCUVVOQk8wRkJRMEVzVDBGQlNTeGpRVUZqTEV0QlFVc3NZMEZCVEN4RlFVRnNRanRCUVVOQkxFOUJRVWtzV1VGQldTeERRVUZvUWpzN1FVRkZTQ3hWUVVGUExHVkJRV1VzUjBGQmRFSXNSVUZCTWtJN1FVRkRNVUlzYTBKQlFXTXNTMEZCU3l4SlFVRk1MRU5CUVZVc1MwRkJTeXhQUVVGTUxFZEJRV1VzVTBGQmVrSXNRMEZCWkR0QlFVTkJPMEZCUTBFN08wRkJSVVFzVlVGQlR5eFRRVUZRTzBGQlEwRTdPMEZCUlVRN096czdPenM3TmtKQlNWYzdRVUZEVml4VlFVRlBMRTFCUVUwc1ZVRkJUaXhEUVVGcFFpeExRVUZMTEVsQlFVd3NRMEZCVlN4UlFVRldMRU5CUVcxQ0xFdEJRVXNzVDBGQmVFSXNSVUZCYVVNc1MwRkJTeXhQUVVGTUxFZEJRV1VzUzBGQlN5eHBRa0ZCVEN4RlFVRm9SQ3hEUVVGcVFpeERRVUZRTzBGQlEwRTdPMEZCUlVRN096czdPenM3T3poQ1FVdFpMRmNzUlVGQllTeE5MRVZCUVZFN1FVRkRhRU1zV1VGQlV5eFZRVUZWTEV0QlFXNUNPenRCUVVWQkxFOUJRVWtzVFVGQlNpeEZRVUZaTzBGQlExZ3NVVUZCU1N4bFFVRmxMR05CUVdNc1MwRkJTeXhSUVVGMFF6dEJRVU5CTEZGQlFVa3NVVUZCVVN4TFFVRkxMRkZCUVV3c1JVRkJXanRCUVVOQkxGRkJRVWtzWVVGQllTeG5Ra0ZCWjBJc1MwRkJha003TzBGQlJVRXNVVUZCU1N4TFFVRkxMRTlCUVV3c1IwRkJaU3hMUVVGTExFbEJRVXdzUTBGQlZTeE5RVUY2UWl4TFFVRnZReXhWUVVGVkxGVkJRVGxETEVOQlFVb3NSVUZCSzBRN1FVRkRPVVFzVTBGQlNTeFRRVUZSTEV0QlFVc3NWVUZCVEN4RlFVRmFPMEZCUTBFc1UwRkJTU3hMUVVGTExFOUJRVlFzUlVGQmEwSXNUMEZCVHl4TlFVRlFPMEZCUTJ4Q08wRkJRMEU3UVVGRlJDeEpRVmhFTEUxQlYwODdRVUZEVGp0QlFVTkJMRkZCUVVrc1MwRkJTeXhOUVVGTUxFTkJRVmtzUzBGQlN5eFZRVUZxUWl4TFFVRm5ReXhMUVVGTExFMUJRVXdzUTBGQldTeExRVUZMTEZWQlFXcENMRVZCUVRaQ0xFbEJRVGRDTEVsQlFYRkRMRmRCUVhwRkxFVkJRWE5HTzBGQlEzSkdMRlZCUVVzc1ZVRkJURHRCUVVOQkxGTkJRVWtzUzBGQlN5eFBRVUZVTEVWQlFXdENMRTlCUVU4c1MwRkJTeXhOUVVGTUxFTkJRVmtzUzBGQlN5eFZRVUZNTEVkQlFXdENMRU5CUVRsQ0xFTkJRVkE3UVVGRGJFSTdRVUZEUkRzN1FVRkZSQ3hWUVVGUExFbEJRVkE3UVVGRFFUczdRVUZGUkRzN096czdPenM3WjBOQlMyTXNaU3hGUVVGcFFqdEJRVU01UWl4UFFVRkpMR05CUVdNc1MwRkJTeXhQUVVGMlFqdEJRVU5CTEU5QlFVa3NXVUZCV1N4RFFVRm9RanRCUVVOQkxFOUJRVWtzVTBGQlV5eE5RVUZOTEZWQlFVNHNRMEZCYVVJc1MwRkJTeXhKUVVGTUxFTkJRVlVzVVVGQlZpeERRVUZ0UWl4clFrRkJhMElzUTBGQmNrTXNSVUZCZDBNc2EwSkJRV3RDTEVOQlFXeENMRWRCUVhOQ0xGTkJRVGxFTEVOQlFXcENMRU5CUVdJN1FVRkRRU3hQUVVGSkxHVkJRV1VzVFVGQmJrSTdPMEZCUlVFc1ZVRkJUeXhOUVVGTkxHTkJRVTRzUTBGQmNVSXNTMEZCU3l4SlFVRk1MRU5CUVZVc1VVRkJWaXhEUVVGdFFpeHJRa0ZCYTBJc1UwRkJiRUlzUjBGQk9FSXNRMEZCYWtRc1JVRkJiMFFzYTBKQlFXdENMRk5CUVd4Q0xFZEJRVGhDTEUxQlFUbENMRWRCUVhWRExFTkJRVE5HTEVOQlFYSkNMRU5CUVZBN1FVRkRRVHM3UVVGRlJEczdPenM3T3pzclFrRkpZVHRCUVVOYUxFOUJRVWtzYTBKQlFXdENMRXRCUVVzc1QwRkJUQ3hIUVVGbExFdEJRVXNzYVVKQlFVd3NSVUZCY2tNN1FVRkRRU3hQUVVGSkxGbEJRVmtzUlVGQmFFSTdRVUZEUVN4UFFVRkpMR2xDUVVGcFFpeExRVUZMTEdsQ1FVRk1MRVZCUVhKQ08wRkJRMEVzWVVGQlZTeExRVUZXTEVkQlFXdENMRXRCUVVzc1MwRkJUQ3hIUVVGaExFTkJRUzlDTzBGQlEwRXNZVUZCVlN4TFFVRldMRWRCUVd0Q0xFdEJRVXNzVVVGQlRDeEZRVUZzUWp0QlFVTkJMRkZCUVVzc1VVRkJUQ3hIUVVGblFpeExRVUZMTEZGQlFVd3NSMEZCWjBJc1ZVRkJWU3hMUVVFeFF6dEJRVU5CTEZGQlFVc3NXVUZCVEN4SlFVRnhRaXhWUVVGVkxFdEJRUzlDTzBGQlEwRXNZVUZCVlN4SlFVRldMRWRCUVdsQ0xFdEJRVXNzV1VGQmRFSTdRVUZEUVN4aFFVRlZMRk5CUVZZc1IwRkJjMElzUzBGQlN5eFBRVUV6UWpzN1FVRkZRVHRCUVVOQkxFOUJRVWtzUzBGQlN5eEpRVUZNTEVOQlFWVXNaVUZCVml4TFFVRTRRaXhKUVVGc1F5eEZRVUYzUXp0QlFVTjJRenM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc1dVRkJUeXhMUVVGTExFbEJRVXdzUTBGQlZTeHJRa0ZCYTBJc1EwRkJOVUlzUTBGQlVEdEJRVU5ETEZWQlFVc3NTVUZCVER0QlFVRlhPMEZCUTFZc1owSkJRVlVzU1VGQlZpeEhRVUZwUWl4cFFrRkJha0k3UVVGRFFUdEJRVU5FTEZWQlFVc3NTVUZCVER0QlFVRlhPMEZCUTFZc1owSkJRVlVzU1VGQlZpeEhRVUZwUWl4WlFVRnFRanRCUVVOQkxHZENRVUZWTEUxQlFWWXNSMEZCYlVJc1MwRkJTeXhoUVVGTUxFTkJRVzFDTEdWQlFXNUNMRU5CUVc1Q08wRkJRMEU3UVVGRFJDeFZRVUZMTEVsQlFVdzdRVUZCVnp0QlFVTldMR2RDUVVGVkxFbEJRVllzUjBGQmFVSXNhMEpCUVdwQ08wRkJRMEU3UVVGRFJDeFZRVUZMTEVsQlFVdzdRVUZCVnp0QlFVTldMR2RDUVVGVkxFbEJRVllzUjBGQmFVSXNjVUpCUVdwQ08wRkJRMEVzWjBKQlFWVXNUVUZCVml4SFFVRnRRaXhMUVVGTExHRkJRVXdzUTBGQmJVSXNaVUZCYmtJc1EwRkJia0k3UVVGRFFUdEJRVU5FTEZWQlFVc3NTVUZCVER0QlFVRlhPMEZCUTFZc1owSkJRVlVzU1VGQlZpeEhRVUZwUWl4cFFrRkJha0k3UVVGRFFTeG5Ra0ZCVlN4TlFVRldMRWRCUVcxQ0xFdEJRVXNzWVVGQlRDeERRVUZ0UWl4bFFVRnVRaXhEUVVGdVFqdEJRVU5CTzBGQlEwUXNWVUZCU3l4SlFVRk1PMEZCUVZjN1FVRkRWaXhuUWtGQlZTeEpRVUZXTEVkQlFXbENMRTlCUVdwQ08wRkJRMEVzWjBKQlFWVXNUVUZCVml4SFFVRnRRaXhMUVVGTExHRkJRVXdzUTBGQmJVSXNaVUZCYmtJc1EwRkJia0k3UVVGRFFUdEJRVU5FTEZWQlFVc3NTVUZCVER0QlFVRlhPMEZCUTFZc1owSkJRVlVzU1VGQlZpeEhRVUZwUWl4UlFVRnFRanRCUVVOQk8wRkJRMFFzVlVGQlN5eEpRVUZNTzBGQlFWYzdRVUZEVml4blFrRkJWU3hKUVVGV0xFZEJRV2xDTEZkQlFXcENPMEZCUTBFc1owSkJRVlVzVFVGQlZpeEhRVUZ0UWl4TFFVRkxMR0ZCUVV3c1EwRkJiVUlzWlVGQmJrSXNRMEZCYmtJN1FVRkRRVHRCUVVORUxGVkJRVXNzU1VGQlREdEJRVUZYTzBGQlExWXNaMEpCUVZVc1NVRkJWaXhIUVVGcFFpeGhRVUZxUWp0QlFVTkJMR2RDUVVGVkxFMUJRVllzUjBGQmJVSXNTMEZCU3l4aFFVRk1MRU5CUVcxQ0xHVkJRVzVDTEVOQlFXNUNPMEZCUTBFN1FVRkRSQ3hWUVVGTExFbEJRVXc3UVVGQlZ6dEJRVU5XTEdkQ1FVRlZMRWxCUVZZc1IwRkJhVUlzY1VKQlFXcENPMEZCUTBFN1FVRkRSQ3hWUVVGTExFbEJRVXc3UVVGQlZ6dEJRVU5XTEdkQ1FVRlZMRWxCUVZZc1IwRkJhVUlzVjBGQmFrSTdRVUZEUVN4blFrRkJWU3hKUVVGV0xFZEJRV2xDTEUxQlFVMHNZVUZCVGl4RFFVRnZRaXhEUVVGRExFdEJRVXNzU1VGQlRDeERRVUZWTEd0Q1FVRnJRaXhEUVVFMVFpeERRVUZFTEVOQlFYQkNMRU5CUVdwQ08wRkJRMEU3UVVGRFJDeFZRVUZMTEVsQlFVdzdRVUZCVnp0QlFVTldMR2RDUVVGVkxFbEJRVllzUjBGQmFVSXNZMEZCYWtJN1FVRkRRVHRCUVVORUxGVkJRVXNzU1VGQlREdEJRVUZYTzBGQlExWXNaMEpCUVZVc1NVRkJWaXhIUVVGcFFpeFhRVUZxUWp0QlFVTkJMR2RDUVVGVkxFbEJRVllzUjBGQmFVSXNTMEZCU3l4TFFVRk1MRU5CUVZjc1YwRkJWeXhOUVVGTkxHRkJRVTRzUTBGQmIwSXNTMEZCU3l4SlFVRk1MRU5CUVZVc1VVRkJWaXhEUVVGdFFpeHJRa0ZCYTBJc1EwRkJja01zUlVGQmQwTXNhMEpCUVd0Q0xFTkJRVEZFTEVOQlFYQkNMRU5CUVhSQ0xFTkJRV3BDTzBGQlEwRXNWMEZCU3l4TFFVRk1MRWRCUVdFc1ZVRkJWU3hKUVVGMlFqdEJRVU5CTzBGQlEwUXNWVUZCU3l4SlFVRk1PMEZCUVZjN1FVRkRWaXhuUWtGQlZTeEpRVUZXTEVkQlFXbENMR05CUVdwQ08wRkJRMEU3UVVGRFJDeFZRVUZMTEVsQlFVdzdRVUZCVnp0QlFVTldPMEZCUTBFc1owSkJRVlVzU1VGQlZpeEhRVUZwUWl4blFrRkJha0k3UVVGRFFTeG5Ra0ZCVlN4SlFVRldMRWRCUVdsQ0xFdEJRVXNzU1VGQlRDeERRVUZWTEZGQlFWWXNRMEZCYlVJc2EwSkJRV3RDTEVOQlFYSkRMRVZCUVhkRExHdENRVUZyUWl4RFFVRXhSQ3hEUVVGcVFqdEJRVU5CTEdkQ1FVRlZMR0ZCUVZZc1IwRkJNRUlzUzBGQlN5eFZRVUZWTEVsQlFWWXNRMEZCWlN4RFFVRm1MRU5CUVV3c1IwRkJlVUlzUjBGQmVrSXNSMEZCSzBJc1MwRkJTeXhIUVVGTUxFTkJRVk1zUTBGQlZDeEZRVUZaTEZWQlFWVXNTVUZCVml4RFFVRmxMRU5CUVdZc1EwRkJXaXhEUVVGNlJEdEJRVU5CTzBGQlEwUXNWVUZCU3l4SlFVRk1PMEZCUVZjN1FVRkRWanRCUVVOQkxHZENRVUZWTEVsQlFWWXNSMEZCYVVJc1pVRkJha0k3UVVGRFFTeG5Ra0ZCVlN4SlFVRldMRWRCUVdsQ0xFdEJRVXNzU1VGQlRDeERRVUZWTEZGQlFWWXNRMEZCYlVJc2EwSkJRV3RDTEVOQlFYSkRMRVZCUVhkRExHdENRVUZyUWl4RFFVRXhSQ3hEUVVGcVFqczdRVUZGUVN4VlFVRkpMRlZCUVZVc1NVRkJWaXhEUVVGbExFTkJRV1lzUzBGQmNVSXNRMEZCZWtJc1JVRkJORUk3UVVGRE0wSXNhVUpCUVZVc1dVRkJWaXhIUVVGNVFpeFZRVUZWTEdkQ1FVRldMRU5CUVRKQ0xGVkJRVlVzU1VGQlZpeERRVUZsTEVOQlFXWXNRMEZCTTBJc1EwRkJla0k3UVVGRlFTeFBRVWhFTEUxQlIwOHNTVUZCU1N4VlFVRlZMRWxCUVZZc1EwRkJaU3hEUVVGbUxFbEJRVzlDTEVOQlFYaENMRVZCUVRKQ08wRkJRMnBETEdsQ1FVRlZMRmxCUVZZc1IwRkJlVUlzVlVGQlZTeHBRa0ZCVml4RFFVRTBRaXhMUVVGTExFZEJRVXdzUTBGQlV5eFZRVUZWTEVsQlFWWXNRMEZCWlN4RFFVRm1MRU5CUVZRc1EwRkJOVUlzUTBGQmVrSTdRVUZEUVRzN1FVRkZSQ3hWUVVGSkxGVkJRVlVzU1VGQlZpeERRVUZsTEVOQlFXWXNTMEZCY1VJc1EwRkJla0lzUlVGQk5FSTdRVUZETTBJc2FVSkJRVlVzV1VGQlZpeEpRVUV3UWl4UlFVRXhRanRCUVVWQkxFOUJTRVFzVFVGSFR5eEpRVUZKTEZWQlFWVXNTVUZCVml4RFFVRmxMRU5CUVdZc1MwRkJjVUlzUTBGQmVrSXNSVUZCTkVJN1FVRkRiRU1zYVVKQlFWVXNXVUZCVml4SlFVRXdRaXhSUVVFeFFqdEJRVU5CT3p0QlFVVkVPMEZCUTBRc1ZVRkJTeXhKUVVGTU8wRkJRVmM3UVVGRFZpeG5Ra0ZCVlN4SlFVRldMRWRCUVdsQ0xDdENRVUZxUWp0QlFVTkJPMEZCUTBRN1FVRkRReXhuUWtGQlZTeEpRVUZXTEVkQlFXbENMR05CUVdNc1MwRkJTeXhKUVVGTUxFTkJRVlVzYTBKQlFXdENMRU5CUVRWQ0xFVkJRU3RDTEZGQlFTOUNMRU5CUVhkRExFVkJRWGhETEVOQlFTOUNPMEZCUTBFN1FVRnVSa1k3TzBGQmMwWkJMRkZCUVVrc1UwRkJVeXhMUVVGTExFbEJRVXdzUTBGQlZTeExRVUZMTEU5QlFVd3NSMEZCWlN4alFVRm1MRWRCUVdkRExFTkJRVEZETEVOQlFXSTdRVUZEUVRzN1FVRkZRU3hUUVVGTExFOUJRVXdzU1VGQlowSXNhVUpCUVdsQ0xFTkJRV3BDTEVkQlFYRkNMRTFCUVhKRE8wRkJSVUVzU1VGc1IwUXNUVUZyUjA4c1NVRkJSeXhMUVVGTExFbEJRVXdzUTBGQlZTeGxRVUZXTEV0QlFUaENMRWxCUVdwRExFVkJRWFZETzBGQlF6ZERPMEZCUTBFc1kwRkJWU3hKUVVGV0xFZEJRV2xDTEU5QlFXcENPMEZCUTBFc1VVRkJTU3hUUVVGVExFdEJRVXNzU1VGQlRDeERRVUZWTEV0QlFVc3NUMEZCVEN4SFFVRmxMR05CUVdZc1IwRkJaME1zUTBGQk1VTXNRMEZCWWp0QlFVTkJMRk5CUVVzc1QwRkJUQ3hKUVVGblFpeHBRa0ZCYVVJc1EwRkJha0lzUjBGQmNVSXNUVUZCY2tNN1FVRkZRU3hKUVU1TkxFMUJUVUU3UVVGRFRqdEJRVU5CTEZGQlFVa3NTMEZCU3l4SlFVRk1MRU5CUVZVc1pVRkJWaXhKUVVFMlFpeEpRVUZxUXl4RlFVRjFRenRCUVVOMFF6dEJRVU5CTEdWQlFWVXNUMEZCVml4SFFVRnZRaXhKUVVGd1FqdEJRVU5CTEdWQlFWVXNWVUZCVml4SFFVRjFRaXhMUVVGTExFbEJRVXdzUTBGQlZTeGxRVUZXTEVOQlFYWkNPMEZCUTBFc1pVRkJWU3hSUVVGV0xFZEJRWEZDTEZWQlFWVXNTMEZCVml4RFFVRm5RaXhMUVVGTExFbEJRVXdzUTBGQlZTeGxRVUZXTEVOQlFXaENMRU5CUVhKQ08wRkJRMEVzWlVGQlZTeFJRVUZXTEVkQlFYRkNMRXRCUVVzc1NVRkJUQ3hEUVVGVkxHdENRVUZyUWl4RFFVRTFRaXhEUVVGeVFqczdRVUZGUVN4VFFVRkpMRXRCUVVzc1ZVRkJUQ3hKUVVGdFFpeEpRVUYyUWl4RlFVRTJRanRCUVVNMVFpeG5Ra0ZCVlN4SlFVRldMRWRCUVdsQ0xGVkJRV3BDTzBGQlEwRXNaMEpCUVZVc1QwRkJWaXhIUVVGdlFpeExRVUZMTEZWQlFVd3NSMEZCYTBJc1NVRkJiRUlzUjBGQmVVSXNRMEZCTjBNN1FVRkZRU3hOUVVwRUxFMUJTVThzU1VGQlNTeExRVUZMTEZWQlFVd3NTVUZCYlVJc1NVRkJka0lzUlVGQk5rSTdRVUZEYmtNc1owSkJRVlVzU1VGQlZpeEhRVUZwUWl4VFFVRnFRanRCUVVOQkxHZENRVUZWTEU5QlFWWXNSMEZCYjBJc1MwRkJTeXhWUVVGTUxFZEJRV3RDTEVsQlFXeENMRWRCUVhsQ0xFTkJRVGRETzBGQlEwRTdPMEZCUlVRc1ZVRkJTeXhQUVVGTUxFbEJRV2RDTEdsQ1FVRnBRaXhEUVVGcVF6dEJRVVZCTEV0QmJFSkVMRTFCYTBKUE8wRkJRMDRzVlVGQlN5eFZRVUZNTEVkQlFXdENMRXRCUVVzc1NVRkJUQ3hEUVVGVkxHVkJRVllzUTBGQmJFSTdPMEZCUlVFc1UwRkJTU3hMUVVGTExFbEJRVXdzUTBGQlZTeGxRVUZXTEV0QlFUaENMRWxCUVd4RExFVkJRWGRETzBGQlEzWkRPMEZCUTBFc1owSkJRVlVzU1VGQlZpeEhRVUZwUWl4VlFVRnFRanRCUVVOQkxHZENRVUZWTEU5QlFWWXNSMEZCYjBJc1MwRkJTeXhWUVVGTUxFZEJRV3RDTEVsQlFXeENMRWRCUVhsQ0xFTkJRVGRETzBGQlEwRXNaMEpCUVZVc1ZVRkJWaXhIUVVGMVFpeExRVUZMTEVsQlFVd3NRMEZCVlN4clFrRkJhMElzUTBGQk5VSXNRMEZCZGtJN1FVRkRRU3huUWtGQlZTeFJRVUZXTEVkQlFYRkNMRlZCUVZVc1MwRkJWaXhEUVVGblFpeExRVUZMTEVsQlFVd3NRMEZCVlN4clFrRkJhMElzUTBGQk5VSXNRMEZCYUVJc1EwRkJja0k3UVVGRFFTeG5Ra0ZCVlN4UlFVRldMRWRCUVhGQ0xFdEJRVXNzUzBGQlRDeERRVUZYTEV0QlFVc3NTVUZCVEN4RFFVRlZMR3RDUVVGclFpeERRVUUxUWl4SlFVRnBReXhIUVVGcVF5eEhRVUYxUXl4SFFVRnNSQ3hEUVVGeVFqdEJRVU5CTEZkQlFVc3NUMEZCVEN4SlFVRm5RaXhwUWtGQmFVSXNRMEZCYWtNN1FVRkZRU3hOUVZSRUxFMUJVMDhzU1VGQlNTeExRVUZMTEVsQlFVd3NRMEZCVlN4bFFVRldMRXRCUVRoQ0xFbEJRV3hETEVWQlFYZERPMEZCUXpsRE8wRkJRMEVzWjBKQlFWVXNTVUZCVml4SFFVRnBRaXhUUVVGcVFqdEJRVU5CTEdkQ1FVRlZMRTlCUVZZc1IwRkJiMElzUzBGQlN5eFZRVUZNTEVkQlFXdENMRWxCUVd4Q0xFZEJRWGxDTEVOQlFUZERPMEZCUTBFc1owSkJRVlVzVlVGQlZpeEhRVUYxUWl4TFFVRkxMRWxCUVV3c1EwRkJWU3hyUWtGQmEwSXNRMEZCTlVJc1EwRkJka0k3UVVGRFFTeG5Ra0ZCVlN4UlFVRldMRWRCUVhGQ0xGVkJRVlVzUzBGQlZpeERRVUZuUWl4TFFVRkxMRWxCUVV3c1EwRkJWU3hyUWtGQmEwSXNRMEZCTlVJc1EwRkJhRUlzUTBGQmNrSTdRVUZEUVN4blFrRkJWU3hSUVVGV0xFZEJRWEZDTEV0QlFVc3NTMEZCVEN4RFFVRlhMRXRCUVVzc1NVRkJUQ3hEUVVGVkxHdENRVUZyUWl4RFFVRTFRaXhKUVVGcFF5eEhRVUZxUXl4SFFVRjFReXhIUVVGc1JDeERRVUZ5UWp0QlFVTkJMRmRCUVVzc1QwRkJUQ3hKUVVGblFpeHBRa0ZCYVVJc1EwRkJha003UVVGRlFTeE5RVlJOTEUxQlUwRXNTVUZCU1N4TFFVRkxMRWxCUVV3c1EwRkJWU3hsUVVGV0xFdEJRVGhDTEVsQlFXeERMRVZCUVhkRE8wRkJRemxETzBGQlEwRXNaMEpCUVZVc1NVRkJWaXhIUVVGcFFpeDVRa0ZCYWtJN1FVRkRRU3huUWtGQlZTeFBRVUZXTEVkQlFXOUNMRXRCUVVzc1ZVRkJUQ3hIUVVGclFpeEpRVUZzUWl4SFFVRjVRaXhEUVVFM1F6dEJRVU5CTEdkQ1FVRlZMRWxCUVZZc1IwRkJhVUlzVlVGQlZTeExRVUZXTEVOQlFXZENMRXRCUVVzc1NVRkJUQ3hEUVVGVkxHdENRVUZyUWl4RFFVRTFRaXhEUVVGb1FpeERRVUZxUWp0QlFVTkJMR2RDUVVGVkxGRkJRVllzUjBGQmNVSXNUVUZCVFN4RFFVRk9MRU5CUVhKQ08wRkJRMEVzVjBGQlN5eFBRVUZNTEVsQlFXZENMR2xDUVVGcFFpeERRVUZxUXp0QlFVVkJMRTFCVWswc1RVRlJRU3hKUVVGSkxFdEJRVXNzU1VGQlRDeERRVUZWTEdWQlFWWXNTMEZCT0VJc1NVRkJiRU1zUlVGQmQwTTdRVUZET1VNN1FVRkRRU3huUWtGQlZTeEpRVUZXTEVkQlFXbENMRzFDUVVGcVFqdEJRVU5CTEdkQ1FVRlZMRTlCUVZZc1IwRkJiMElzUzBGQlN5eFZRVUZNTEVkQlFXdENMRWxCUVd4Q0xFZEJRWGxDTEVOQlFUZERPMEZCUTBFc1owSkJRVlVzVFVGQlZpeEhRVUZ0UWl4TFFVRkxMRWxCUVV3c1EwRkJWU3hyUWtGQmEwSXNRMEZCTlVJc1EwRkJia0k3UVVGRFFTeG5Ra0ZCVlN4TFFVRldMRWRCUVd0Q0xFdEJRVXNzU1VGQlRDeERRVUZWTEd0Q1FVRnJRaXhEUVVFMVFpeERRVUZzUWp0QlFVTkJMRmRCUVVzc1QwRkJUQ3hKUVVGblFpeHBRa0ZCYVVJc1EwRkJha003UVVGRlFTeE5RVkpOTEUxQlVVRXNTVUZCU1N4TFFVRkxMRWxCUVV3c1EwRkJWU3hsUVVGV0xFdEJRVGhDTEVsQlFXeERMRVZCUVhkRE8wRkJRemxETzBGQlEwRXNaMEpCUVZVc1NVRkJWaXhIUVVGcFFpeG5Ra0ZCYWtJN1FVRkRRU3huUWtGQlZTeFBRVUZXTEVkQlFXOUNMRXRCUVVzc1ZVRkJUQ3hIUVVGclFpeEpRVUZzUWl4SFFVRjVRaXhEUVVFM1F6dEJRVU5CTEdkQ1FVRlZMRXRCUVZZc1IwRkJhMElzUzBGQlN5eEpRVUZNTEVOQlFWVXNhMEpCUVd0Q0xFTkJRVFZDTEVOQlFXeENPMEZCUTBFc1YwRkJTeXhQUVVGTUxFbEJRV2RDTEdsQ1FVRnBRaXhEUVVGcVF6dEJRVVZCTEUxQlVFMHNUVUZQUVN4SlFVRkpMRXRCUVVzc1NVRkJUQ3hEUVVGVkxHVkJRVllzUzBGQk9FSXNTVUZCYkVNc1JVRkJkME03UVVGRE9VTTdRVUZEUVN4blFrRkJWU3hKUVVGV0xFZEJRV2xDTEhOQ1FVRnFRanRCUVVOQkxHZENRVUZWTEU5QlFWWXNSMEZCYjBJc1MwRkJTeXhWUVVGTUxFZEJRV3RDTEVsQlFXeENMRWRCUVhsQ0xFTkJRVGRETzBGQlEwRXNWMEZCU3l4UFFVRk1MRWxCUVdkQ0xHbENRVUZwUWl4RFFVRnFRenRCUVVWQkxFMUJUazBzVFVGTlFTeEpRVUZKTEV0QlFVc3NTVUZCVEN4RFFVRlZMR1ZCUVZZc1MwRkJPRUlzU1VGQmJFTXNSVUZCZDBNN1FVRkRPVU03UVVGRFFTeG5Ra0ZCVlN4SlFVRldMRWRCUVdsQ0xGbEJRV3BDTzBGQlEwRXNaMEpCUVZVc1QwRkJWaXhIUVVGdlFpeExRVUZMTEZWQlFVd3NSMEZCYTBJc1NVRkJiRUlzUjBGQmVVSXNRMEZCTjBNN1FVRkRRU3hYUVVGTExFOUJRVXdzU1VGQlowSXNhVUpCUVdsQ0xFTkJRV3BETzBGQlJVRXNUVUZPVFN4TlFVMUJPMEZCUTA0c1owSkJRVlVzU1VGQlZpeEhRVUZwUWl4M1FrRkJkMElzUzBGQlN5eFBRVUZNTEVOQlFXRXNVVUZCWWl4RlFVRjRRaXhIUVVGclJDeEhRVUZzUkN4SFFVRjVSQ3huUWtGQlowSXNVVUZCYUVJc1JVRkJla1FzUjBGQmMwWXNSMEZCZEVZc1IwRkJORVlzUzBGQlN5eEpRVUZNTEVOQlFWVXNUVUZCZGtnN1FVRkRRVHRCUVVORU8wRkJRMFE3TzBGQlJVUXNVVUZCU3l4TFFVRk1MRWxCUVdNc1ZVRkJWU3hMUVVGNFFqdEJRVU5CTEZGQlFVc3NUVUZCVEN4RFFVRlpMRWxCUVZvc1EwRkJhVUlzVTBGQmFrSTdPMEZCUlVFc1ZVRkJUeXhUUVVGUU8wRkJRMEU3TzBGQlJVUTdPenM3T3pzN0swSkJTV0U3UVVGRFdpeFBRVUZKTEV0QlFVc3NTVUZCVEN4RFFVRlZMRXRCUVVzc1QwRkJUQ3hIUVVGbExFTkJRWHBDTEV0QlFTdENMRWxCUVM5Q0xFbEJRWFZETEV0QlFVc3NTVUZCVEN4RFFVRlZMRXRCUVVzc1QwRkJUQ3hIUVVGbExFTkJRWHBDTEV0QlFTdENMRWxCUVhSRkxFbEJRVGhGTEV0QlFVc3NTVUZCVEN4RFFVRlZMRXRCUVVzc1QwRkJUQ3hIUVVGbExFTkJRWHBDTEV0QlFTdENMRWxCUVdwSUxFVkJRWFZJTzBGQlEzUklMRmRCUVU4c1NVRkJVRHRCUVVOQk96dEJRVVZFTEZWQlFVOHNTMEZCVUR0QlFVTkJPenM3T3pzN1FVRkhSaXhQUVVGUExFOUJRVkFzUTBGQlpTeExRVUZtTEVkQlFYVkNMRXRCUVhaQ096czdPenM3T3pzN08wRkRibGhCT3pzN1NVRkhUU3hMT3pzN096czdPenM3UVVGRlREczdPenM3TkVKQlMybENMRWtzUlVGQlRUdEJRVU4wUWp0QlFVTkJMRlZCUVU4c1EwRkJReXhOUVVGTkxFdEJRVXNzVVVGQlRDeERRVUZqTEVWQlFXUXNRMEZCVUN4RlFVRXdRaXhMUVVFeFFpeERRVUZuUXl4RFFVRkRMRU5CUVdwRExFTkJRVkE3UVVGRFFUczdRVUZGUkRzN096czdPenM3TmtKQlMydENMRk1zUlVGQlZ6dEJRVU0xUWl4UFFVRkpMRTFCUVUwc1JVRkJWanRCUVVOQkxHRkJRVlVzVDBGQlZpeERRVUZyUWp0QlFVRkJMRmRCUVZFc1NVRkJTU3hKUVVGS0xFTkJRVk1zVFVGQlRTeFRRVUZPTEVOQlFXZENMRWxCUVdoQ0xFTkJRVlFzUTBGQlVqdEJRVUZCTEVsQlFXeENPMEZCUTBFc1ZVRkJUeXhKUVVGSkxFbEJRVW9zUTBGQlV5eEZRVUZVTEVOQlFWQTdRVUZEUVRzN1FVRkZSRHM3T3pzN096czdPRUpCUzIxQ0xGTXNSVUZCVnp0QlFVTTNRaXhWUVVGUExGTkJRVk1zVTBGQlZDeEZRVUZ2UWl4RlFVRndRaXhEUVVGUU8wRkJRMEU3TzBGQlJVUTdPenM3T3pzN08yZERRVXR4UWl4VExFVkJRVmM3UVVGREwwSXNWVUZCVHl4TlFVRk5MRmRCUVU0c1EwRkJhMElzVFVGQlRTeFZRVUZPTEVOQlFXbENMRk5CUVdwQ0xFTkJRV3hDTEVOQlFWQTdRVUZEUVRzN1FVRkZSRHM3T3pzN096czdhVU5CUzNOQ0xGTXNSVUZCVnp0QlFVTm9ReXhQUVVGSkxGVkJRVlVzUlVGQlpEdEJRVU5CTEdGQlFWVXNUMEZCVml4RFFVRnJRanRCUVVGQkxGZEJRVkVzVVVGQlVTeEpRVUZTTEVOQlFXRXNUMEZCVHl4WlFVRlFMRU5CUVc5Q0xFbEJRWEJDTEVOQlFXSXNRMEZCVWp0QlFVRkJMRWxCUVd4Q08wRkJRMEVzVlVGQlR5eFJRVUZSTEVsQlFWSXNRMEZCWVN4RlFVRmlMRU5CUVZBN1FVRkRRVHM3UVVGRlJEczdPenM3T3pzN09FSkJTMjFDTEVjc1JVRkJTenRCUVVOd1FpeFZRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRlVMRVZCUVZrc1VVRkJXaXhEUVVGeFFpeERRVUZ5UWl4RFFVRlFPMEZCUTBnN08wRkJSVVE3T3pzN096czdPelpDUVV0clFpeFRMRVZCUVZjN1FVRkROVUlzVDBGQlNTeFRRVUZUTEVOQlFXSTdRVUZEUVN4aFFVRlZMRTlCUVZZc1EwRkJhMElzYTBKQlFWVTdRVUZETTBJc1VVRkJTU3hKUVVGSkxFMUJRVkk3UVVGRFFTeFJRVUZKTEVsQlFVa3NTVUZCVWl4RlFVRmpPMEZCUTJJc1pVRkJWeXhKUVVGSkxFbEJRV1k3UVVGRFFTeG5Ra0ZCVnl4RFFVRllPMEZCUTBFc1MwRklSQ3hOUVVkUE8wRkJRMDQ3UVVGRFFTeGxRVUZWTEVOQlFWWTdRVUZEUVR0QlFVTkVMRWxCVkVRN08wRkJWMEVzVlVGQlR5eE5RVUZRTzBGQlEwRTdPMEZCUlVRN096czdPenM3T3pzN096czdPenM3T3p0alFVdFpMRTBzUlVGQlVUdEJRVU51UWl4UFFVRkpMRTlCUVU4c1NVRkJVQ3hMUVVGblFpeFZRVUZ3UWl4RlFVRm5ReXhQUVVGUExFdEJRVXNzVFVGQlRDeERRVUZRTzBGQlEyaERMRlZCUVU4c1NVRkJTU3hOUVVGS0xFTkJRVmNzVFVGQldDeEZRVUZ0UWl4UlFVRnVRaXhGUVVFMlFpeFJRVUUzUWl4RFFVRnpReXhSUVVGMFF5eERRVUZRTzBGQlEwRXNSenM3T3pzN08wRkJSMFlzVVVGQlVTeExRVUZTTEVkQlFXZENMRXRCUVdoQ0lpd2labWxzWlNJNkltZGxibVZ5WVhSbFpDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUlvWm5WdVkzUnBiMjRvS1h0bWRXNWpkR2x2YmlCbEtIUXNiaXh5S1h0bWRXNWpkR2x2YmlCektHOHNkU2w3YVdZb0lXNWJiMTBwZTJsbUtDRjBXMjlkS1h0MllYSWdZVDEwZVhCbGIyWWdjbVZ4ZFdseVpUMDlYQ0ptZFc1amRHbHZibHdpSmlaeVpYRjFhWEpsTzJsbUtDRjFKaVpoS1hKbGRIVnliaUJoS0c4c0lUQXBPMmxtS0drcGNtVjBkWEp1SUdrb2J5d2hNQ2s3ZG1GeUlHWTlibVYzSUVWeWNtOXlLRndpUTJGdWJtOTBJR1pwYm1RZ2JXOWtkV3hsSUNkY0lpdHZLMXdpSjF3aUtUdDBhSEp2ZHlCbUxtTnZaR1U5WENKTlQwUlZURVZmVGs5VVgwWlBWVTVFWENJc1puMTJZWElnYkQxdVcyOWRQWHRsZUhCdmNuUnpPbnQ5ZlR0MFcyOWRXekJkTG1OaGJHd29iQzVsZUhCdmNuUnpMR1oxYm1OMGFXOXVLR1VwZTNaaGNpQnVQWFJiYjExYk1WMWJaVjA3Y21WMGRYSnVJSE1vYmo5dU9tVXBmU3hzTEd3dVpYaHdiM0owY3l4bExIUXNiaXh5S1gxeVpYUjFjbTRnYmx0dlhTNWxlSEJ2Y25SemZYWmhjaUJwUFhSNWNHVnZaaUJ5WlhGMWFYSmxQVDFjSW1aMWJtTjBhVzl1WENJbUpuSmxjWFZwY21VN1ptOXlLSFpoY2lCdlBUQTdienh5TG14bGJtZDBhRHR2S3lzcGN5aHlXMjlkS1R0eVpYUjFjbTRnYzMxeVpYUjFjbTRnWlgwcEtDa2lMQ0luZFhObElITjBjbWxqZENkY2JseHVaWGh3YjNKMGN5NWllWFJsVEdWdVozUm9JRDBnWW5sMFpVeGxibWQwYUZ4dVpYaHdiM0owY3k1MGIwSjVkR1ZCY25KaGVTQTlJSFJ2UW5sMFpVRnljbUY1WEc1bGVIQnZjblJ6TG1aeWIyMUNlWFJsUVhKeVlYa2dQU0JtY205dFFubDBaVUZ5Y21GNVhHNWNiblpoY2lCc2IyOXJkWEFnUFNCYlhWeHVkbUZ5SUhKbGRreHZiMnQxY0NBOUlGdGRYRzUyWVhJZ1FYSnlJRDBnZEhsd1pXOW1JRlZwYm5RNFFYSnlZWGtnSVQwOUlDZDFibVJsWm1sdVpXUW5JRDhnVldsdWREaEJjbkpoZVNBNklFRnljbUY1WEc1Y2JuWmhjaUJqYjJSbElEMGdKMEZDUTBSRlJrZElTVXBMVEUxT1QxQlJVbE5VVlZaWFdGbGFZV0pqWkdWbVoyaHBhbXRzYlc1dmNIRnljM1IxZG5kNGVYb3dNVEl6TkRVMk56ZzVLeThuWEc1bWIzSWdLSFpoY2lCcElEMGdNQ3dnYkdWdUlEMGdZMjlrWlM1c1pXNW5kR2c3SUdrZ1BDQnNaVzQ3SUNzcmFTa2dlMXh1SUNCc2IyOXJkWEJiYVYwZ1BTQmpiMlJsVzJsZFhHNGdJSEpsZGt4dmIydDFjRnRqYjJSbExtTm9ZWEpEYjJSbFFYUW9hU2xkSUQwZ2FWeHVmVnh1WEc1eVpYWk1iMjlyZFhCYkp5MG5MbU5vWVhKRGIyUmxRWFFvTUNsZElEMGdOakpjYm5KbGRreHZiMnQxY0Zzblh5Y3VZMmhoY2tOdlpHVkJkQ2d3S1YwZ1BTQTJNMXh1WEc1bWRXNWpkR2x2YmlCd2JHRmpaVWh2YkdSbGNuTkRiM1Z1ZENBb1lqWTBLU0I3WEc0Z0lIWmhjaUJzWlc0Z1BTQmlOalF1YkdWdVozUm9YRzRnSUdsbUlDaHNaVzRnSlNBMElENGdNQ2tnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpZ25TVzUyWVd4cFpDQnpkSEpwYm1jdUlFeGxibWQwYUNCdGRYTjBJR0psSUdFZ2JYVnNkR2x3YkdVZ2IyWWdOQ2NwWEc0Z0lIMWNibHh1SUNBdkx5QjBhR1VnYm5WdFltVnlJRzltSUdWeGRXRnNJSE5wWjI1eklDaHdiR0ZqWlNCb2IyeGtaWEp6S1Z4dUlDQXZMeUJwWmlCMGFHVnlaU0JoY21VZ2RIZHZJSEJzWVdObGFHOXNaR1Z5Y3l3Z2RHaGhiaUIwYUdVZ2RIZHZJR05vWVhKaFkzUmxjbk1nWW1WbWIzSmxJR2wwWEc0Z0lDOHZJSEpsY0hKbGMyVnVkQ0J2Ym1VZ1lubDBaVnh1SUNBdkx5QnBaaUIwYUdWeVpTQnBjeUJ2Ym14NUlHOXVaU3dnZEdobGJpQjBhR1VnZEdoeVpXVWdZMmhoY21GamRHVnljeUJpWldadmNtVWdhWFFnY21Wd2NtVnpaVzUwSURJZ1lubDBaWE5jYmlBZ0x5OGdkR2hwY3lCcGN5QnFkWE4wSUdFZ1kyaGxZWEFnYUdGamF5QjBieUJ1YjNRZ1pHOGdhVzVrWlhoUFppQjBkMmxqWlZ4dUlDQnlaWFIxY200Z1lqWTBXMnhsYmlBdElESmRJRDA5UFNBblBTY2dQeUF5SURvZ1lqWTBXMnhsYmlBdElERmRJRDA5UFNBblBTY2dQeUF4SURvZ01GeHVmVnh1WEc1bWRXNWpkR2x2YmlCaWVYUmxUR1Z1WjNSb0lDaGlOalFwSUh0Y2JpQWdMeThnWW1GelpUWTBJR2x6SURRdk15QXJJSFZ3SUhSdklIUjNieUJqYUdGeVlXTjBaWEp6SUc5bUlIUm9aU0J2Y21sbmFXNWhiQ0JrWVhSaFhHNGdJSEpsZEhWeWJpQW9ZalkwTG14bGJtZDBhQ0FxSURNZ0x5QTBLU0F0SUhCc1lXTmxTRzlzWkdWeWMwTnZkVzUwS0dJMk5DbGNibjFjYmx4dVpuVnVZM1JwYjI0Z2RHOUNlWFJsUVhKeVlYa2dLR0kyTkNrZ2UxeHVJQ0IyWVhJZ2FTd2diQ3dnZEcxd0xDQndiR0ZqWlVodmJHUmxjbk1zSUdGeWNseHVJQ0IyWVhJZ2JHVnVJRDBnWWpZMExteGxibWQwYUZ4dUlDQndiR0ZqWlVodmJHUmxjbk1nUFNCd2JHRmpaVWh2YkdSbGNuTkRiM1Z1ZENoaU5qUXBYRzVjYmlBZ1lYSnlJRDBnYm1WM0lFRnljaWdvYkdWdUlDb2dNeUF2SURRcElDMGdjR3hoWTJWSWIyeGtaWEp6S1Z4dVhHNGdJQzh2SUdsbUlIUm9aWEpsSUdGeVpTQndiR0ZqWldodmJHUmxjbk1zSUc5dWJIa2daMlYwSUhWd0lIUnZJSFJvWlNCc1lYTjBJR052YlhCc1pYUmxJRFFnWTJoaGNuTmNiaUFnYkNBOUlIQnNZV05sU0c5c1pHVnljeUErSURBZ1B5QnNaVzRnTFNBMElEb2diR1Z1WEc1Y2JpQWdkbUZ5SUV3Z1BTQXdYRzVjYmlBZ1ptOXlJQ2hwSUQwZ01Ec2dhU0E4SUd3N0lHa2dLejBnTkNrZ2UxeHVJQ0FnSUhSdGNDQTlJQ2h5WlhaTWIyOXJkWEJiWWpZMExtTm9ZWEpEYjJSbFFYUW9hU2xkSUR3OElERTRLU0I4SUNoeVpYWk1iMjlyZFhCYllqWTBMbU5vWVhKRGIyUmxRWFFvYVNBcklERXBYU0E4UENBeE1pa2dmQ0FvY21WMlRHOXZhM1Z3VzJJMk5DNWphR0Z5UTI5a1pVRjBLR2tnS3lBeUtWMGdQRHdnTmlrZ2ZDQnlaWFpNYjI5cmRYQmJZalkwTG1Ob1lYSkRiMlJsUVhRb2FTQXJJRE1wWFZ4dUlDQWdJR0Z5Y2x0TUt5dGRJRDBnS0hSdGNDQStQaUF4TmlrZ0ppQXdlRVpHWEc0Z0lDQWdZWEp5VzB3cksxMGdQU0FvZEcxd0lENCtJRGdwSUNZZ01IaEdSbHh1SUNBZ0lHRnljbHRNS3l0ZElEMGdkRzF3SUNZZ01IaEdSbHh1SUNCOVhHNWNiaUFnYVdZZ0tIQnNZV05sU0c5c1pHVnljeUE5UFQwZ01pa2dlMXh1SUNBZ0lIUnRjQ0E5SUNoeVpYWk1iMjlyZFhCYllqWTBMbU5vWVhKRGIyUmxRWFFvYVNsZElEdzhJRElwSUh3Z0tISmxka3h2YjJ0MWNGdGlOalF1WTJoaGNrTnZaR1ZCZENocElDc2dNU2xkSUQ0K0lEUXBYRzRnSUNBZ1lYSnlXMHdySzEwZ1BTQjBiWEFnSmlBd2VFWkdYRzRnSUgwZ1pXeHpaU0JwWmlBb2NHeGhZMlZJYjJ4a1pYSnpJRDA5UFNBeEtTQjdYRzRnSUNBZ2RHMXdJRDBnS0hKbGRreHZiMnQxY0Z0aU5qUXVZMmhoY2tOdlpHVkJkQ2hwS1YwZ1BEd2dNVEFwSUh3Z0tISmxka3h2YjJ0MWNGdGlOalF1WTJoaGNrTnZaR1ZCZENocElDc2dNU2xkSUR3OElEUXBJSHdnS0hKbGRreHZiMnQxY0Z0aU5qUXVZMmhoY2tOdlpHVkJkQ2hwSUNzZ01pbGRJRDQrSURJcFhHNGdJQ0FnWVhKeVcwd3JLMTBnUFNBb2RHMXdJRDQrSURncElDWWdNSGhHUmx4dUlDQWdJR0Z5Y2x0TUt5dGRJRDBnZEcxd0lDWWdNSGhHUmx4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdGeWNseHVmVnh1WEc1bWRXNWpkR2x2YmlCMGNtbHdiR1YwVkc5Q1lYTmxOalFnS0c1MWJTa2dlMXh1SUNCeVpYUjFjbTRnYkc5dmEzVndXMjUxYlNBK1BpQXhPQ0FtSURCNE0wWmRJQ3NnYkc5dmEzVndXMjUxYlNBK1BpQXhNaUFtSURCNE0wWmRJQ3NnYkc5dmEzVndXMjUxYlNBK1BpQTJJQ1lnTUhnelJsMGdLeUJzYjI5cmRYQmJiblZ0SUNZZ01IZ3pSbDFjYm4xY2JseHVablZ1WTNScGIyNGdaVzVqYjJSbFEyaDFibXNnS0hWcGJuUTRMQ0J6ZEdGeWRDd2daVzVrS1NCN1hHNGdJSFpoY2lCMGJYQmNiaUFnZG1GeUlHOTFkSEIxZENBOUlGdGRYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQnpkR0Z5ZERzZ2FTQThJR1Z1WkRzZ2FTQXJQU0F6S1NCN1hHNGdJQ0FnZEcxd0lEMGdLSFZwYm5RNFcybGRJRHc4SURFMktTQXJJQ2gxYVc1ME9GdHBJQ3NnTVYwZ1BEd2dPQ2tnS3lBb2RXbHVkRGhiYVNBcklESmRLVnh1SUNBZ0lHOTFkSEIxZEM1d2RYTm9LSFJ5YVhCc1pYUlViMEpoYzJVMk5DaDBiWEFwS1Z4dUlDQjlYRzRnSUhKbGRIVnliaUJ2ZFhSd2RYUXVhbTlwYmlnbkp5bGNibjFjYmx4dVpuVnVZM1JwYjI0Z1puSnZiVUo1ZEdWQmNuSmhlU0FvZFdsdWREZ3BJSHRjYmlBZ2RtRnlJSFJ0Y0Z4dUlDQjJZWElnYkdWdUlEMGdkV2x1ZERndWJHVnVaM1JvWEc0Z0lIWmhjaUJsZUhSeVlVSjVkR1Z6SUQwZ2JHVnVJQ1VnTXlBdkx5QnBaaUIzWlNCb1lYWmxJREVnWW5sMFpTQnNaV1owTENCd1lXUWdNaUJpZVhSbGMxeHVJQ0IyWVhJZ2IzVjBjSFYwSUQwZ0p5ZGNiaUFnZG1GeUlIQmhjblJ6SUQwZ1cxMWNiaUFnZG1GeUlHMWhlRU5vZFc1clRHVnVaM1JvSUQwZ01UWXpPRE1nTHk4Z2JYVnpkQ0JpWlNCdGRXeDBhWEJzWlNCdlppQXpYRzVjYmlBZ0x5OGdaMjhnZEdoeWIzVm5hQ0IwYUdVZ1lYSnlZWGtnWlhabGNua2dkR2h5WldVZ1lubDBaWE1zSUhkbEoyeHNJR1JsWVd3Z2QybDBhQ0IwY21GcGJHbHVaeUJ6ZEhWbVppQnNZWFJsY2x4dUlDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JHVnVNaUE5SUd4bGJpQXRJR1Y0ZEhKaFFubDBaWE03SUdrZ1BDQnNaVzR5T3lCcElDczlJRzFoZUVOb2RXNXJUR1Z1WjNSb0tTQjdYRzRnSUNBZ2NHRnlkSE11Y0hWemFDaGxibU52WkdWRGFIVnVheWgxYVc1ME9Dd2dhU3dnS0drZ0t5QnRZWGhEYUhWdWEweGxibWQwYUNrZ1BpQnNaVzR5SUQ4Z2JHVnVNaUE2SUNocElDc2diV0Y0UTJoMWJtdE1aVzVuZEdncEtTbGNiaUFnZlZ4dVhHNGdJQzh2SUhCaFpDQjBhR1VnWlc1a0lIZHBkR2dnZW1WeWIzTXNJR0oxZENCdFlXdGxJSE4xY21VZ2RHOGdibTkwSUdadmNtZGxkQ0IwYUdVZ1pYaDBjbUVnWW5sMFpYTmNiaUFnYVdZZ0tHVjRkSEpoUW5sMFpYTWdQVDA5SURFcElIdGNiaUFnSUNCMGJYQWdQU0IxYVc1ME9GdHNaVzRnTFNBeFhWeHVJQ0FnSUc5MWRIQjFkQ0FyUFNCc2IyOXJkWEJiZEcxd0lENCtJREpkWEc0Z0lDQWdiM1YwY0hWMElDczlJR3h2YjJ0MWNGc29kRzF3SUR3OElEUXBJQ1lnTUhnelJsMWNiaUFnSUNCdmRYUndkWFFnS3owZ0p6MDlKMXh1SUNCOUlHVnNjMlVnYVdZZ0tHVjRkSEpoUW5sMFpYTWdQVDA5SURJcElIdGNiaUFnSUNCMGJYQWdQU0FvZFdsdWREaGJiR1Z1SUMwZ01sMGdQRHdnT0NrZ0t5QW9kV2x1ZERoYmJHVnVJQzBnTVYwcFhHNGdJQ0FnYjNWMGNIVjBJQ3M5SUd4dmIydDFjRnQwYlhBZ1BqNGdNVEJkWEc0Z0lDQWdiM1YwY0hWMElDczlJR3h2YjJ0MWNGc29kRzF3SUQ0K0lEUXBJQ1lnTUhnelJsMWNiaUFnSUNCdmRYUndkWFFnS3owZ2JHOXZhM1Z3V3loMGJYQWdQRHdnTWlrZ0ppQXdlRE5HWFZ4dUlDQWdJRzkxZEhCMWRDQXJQU0FuUFNkY2JpQWdmVnh1WEc0Z0lIQmhjblJ6TG5CMWMyZ29iM1YwY0hWMEtWeHVYRzRnSUhKbGRIVnliaUJ3WVhKMGN5NXFiMmx1S0NjbktWeHVmVnh1SWl3aUx5b2hYRzRnS2lCVWFHVWdZblZtWm1WeUlHMXZaSFZzWlNCbWNtOXRJRzV2WkdVdWFuTXNJR1p2Y2lCMGFHVWdZbkp2ZDNObGNpNWNiaUFxWEc0Z0tpQkFZWFYwYUc5eUlDQWdSbVZ5YjNOeklFRmliM1ZyYUdGa2FXcGxhQ0E4YUhSMGNITTZMeTltWlhKdmMzTXViM0puUGx4dUlDb2dRR3hwWTJWdWMyVWdJRTFKVkZ4dUlDb3ZYRzR2S2lCbGMyeHBiblF0WkdsellXSnNaU0J1Ynkxd2NtOTBieUFxTDF4dVhHNG5kWE5sSUhOMGNtbGpkQ2RjYmx4dWRtRnlJR0poYzJVMk5DQTlJSEpsY1hWcGNtVW9KMkpoYzJVMk5DMXFjeWNwWEc1MllYSWdhV1ZsWlRjMU5DQTlJSEpsY1hWcGNtVW9KMmxsWldVM05UUW5LVnh1WEc1bGVIQnZjblJ6TGtKMVptWmxjaUE5SUVKMVptWmxjbHh1Wlhod2IzSjBjeTVUYkc5M1FuVm1abVZ5SUQwZ1UyeHZkMEoxWm1abGNseHVaWGh3YjNKMGN5NUpUbE5RUlVOVVgwMUJXRjlDV1ZSRlV5QTlJRFV3WEc1Y2JuWmhjaUJMWDAxQldGOU1SVTVIVkVnZ1BTQXdlRGRtWm1abVptWm1YRzVsZUhCdmNuUnpMbXROWVhoTVpXNW5kR2dnUFNCTFgwMUJXRjlNUlU1SFZFaGNibHh1THlvcVhHNGdLaUJKWmlCZ1FuVm1abVZ5TGxSWlVFVkVYMEZTVWtGWlgxTlZVRkJQVWxSZ09seHVJQ29nSUNBOVBUMGdkSEoxWlNBZ0lDQlZjMlVnVldsdWREaEJjbkpoZVNCcGJYQnNaVzFsYm5SaGRHbHZiaUFvWm1GemRHVnpkQ2xjYmlBcUlDQWdQVDA5SUdaaGJITmxJQ0FnVUhKcGJuUWdkMkZ5Ym1sdVp5QmhibVFnY21WamIyMXRaVzVrSUhWemFXNW5JR0JpZFdabVpYSmdJSFkwTG5nZ2QyaHBZMmdnYUdGeklHRnVJRTlpYW1WamRGeHVJQ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBiWEJzWlcxbGJuUmhkR2x2YmlBb2JXOXpkQ0JqYjIxd1lYUnBZbXhsTENCbGRtVnVJRWxGTmlsY2JpQXFYRzRnS2lCQ2NtOTNjMlZ5Y3lCMGFHRjBJSE4xY0hCdmNuUWdkSGx3WldRZ1lYSnlZWGx6SUdGeVpTQkpSU0F4TUNzc0lFWnBjbVZtYjNnZ05Dc3NJRU5vY205dFpTQTNLeXdnVTJGbVlYSnBJRFV1TVNzc1hHNGdLaUJQY0dWeVlTQXhNUzQyS3l3Z2FVOVRJRFF1TWlzdVhHNGdLbHh1SUNvZ1YyVWdjbVZ3YjNKMElIUm9ZWFFnZEdobElHSnliM2R6WlhJZ1pHOWxjeUJ1YjNRZ2MzVndjRzl5ZENCMGVYQmxaQ0JoY25KaGVYTWdhV1lnZEdobElHRnlaU0J1YjNRZ2MzVmlZMnhoYzNOaFlteGxYRzRnS2lCMWMybHVaeUJmWDNCeWIzUnZYMTh1SUVacGNtVm1iM2dnTkMweU9TQnNZV05yY3lCemRYQndiM0owSUdadmNpQmhaR1JwYm1jZ2JtVjNJSEJ5YjNCbGNuUnBaWE1nZEc4Z1lGVnBiblE0UVhKeVlYbGdYRzRnS2lBb1UyVmxPaUJvZEhSd2N6b3ZMMkoxWjNwcGJHeGhMbTF2ZW1sc2JHRXViM0puTDNOb2IzZGZZblZuTG1ObmFUOXBaRDAyT1RVME16Z3BMaUJKUlNBeE1DQnNZV05yY3lCemRYQndiM0owWEc0Z0tpQm1iM0lnWDE5d2NtOTBiMTlmSUdGdVpDQm9ZWE1nWVNCaWRXZG5lU0IwZVhCbFpDQmhjbkpoZVNCcGJYQnNaVzFsYm5SaGRHbHZiaTVjYmlBcUwxeHVRblZtWm1WeUxsUlpVRVZFWDBGU1VrRlpYMU5WVUZCUFVsUWdQU0IwZVhCbFpFRnljbUY1VTNWd2NHOXlkQ2dwWEc1Y2JtbG1JQ2doUW5WbVptVnlMbFJaVUVWRVgwRlNVa0ZaWDFOVlVGQlBVbFFnSmlZZ2RIbHdaVzltSUdOdmJuTnZiR1VnSVQwOUlDZDFibVJsWm1sdVpXUW5JQ1ltWEc0Z0lDQWdkSGx3Wlc5bUlHTnZibk52YkdVdVpYSnliM0lnUFQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmlBZ1kyOXVjMjlzWlM1bGNuSnZjaWhjYmlBZ0lDQW5WR2hwY3lCaWNtOTNjMlZ5SUd4aFkydHpJSFI1Y0dWa0lHRnljbUY1SUNoVmFXNTBPRUZ5Y21GNUtTQnpkWEJ3YjNKMElIZG9hV05vSUdseklISmxjWFZwY21Wa0lHSjVJQ2NnSzF4dUlDQWdJQ2RnWW5WbVptVnlZQ0IyTlM1NExpQlZjMlVnWUdKMVptWmxjbUFnZGpRdWVDQnBaaUI1YjNVZ2NtVnhkV2x5WlNCdmJHUWdZbkp2ZDNObGNpQnpkWEJ3YjNKMExpZGNiaUFnS1Z4dWZWeHVYRzVtZFc1amRHbHZiaUIwZVhCbFpFRnljbUY1VTNWd2NHOXlkQ0FvS1NCN1hHNGdJQzh2SUVOaGJpQjBlWEJsWkNCaGNuSmhlU0JwYm5OMFlXNWpaWE1nWTJGdUlHSmxJR0YxWjIxbGJuUmxaRDljYmlBZ2RISjVJSHRjYmlBZ0lDQjJZWElnWVhKeUlEMGdibVYzSUZWcGJuUTRRWEp5WVhrb01TbGNiaUFnSUNCaGNuSXVYMTl3Y205MGIxOWZJRDBnZTE5ZmNISnZkRzlmWHpvZ1ZXbHVkRGhCY25KaGVTNXdjbTkwYjNSNWNHVXNJR1p2YnpvZ1puVnVZM1JwYjI0Z0tDa2dleUJ5WlhSMWNtNGdORElnZlgxY2JpQWdJQ0J5WlhSMWNtNGdZWEp5TG1admJ5Z3BJRDA5UFNBME1seHVJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1poYkhObFhHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdZM0psWVhSbFFuVm1abVZ5SUNoc1pXNW5kR2dwSUh0Y2JpQWdhV1lnS0d4bGJtZDBhQ0ErSUV0ZlRVRllYMHhGVGtkVVNDa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlNZVzVuWlVWeWNtOXlLQ2RKYm5aaGJHbGtJSFI1Y0dWa0lHRnljbUY1SUd4bGJtZDBhQ2NwWEc0Z0lIMWNiaUFnTHk4Z1VtVjBkWEp1SUdGdUlHRjFaMjFsYm5SbFpDQmdWV2x1ZERoQmNuSmhlV0FnYVc1emRHRnVZMlZjYmlBZ2RtRnlJR0oxWmlBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0d4bGJtZDBhQ2xjYmlBZ1luVm1MbDlmY0hKdmRHOWZYeUE5SUVKMVptWmxjaTV3Y205MGIzUjVjR1ZjYmlBZ2NtVjBkWEp1SUdKMVpseHVmVnh1WEc0dktpcGNiaUFxSUZSb1pTQkNkV1ptWlhJZ1kyOXVjM1J5ZFdOMGIzSWdjbVYwZFhKdWN5QnBibk4wWVc1alpYTWdiMllnWUZWcGJuUTRRWEp5WVhsZ0lIUm9ZWFFnYUdGMlpTQjBhR1ZwY2x4dUlDb2djSEp2ZEc5MGVYQmxJR05vWVc1blpXUWdkRzhnWUVKMVptWmxjaTV3Y205MGIzUjVjR1ZnTGlCR2RYSjBhR1Z5Ylc5eVpTd2dZRUoxWm1abGNtQWdhWE1nWVNCemRXSmpiR0Z6Y3lCdlpseHVJQ29nWUZWcGJuUTRRWEp5WVhsZ0xDQnpieUIwYUdVZ2NtVjBkWEp1WldRZ2FXNXpkR0Z1WTJWeklIZHBiR3dnYUdGMlpTQmhiR3dnZEdobElHNXZaR1VnWUVKMVptWmxjbUFnYldWMGFHOWtjMXh1SUNvZ1lXNWtJSFJvWlNCZ1ZXbHVkRGhCY25KaGVXQWdiV1YwYUc5a2N5NGdVM0YxWVhKbElHSnlZV05yWlhRZ2JtOTBZWFJwYjI0Z2QyOXlhM01nWVhNZ1pYaHdaV04wWldRZ0xTMGdhWFJjYmlBcUlISmxkSFZ5Ym5NZ1lTQnphVzVuYkdVZ2IyTjBaWFF1WEc0Z0tseHVJQ29nVkdobElHQlZhVzUwT0VGeWNtRjVZQ0J3Y205MGIzUjVjR1VnY21WdFlXbHVjeUIxYm0xdlpHbG1hV1ZrTGx4dUlDb3ZYRzVjYm1aMWJtTjBhVzl1SUVKMVptWmxjaUFvWVhKbkxDQmxibU52WkdsdVowOXlUMlptYzJWMExDQnNaVzVuZEdncElIdGNiaUFnTHk4Z1EyOXRiVzl1SUdOaGMyVXVYRzRnSUdsbUlDaDBlWEJsYjJZZ1lYSm5JRDA5UFNBbmJuVnRZbVZ5SnlrZ2UxeHVJQ0FnSUdsbUlDaDBlWEJsYjJZZ1pXNWpiMlJwYm1kUGNrOW1abk5sZENBOVBUMGdKM04wY21sdVp5Y3BJSHRjYmlBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpaGNiaUFnSUNBZ0lDQWdKMGxtSUdWdVkyOWthVzVuSUdseklITndaV05wWm1sbFpDQjBhR1Z1SUhSb1pTQm1hWEp6ZENCaGNtZDFiV1Z1ZENCdGRYTjBJR0psSUdFZ2MzUnlhVzVuSjF4dUlDQWdJQ0FnS1Z4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z1lXeHNiMk5WYm5OaFptVW9ZWEpuS1Z4dUlDQjlYRzRnSUhKbGRIVnliaUJtY205dEtHRnlaeXdnWlc1amIyUnBibWRQY2s5bVpuTmxkQ3dnYkdWdVozUm9LVnh1ZlZ4dVhHNHZMeUJHYVhnZ2MzVmlZWEp5WVhrb0tTQnBiaUJGVXpJd01UWXVJRk5sWlRvZ2FIUjBjSE02THk5bmFYUm9kV0l1WTI5dEwyWmxjbTl6Y3k5aWRXWm1aWEl2Y0hWc2JDODVOMXh1YVdZZ0tIUjVjR1Z2WmlCVGVXMWliMndnSVQwOUlDZDFibVJsWm1sdVpXUW5JQ1ltSUZONWJXSnZiQzV6Y0dWamFXVnpJQ1ltWEc0Z0lDQWdRblZtWm1WeVcxTjViV0p2YkM1emNHVmphV1Z6WFNBOVBUMGdRblZtWm1WeUtTQjdYRzRnSUU5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGVTaENkV1ptWlhJc0lGTjViV0p2YkM1emNHVmphV1Z6TENCN1hHNGdJQ0FnZG1Gc2RXVTZJRzUxYkd3c1hHNGdJQ0FnWTI5dVptbG5kWEpoWW14bE9pQjBjblZsTEZ4dUlDQWdJR1Z1ZFcxbGNtRmliR1U2SUdaaGJITmxMRnh1SUNBZ0lIZHlhWFJoWW14bE9pQm1ZV3h6WlZ4dUlDQjlLVnh1ZlZ4dVhHNUNkV1ptWlhJdWNHOXZiRk5wZW1VZ1BTQTRNVGt5SUM4dklHNXZkQ0IxYzJWa0lHSjVJSFJvYVhNZ2FXMXdiR1Z0Wlc1MFlYUnBiMjVjYmx4dVpuVnVZM1JwYjI0Z1puSnZiU0FvZG1Gc2RXVXNJR1Z1WTI5a2FXNW5UM0pQWm1aelpYUXNJR3hsYm1kMGFDa2dlMXh1SUNCcFppQW9kSGx3Wlc5bUlIWmhiSFZsSUQwOVBTQW5iblZ0WW1WeUp5a2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMXdpZG1Gc2RXVmNJaUJoY21kMWJXVnVkQ0J0ZFhOMElHNXZkQ0JpWlNCaElHNTFiV0psY2ljcFhHNGdJSDFjYmx4dUlDQnBaaUFvYVhOQmNuSmhlVUoxWm1abGNpaDJZV3gxWlNrcElIdGNiaUFnSUNCeVpYUjFjbTRnWm5KdmJVRnljbUY1UW5WbVptVnlLSFpoYkhWbExDQmxibU52WkdsdVowOXlUMlptYzJWMExDQnNaVzVuZEdncFhHNGdJSDFjYmx4dUlDQnBaaUFvZEhsd1pXOW1JSFpoYkhWbElEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJSEpsZEhWeWJpQm1jbTl0VTNSeWFXNW5LSFpoYkhWbExDQmxibU52WkdsdVowOXlUMlptYzJWMEtWeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHWnliMjFQWW1wbFkzUW9kbUZzZFdVcFhHNTlYRzVjYmk4cUtseHVJQ29nUm5WdVkzUnBiMjVoYkd4NUlHVnhkV2wyWVd4bGJuUWdkRzhnUW5WbVptVnlLR0Z5Wnl3Z1pXNWpiMlJwYm1jcElHSjFkQ0IwYUhKdmQzTWdZU0JVZVhCbFJYSnliM0pjYmlBcUlHbG1JSFpoYkhWbElHbHpJR0VnYm5WdFltVnlMbHh1SUNvZ1FuVm1abVZ5TG1aeWIyMG9jM1J5V3l3Z1pXNWpiMlJwYm1kZEtWeHVJQ29nUW5WbVptVnlMbVp5YjIwb1lYSnlZWGtwWEc0Z0tpQkNkV1ptWlhJdVpuSnZiU2hpZFdabVpYSXBYRzRnS2lCQ2RXWm1aWEl1Wm5KdmJTaGhjbkpoZVVKMVptWmxjbHNzSUdKNWRHVlBabVp6WlhSYkxDQnNaVzVuZEdoZFhTbGNiaUFxS2k5Y2JrSjFabVpsY2k1bWNtOXRJRDBnWm5WdVkzUnBiMjRnS0haaGJIVmxMQ0JsYm1OdlpHbHVaMDl5VDJabWMyVjBMQ0JzWlc1bmRHZ3BJSHRjYmlBZ2NtVjBkWEp1SUdaeWIyMG9kbUZzZFdVc0lHVnVZMjlrYVc1blQzSlBabVp6WlhRc0lHeGxibWQwYUNsY2JuMWNibHh1THk4Z1RtOTBaVG9nUTJoaGJtZGxJSEJ5YjNSdmRIbHdaU0FxWVdaMFpYSXFJRUoxWm1abGNpNW1jbTl0SUdseklHUmxabWx1WldRZ2RHOGdkMjl5YTJGeWIzVnVaQ0JEYUhKdmJXVWdZblZuT2x4dUx5OGdhSFIwY0hNNkx5OW5hWFJvZFdJdVkyOXRMMlpsY205emN5OWlkV1ptWlhJdmNIVnNiQzh4TkRoY2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdVgxOXdjbTkwYjE5ZklEMGdWV2x1ZERoQmNuSmhlUzV3Y205MGIzUjVjR1ZjYmtKMVptWmxjaTVmWDNCeWIzUnZYMThnUFNCVmFXNTBPRUZ5Y21GNVhHNWNibVoxYm1OMGFXOXVJR0Z6YzJWeWRGTnBlbVVnS0hOcGVtVXBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQnphWHBsSUNFOVBTQW5iblZ0WW1WeUp5a2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMXdpYzJsNlpWd2lJR0Z5WjNWdFpXNTBJRzExYzNRZ1ltVWdZU0J1ZFcxaVpYSW5LVnh1SUNCOUlHVnNjMlVnYVdZZ0tITnBlbVVnUENBd0tTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGSmhibWRsUlhKeWIzSW9KMXdpYzJsNlpWd2lJR0Z5WjNWdFpXNTBJRzExYzNRZ2JtOTBJR0psSUc1bFoyRjBhWFpsSnlsY2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmhiR3h2WXlBb2MybDZaU3dnWm1sc2JDd2daVzVqYjJScGJtY3BJSHRjYmlBZ1lYTnpaWEowVTJsNlpTaHphWHBsS1Z4dUlDQnBaaUFvYzJsNlpTQThQU0F3S1NCN1hHNGdJQ0FnY21WMGRYSnVJR055WldGMFpVSjFabVpsY2loemFYcGxLVnh1SUNCOVhHNGdJR2xtSUNobWFXeHNJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNBdkx5QlBibXg1SUhCaGVTQmhkSFJsYm5ScGIyNGdkRzhnWlc1amIyUnBibWNnYVdZZ2FYUW5jeUJoSUhOMGNtbHVaeTRnVkdocGMxeHVJQ0FnSUM4dklIQnlaWFpsYm5SeklHRmpZMmxrWlc1MFlXeHNlU0J6Wlc1a2FXNW5JR2x1SUdFZ2JuVnRZbVZ5SUhSb1lYUWdkMjkxYkdSY2JpQWdJQ0F2THlCaVpTQnBiblJsY25CeVpYUjBaV1FnWVhNZ1lTQnpkR0Z5ZENCdlptWnpaWFF1WEc0Z0lDQWdjbVYwZFhKdUlIUjVjR1Z2WmlCbGJtTnZaR2x1WnlBOVBUMGdKM04wY21sdVp5ZGNiaUFnSUNBZ0lEOGdZM0psWVhSbFFuVm1abVZ5S0hOcGVtVXBMbVpwYkd3b1ptbHNiQ3dnWlc1amIyUnBibWNwWEc0Z0lDQWdJQ0E2SUdOeVpXRjBaVUoxWm1abGNpaHphWHBsS1M1bWFXeHNLR1pwYkd3cFhHNGdJSDFjYmlBZ2NtVjBkWEp1SUdOeVpXRjBaVUoxWm1abGNpaHphWHBsS1Z4dWZWeHVYRzR2S2lwY2JpQXFJRU55WldGMFpYTWdZU0J1WlhjZ1ptbHNiR1ZrSUVKMVptWmxjaUJwYm5OMFlXNWpaUzVjYmlBcUlHRnNiRzlqS0hOcGVtVmJMQ0JtYVd4c1d5d2daVzVqYjJScGJtZGRYU2xjYmlBcUtpOWNia0oxWm1abGNpNWhiR3h2WXlBOUlHWjFibU4wYVc5dUlDaHphWHBsTENCbWFXeHNMQ0JsYm1OdlpHbHVaeWtnZTF4dUlDQnlaWFIxY200Z1lXeHNiMk1vYzJsNlpTd2dabWxzYkN3Z1pXNWpiMlJwYm1jcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdGc2JHOWpWVzV6WVdabElDaHphWHBsS1NCN1hHNGdJR0Z6YzJWeWRGTnBlbVVvYzJsNlpTbGNiaUFnY21WMGRYSnVJR055WldGMFpVSjFabVpsY2loemFYcGxJRHdnTUNBL0lEQWdPaUJqYUdWamEyVmtLSE5wZW1VcElId2dNQ2xjYm4xY2JseHVMeW9xWEc0Z0tpQkZjWFZwZG1Gc1pXNTBJSFJ2SUVKMVptWmxjaWh1ZFcwcExDQmllU0JrWldaaGRXeDBJR055WldGMFpYTWdZU0J1YjI0dGVtVnlieTFtYVd4c1pXUWdRblZtWm1WeUlHbHVjM1JoYm1ObExseHVJQ29nS2k5Y2JrSjFabVpsY2k1aGJHeHZZMVZ1YzJGbVpTQTlJR1oxYm1OMGFXOXVJQ2h6YVhwbEtTQjdYRzRnSUhKbGRIVnliaUJoYkd4dlkxVnVjMkZtWlNoemFYcGxLVnh1ZlZ4dUx5b3FYRzRnS2lCRmNYVnBkbUZzWlc1MElIUnZJRk5zYjNkQ2RXWm1aWElvYm5WdEtTd2dZbmtnWkdWbVlYVnNkQ0JqY21WaGRHVnpJR0VnYm05dUxYcGxjbTh0Wm1sc2JHVmtJRUoxWm1abGNpQnBibk4wWVc1alpTNWNiaUFxTDF4dVFuVm1abVZ5TG1Gc2JHOWpWVzV6WVdabFUyeHZkeUE5SUdaMWJtTjBhVzl1SUNoemFYcGxLU0I3WEc0Z0lISmxkSFZ5YmlCaGJHeHZZMVZ1YzJGbVpTaHphWHBsS1Z4dWZWeHVYRzVtZFc1amRHbHZiaUJtY205dFUzUnlhVzVuSUNoemRISnBibWNzSUdWdVkyOWthVzVuS1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnWlc1amIyUnBibWNnSVQwOUlDZHpkSEpwYm1jbklIeDhJR1Z1WTI5a2FXNW5JRDA5UFNBbkp5a2dlMXh1SUNBZ0lHVnVZMjlrYVc1bklEMGdKM1YwWmpnblhHNGdJSDFjYmx4dUlDQnBaaUFvSVVKMVptWmxjaTVwYzBWdVkyOWthVzVuS0dWdVkyOWthVzVuS1NrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0oxd2laVzVqYjJScGJtZGNJaUJ0ZFhOMElHSmxJR0VnZG1Gc2FXUWdjM1J5YVc1bklHVnVZMjlrYVc1bkp5bGNiaUFnZlZ4dVhHNGdJSFpoY2lCc1pXNW5kR2dnUFNCaWVYUmxUR1Z1WjNSb0tITjBjbWx1Wnl3Z1pXNWpiMlJwYm1jcElId2dNRnh1SUNCMllYSWdZblZtSUQwZ1kzSmxZWFJsUW5WbVptVnlLR3hsYm1kMGFDbGNibHh1SUNCMllYSWdZV04wZFdGc0lEMGdZblZtTG5keWFYUmxLSE4wY21sdVp5d2daVzVqYjJScGJtY3BYRzVjYmlBZ2FXWWdLR0ZqZEhWaGJDQWhQVDBnYkdWdVozUm9LU0I3WEc0Z0lDQWdMeThnVjNKcGRHbHVaeUJoSUdobGVDQnpkSEpwYm1jc0lHWnZjaUJsZUdGdGNHeGxMQ0IwYUdGMElHTnZiblJoYVc1eklHbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeWN5QjNhV3hzWEc0Z0lDQWdMeThnWTJGMWMyVWdaWFpsY25sMGFHbHVaeUJoWm5SbGNpQjBhR1VnWm1seWMzUWdhVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdkRzhnWW1VZ2FXZHViM0psWkM0Z0tHVXVaeTVjYmlBZ0lDQXZMeUFuWVdKNGVHTmtKeUIzYVd4c0lHSmxJSFJ5WldGMFpXUWdZWE1nSjJGaUp5bGNiaUFnSUNCaWRXWWdQU0JpZFdZdWMyeHBZMlVvTUN3Z1lXTjBkV0ZzS1Z4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdKMVpseHVmVnh1WEc1bWRXNWpkR2x2YmlCbWNtOXRRWEp5WVhsTWFXdGxJQ2hoY25KaGVTa2dlMXh1SUNCMllYSWdiR1Z1WjNSb0lEMGdZWEp5WVhrdWJHVnVaM1JvSUR3Z01DQS9JREFnT2lCamFHVmphMlZrS0dGeWNtRjVMbXhsYm1kMGFDa2dmQ0F3WEc0Z0lIWmhjaUJpZFdZZ1BTQmpjbVZoZEdWQ2RXWm1aWElvYkdWdVozUm9LVnh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxibWQwYURzZ2FTQXJQU0F4S1NCN1hHNGdJQ0FnWW5WbVcybGRJRDBnWVhKeVlYbGJhVjBnSmlBeU5UVmNiaUFnZlZ4dUlDQnlaWFIxY200Z1luVm1YRzU5WEc1Y2JtWjFibU4wYVc5dUlHWnliMjFCY25KaGVVSjFabVpsY2lBb1lYSnlZWGtzSUdKNWRHVlBabVp6WlhRc0lHeGxibWQwYUNrZ2UxeHVJQ0JwWmlBb1lubDBaVTltWm5ObGRDQThJREFnZkh3Z1lYSnlZWGt1WW5sMFpVeGxibWQwYUNBOElHSjVkR1ZQWm1aelpYUXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dVbUZ1WjJWRmNuSnZjaWduWEZ3bmIyWm1jMlYwWEZ3bklHbHpJRzkxZENCdlppQmliM1Z1WkhNbktWeHVJQ0I5WEc1Y2JpQWdhV1lnS0dGeWNtRjVMbUo1ZEdWTVpXNW5kR2dnUENCaWVYUmxUMlptYzJWMElDc2dLR3hsYm1kMGFDQjhmQ0F3S1NrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCU1lXNW5aVVZ5Y205eUtDZGNYQ2RzWlc1bmRHaGNYQ2NnYVhNZ2IzVjBJRzltSUdKdmRXNWtjeWNwWEc0Z0lIMWNibHh1SUNCMllYSWdZblZtWEc0Z0lHbG1JQ2hpZVhSbFQyWm1jMlYwSUQwOVBTQjFibVJsWm1sdVpXUWdKaVlnYkdWdVozUm9JRDA5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNCaWRXWWdQU0J1WlhjZ1ZXbHVkRGhCY25KaGVTaGhjbkpoZVNsY2JpQWdmU0JsYkhObElHbG1JQ2hzWlc1bmRHZ2dQVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUdKMVppQTlJRzVsZHlCVmFXNTBPRUZ5Y21GNUtHRnljbUY1TENCaWVYUmxUMlptYzJWMEtWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHSjFaaUE5SUc1bGR5QlZhVzUwT0VGeWNtRjVLR0Z5Y21GNUxDQmllWFJsVDJabWMyVjBMQ0JzWlc1bmRHZ3BYRzRnSUgxY2JseHVJQ0F2THlCU1pYUjFjbTRnWVc0Z1lYVm5iV1Z1ZEdWa0lHQlZhVzUwT0VGeWNtRjVZQ0JwYm5OMFlXNWpaVnh1SUNCaWRXWXVYMTl3Y205MGIxOWZJRDBnUW5WbVptVnlMbkJ5YjNSdmRIbHdaVnh1SUNCeVpYUjFjbTRnWW5WbVhHNTlYRzVjYm1aMWJtTjBhVzl1SUdaeWIyMVBZbXBsWTNRZ0tHOWlhaWtnZTF4dUlDQnBaaUFvUW5WbVptVnlMbWx6UW5WbVptVnlLRzlpYWlrcElIdGNiaUFnSUNCMllYSWdiR1Z1SUQwZ1kyaGxZMnRsWkNodlltb3ViR1Z1WjNSb0tTQjhJREJjYmlBZ0lDQjJZWElnWW5WbUlEMGdZM0psWVhSbFFuVm1abVZ5S0d4bGJpbGNibHh1SUNBZ0lHbG1JQ2hpZFdZdWJHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdZblZtWEc0Z0lDQWdmVnh1WEc0Z0lDQWdiMkpxTG1OdmNIa29ZblZtTENBd0xDQXdMQ0JzWlc0cFhHNGdJQ0FnY21WMGRYSnVJR0oxWmx4dUlDQjlYRzVjYmlBZ2FXWWdLRzlpYWlrZ2UxeHVJQ0FnSUdsbUlDaHBjMEZ5Y21GNVFuVm1abVZ5Vm1sbGR5aHZZbW9wSUh4OElDZHNaVzVuZEdnbklHbHVJRzlpYWlrZ2UxeHVJQ0FnSUNBZ2FXWWdLSFI1Y0dWdlppQnZZbW91YkdWdVozUm9JQ0U5UFNBbmJuVnRZbVZ5SnlCOGZDQnVkVzFpWlhKSmMwNWhUaWh2WW1vdWJHVnVaM1JvS1NrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1kzSmxZWFJsUW5WbVptVnlLREFwWEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabkp2YlVGeWNtRjVUR2xyWlNodlltb3BYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLRzlpYWk1MGVYQmxJRDA5UFNBblFuVm1abVZ5SnlBbUppQkJjbkpoZVM1cGMwRnljbUY1S0c5aWFpNWtZWFJoS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdaeWIyMUJjbkpoZVV4cGEyVW9iMkpxTG1SaGRHRXBYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWduUm1seWMzUWdZWEpuZFcxbGJuUWdiWFZ6ZENCaVpTQmhJSE4wY21sdVp5d2dRblZtWm1WeUxDQkJjbkpoZVVKMVptWmxjaXdnUVhKeVlYa3NJRzl5SUdGeWNtRjVMV3hwYTJVZ2IySnFaV04wTGljcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdOb1pXTnJaV1FnS0d4bGJtZDBhQ2tnZTF4dUlDQXZMeUJPYjNSbE9pQmpZVzV1YjNRZ2RYTmxJR0JzWlc1bmRHZ2dQQ0JMWDAxQldGOU1SVTVIVkVoZ0lHaGxjbVVnWW1WallYVnpaU0IwYUdGMElHWmhhV3h6SUhkb1pXNWNiaUFnTHk4Z2JHVnVaM1JvSUdseklFNWhUaUFvZDJocFkyZ2dhWE1nYjNSb1pYSjNhWE5sSUdOdlpYSmpaV1FnZEc4Z2VtVnlieTRwWEc0Z0lHbG1JQ2hzWlc1bmRHZ2dQajBnUzE5TlFWaGZURVZPUjFSSUtTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGSmhibWRsUlhKeWIzSW9KMEYwZEdWdGNIUWdkRzhnWVd4c2IyTmhkR1VnUW5WbVptVnlJR3hoY21kbGNpQjBhR0Z1SUcxaGVHbHRkVzBnSnlBclhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0ozTnBlbVU2SURCNEp5QXJJRXRmVFVGWVgweEZUa2RVU0M1MGIxTjBjbWx1WnlneE5pa2dLeUFuSUdKNWRHVnpKeWxjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdiR1Z1WjNSb0lId2dNRnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQlRiRzkzUW5WbVptVnlJQ2hzWlc1bmRHZ3BJSHRjYmlBZ2FXWWdLQ3RzWlc1bmRHZ2dJVDBnYkdWdVozUm9LU0I3SUM4dklHVnpiR2x1ZEMxa2FYTmhZbXhsTFd4cGJtVWdaWEZsY1dWeFhHNGdJQ0FnYkdWdVozUm9JRDBnTUZ4dUlDQjlYRzRnSUhKbGRIVnliaUJDZFdabVpYSXVZV3hzYjJNb0syeGxibWQwYUNsY2JuMWNibHh1UW5WbVptVnlMbWx6UW5WbVptVnlJRDBnWm5WdVkzUnBiMjRnYVhOQ2RXWm1aWElnS0dJcElIdGNiaUFnY21WMGRYSnVJR0lnSVQwZ2JuVnNiQ0FtSmlCaUxsOXBjMEoxWm1abGNpQTlQVDBnZEhKMVpWeHVmVnh1WEc1Q2RXWm1aWEl1WTI5dGNHRnlaU0E5SUdaMWJtTjBhVzl1SUdOdmJYQmhjbVVnS0dFc0lHSXBJSHRjYmlBZ2FXWWdLQ0ZDZFdabVpYSXVhWE5DZFdabVpYSW9ZU2tnZkh3Z0lVSjFabVpsY2k1cGMwSjFabVpsY2loaUtTa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMEZ5WjNWdFpXNTBjeUJ0ZFhOMElHSmxJRUoxWm1abGNuTW5LVnh1SUNCOVhHNWNiaUFnYVdZZ0tHRWdQVDA5SUdJcElISmxkSFZ5YmlBd1hHNWNiaUFnZG1GeUlIZ2dQU0JoTG14bGJtZDBhRnh1SUNCMllYSWdlU0E5SUdJdWJHVnVaM1JvWEc1Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBc0lHeGxiaUE5SUUxaGRHZ3ViV2x1S0hnc0lIa3BPeUJwSUR3Z2JHVnVPeUFySzJrcElIdGNiaUFnSUNCcFppQW9ZVnRwWFNBaFBUMGdZbHRwWFNrZ2UxeHVJQ0FnSUNBZ2VDQTlJR0ZiYVYxY2JpQWdJQ0FnSUhrZ1BTQmlXMmxkWEc0Z0lDQWdJQ0JpY21WaGExeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHbG1JQ2g0SUR3Z2VTa2djbVYwZFhKdUlDMHhYRzRnSUdsbUlDaDVJRHdnZUNrZ2NtVjBkWEp1SURGY2JpQWdjbVYwZFhKdUlEQmNibjFjYmx4dVFuVm1abVZ5TG1selJXNWpiMlJwYm1jZ1BTQm1kVzVqZEdsdmJpQnBjMFZ1WTI5a2FXNW5JQ2hsYm1OdlpHbHVaeWtnZTF4dUlDQnpkMmwwWTJnZ0tGTjBjbWx1WnlobGJtTnZaR2x1WnlrdWRHOU1iM2RsY2tOaGMyVW9LU2tnZTF4dUlDQWdJR05oYzJVZ0oyaGxlQ2M2WEc0Z0lDQWdZMkZ6WlNBbmRYUm1PQ2M2WEc0Z0lDQWdZMkZ6WlNBbmRYUm1MVGduT2x4dUlDQWdJR05oYzJVZ0oyRnpZMmxwSnpwY2JpQWdJQ0JqWVhObElDZHNZWFJwYmpFbk9seHVJQ0FnSUdOaGMyVWdKMkpwYm1GeWVTYzZYRzRnSUNBZ1kyRnpaU0FuWW1GelpUWTBKenBjYmlBZ0lDQmpZWE5sSUNkMVkzTXlKenBjYmlBZ0lDQmpZWE5sSUNkMVkzTXRNaWM2WEc0Z0lDQWdZMkZ6WlNBbmRYUm1NVFpzWlNjNlhHNGdJQ0FnWTJGelpTQW5kWFJtTFRFMmJHVW5PbHh1SUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1ZjYmlBZ0lDQmtaV1poZFd4ME9seHVJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxYRzRnSUgxY2JuMWNibHh1UW5WbVptVnlMbU52Ym1OaGRDQTlJR1oxYm1OMGFXOXVJR052Ym1OaGRDQW9iR2x6ZEN3Z2JHVnVaM1JvS1NCN1hHNGdJR2xtSUNnaFFYSnlZWGt1YVhOQmNuSmhlU2hzYVhOMEtTa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMXdpYkdsemRGd2lJR0Z5WjNWdFpXNTBJRzExYzNRZ1ltVWdZVzRnUVhKeVlYa2diMllnUW5WbVptVnljeWNwWEc0Z0lIMWNibHh1SUNCcFppQW9iR2x6ZEM1c1pXNW5kR2dnUFQwOUlEQXBJSHRjYmlBZ0lDQnlaWFIxY200Z1FuVm1abVZ5TG1Gc2JHOWpLREFwWEc0Z0lIMWNibHh1SUNCMllYSWdhVnh1SUNCcFppQW9iR1Z1WjNSb0lEMDlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0JzWlc1bmRHZ2dQU0F3WEc0Z0lDQWdabTl5SUNocElEMGdNRHNnYVNBOElHeHBjM1F1YkdWdVozUm9PeUFySzJrcElIdGNiaUFnSUNBZ0lHeGxibWQwYUNBclBTQnNhWE4wVzJsZExteGxibWQwYUZ4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhaaGNpQmlkV1ptWlhJZ1BTQkNkV1ptWlhJdVlXeHNiMk5WYm5OaFptVW9iR1Z1WjNSb0tWeHVJQ0IyWVhJZ2NHOXpJRDBnTUZ4dUlDQm1iM0lnS0drZ1BTQXdPeUJwSUR3Z2JHbHpkQzVzWlc1bmRHZzdJQ3NyYVNrZ2UxeHVJQ0FnSUhaaGNpQmlkV1lnUFNCc2FYTjBXMmxkWEc0Z0lDQWdhV1lnS0NGQ2RXWm1aWEl1YVhOQ2RXWm1aWElvWW5WbUtTa2dlMXh1SUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWduWENKc2FYTjBYQ0lnWVhKbmRXMWxiblFnYlhWemRDQmlaU0JoYmlCQmNuSmhlU0J2WmlCQ2RXWm1aWEp6SnlsY2JpQWdJQ0I5WEc0Z0lDQWdZblZtTG1OdmNIa29ZblZtWm1WeUxDQndiM01wWEc0Z0lDQWdjRzl6SUNzOUlHSjFaaTVzWlc1bmRHaGNiaUFnZlZ4dUlDQnlaWFIxY200Z1luVm1abVZ5WEc1OVhHNWNibVoxYm1OMGFXOXVJR0o1ZEdWTVpXNW5kR2dnS0hOMGNtbHVaeXdnWlc1amIyUnBibWNwSUh0Y2JpQWdhV1lnS0VKMVptWmxjaTVwYzBKMVptWmxjaWh6ZEhKcGJtY3BLU0I3WEc0Z0lDQWdjbVYwZFhKdUlITjBjbWx1Wnk1c1pXNW5kR2hjYmlBZ2ZWeHVJQ0JwWmlBb2FYTkJjbkpoZVVKMVptWmxjbFpwWlhjb2MzUnlhVzVuS1NCOGZDQnBjMEZ5Y21GNVFuVm1abVZ5S0hOMGNtbHVaeWtwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdjM1J5YVc1bkxtSjVkR1ZNWlc1bmRHaGNiaUFnZlZ4dUlDQnBaaUFvZEhsd1pXOW1JSE4wY21sdVp5QWhQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0J6ZEhKcGJtY2dQU0FuSnlBcklITjBjbWx1WjF4dUlDQjlYRzVjYmlBZ2RtRnlJR3hsYmlBOUlITjBjbWx1Wnk1c1pXNW5kR2hjYmlBZ2FXWWdLR3hsYmlBOVBUMGdNQ2tnY21WMGRYSnVJREJjYmx4dUlDQXZMeUJWYzJVZ1lTQm1iM0lnYkc5dmNDQjBieUJoZG05cFpDQnlaV04xY25OcGIyNWNiaUFnZG1GeUlHeHZkMlZ5WldSRFlYTmxJRDBnWm1Gc2MyVmNiaUFnWm05eUlDZzdPeWtnZTF4dUlDQWdJSE4zYVhSamFDQW9aVzVqYjJScGJtY3BJSHRjYmlBZ0lDQWdJR05oYzJVZ0oyRnpZMmxwSnpwY2JpQWdJQ0FnSUdOaGMyVWdKMnhoZEdsdU1TYzZYRzRnSUNBZ0lDQmpZWE5sSUNkaWFXNWhjbmtuT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYkdWdVhHNGdJQ0FnSUNCallYTmxJQ2QxZEdZNEp6cGNiaUFnSUNBZ0lHTmhjMlVnSjNWMFppMDRKenBjYmlBZ0lDQWdJR05oYzJVZ2RXNWtaV1pwYm1Wa09seHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RYUm1PRlJ2UW5sMFpYTW9jM1J5YVc1bktTNXNaVzVuZEdoY2JpQWdJQ0FnSUdOaGMyVWdKM1ZqY3pJbk9seHVJQ0FnSUNBZ1kyRnpaU0FuZFdOekxUSW5PbHh1SUNBZ0lDQWdZMkZ6WlNBbmRYUm1NVFpzWlNjNlhHNGdJQ0FnSUNCallYTmxJQ2QxZEdZdE1UWnNaU2M2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJzWlc0Z0tpQXlYRzRnSUNBZ0lDQmpZWE5sSUNkb1pYZ25PbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiR1Z1SUQ0K1BpQXhYRzRnSUNBZ0lDQmpZWE5sSUNkaVlYTmxOalFuT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWW1GelpUWTBWRzlDZVhSbGN5aHpkSEpwYm1jcExteGxibWQwYUZ4dUlDQWdJQ0FnWkdWbVlYVnNkRHBjYmlBZ0lDQWdJQ0FnYVdZZ0tHeHZkMlZ5WldSRFlYTmxLU0J5WlhSMWNtNGdkWFJtT0ZSdlFubDBaWE1vYzNSeWFXNW5LUzVzWlc1bmRHZ2dMeThnWVhOemRXMWxJSFYwWmpoY2JpQWdJQ0FnSUNBZ1pXNWpiMlJwYm1jZ1BTQW9KeWNnS3lCbGJtTnZaR2x1WnlrdWRHOU1iM2RsY2tOaGMyVW9LVnh1SUNBZ0lDQWdJQ0JzYjNkbGNtVmtRMkZ6WlNBOUlIUnlkV1ZjYmlBZ0lDQjlYRzRnSUgxY2JuMWNia0oxWm1abGNpNWllWFJsVEdWdVozUm9JRDBnWW5sMFpVeGxibWQwYUZ4dVhHNW1kVzVqZEdsdmJpQnpiRzkzVkc5VGRISnBibWNnS0dWdVkyOWthVzVuTENCemRHRnlkQ3dnWlc1a0tTQjdYRzRnSUhaaGNpQnNiM2RsY21Wa1EyRnpaU0E5SUdaaGJITmxYRzVjYmlBZ0x5OGdUbThnYm1WbFpDQjBieUIyWlhKcFpua2dkR2hoZENCY0luUm9hWE11YkdWdVozUm9JRHc5SUUxQldGOVZTVTVVTXpKY0lpQnphVzVqWlNCcGRDZHpJR0VnY21WaFpDMXZibXg1WEc0Z0lDOHZJSEJ5YjNCbGNuUjVJRzltSUdFZ2RIbHdaV1FnWVhKeVlYa3VYRzVjYmlBZ0x5OGdWR2hwY3lCaVpXaGhkbVZ6SUc1bGFYUm9aWElnYkdsclpTQlRkSEpwYm1jZ2JtOXlJRlZwYm5RNFFYSnlZWGtnYVc0Z2RHaGhkQ0IzWlNCelpYUWdjM1JoY25RdlpXNWtYRzRnSUM4dklIUnZJSFJvWldseUlIVndjR1Z5TDJ4dmQyVnlJR0p2ZFc1a2N5QnBaaUIwYUdVZ2RtRnNkV1VnY0dGemMyVmtJR2x6SUc5MWRDQnZaaUJ5WVc1blpTNWNiaUFnTHk4Z2RXNWtaV1pwYm1Wa0lHbHpJR2hoYm1Sc1pXUWdjM0JsWTJsaGJHeDVJR0Z6SUhCbGNpQkZRMDFCTFRJMk1pQTJkR2dnUldScGRHbHZiaXhjYmlBZ0x5OGdVMlZqZEdsdmJpQXhNeTR6TGpNdU55QlNkVzUwYVcxbElGTmxiV0Z1ZEdsamN6b2dTMlY1WldSQ2FXNWthVzVuU1c1cGRHbGhiR2w2WVhScGIyNHVYRzRnSUdsbUlDaHpkR0Z5ZENBOVBUMGdkVzVrWldacGJtVmtJSHg4SUhOMFlYSjBJRHdnTUNrZ2UxeHVJQ0FnSUhOMFlYSjBJRDBnTUZ4dUlDQjlYRzRnSUM4dklGSmxkSFZ5YmlCbFlYSnNlU0JwWmlCemRHRnlkQ0ErSUhSb2FYTXViR1Z1WjNSb0xpQkViMjVsSUdobGNtVWdkRzhnY0hKbGRtVnVkQ0J3YjNSbGJuUnBZV3dnZFdsdWRETXlYRzRnSUM4dklHTnZaWEpqYVc5dUlHWmhhV3dnWW1Wc2IzY3VYRzRnSUdsbUlDaHpkR0Z5ZENBK0lIUm9hWE11YkdWdVozUm9LU0I3WEc0Z0lDQWdjbVYwZFhKdUlDY25YRzRnSUgxY2JseHVJQ0JwWmlBb1pXNWtJRDA5UFNCMWJtUmxabWx1WldRZ2ZId2daVzVrSUQ0Z2RHaHBjeTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQmxibVFnUFNCMGFHbHpMbXhsYm1kMGFGeHVJQ0I5WEc1Y2JpQWdhV1lnS0dWdVpDQThQU0F3S1NCN1hHNGdJQ0FnY21WMGRYSnVJQ2NuWEc0Z0lIMWNibHh1SUNBdkx5QkdiM0pqWlNCamIyVnljMmx2YmlCMGJ5QjFhVzUwTXpJdUlGUm9hWE1nZDJsc2JDQmhiSE52SUdOdlpYSmpaU0JtWVd4elpYa3ZUbUZPSUhaaGJIVmxjeUIwYnlBd0xseHVJQ0JsYm1RZ1BqNCtQU0F3WEc0Z0lITjBZWEowSUQ0K1BqMGdNRnh1WEc0Z0lHbG1JQ2hsYm1RZ1BEMGdjM1JoY25RcElIdGNiaUFnSUNCeVpYUjFjbTRnSnlkY2JpQWdmVnh1WEc0Z0lHbG1JQ2doWlc1amIyUnBibWNwSUdWdVkyOWthVzVuSUQwZ0ozVjBaamduWEc1Y2JpQWdkMmhwYkdVZ0tIUnlkV1VwSUh0Y2JpQWdJQ0J6ZDJsMFkyZ2dLR1Z1WTI5a2FXNW5LU0I3WEc0Z0lDQWdJQ0JqWVhObElDZG9aWGduT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYUdWNFUyeHBZMlVvZEdocGN5d2djM1JoY25Rc0lHVnVaQ2xjYmx4dUlDQWdJQ0FnWTJGelpTQW5kWFJtT0NjNlhHNGdJQ0FnSUNCallYTmxJQ2QxZEdZdE9DYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjFkR1k0VTJ4cFkyVW9kR2hwY3l3Z2MzUmhjblFzSUdWdVpDbGNibHh1SUNBZ0lDQWdZMkZ6WlNBbllYTmphV2tuT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWVhOamFXbFRiR2xqWlNoMGFHbHpMQ0J6ZEdGeWRDd2daVzVrS1Z4dVhHNGdJQ0FnSUNCallYTmxJQ2RzWVhScGJqRW5PbHh1SUNBZ0lDQWdZMkZ6WlNBblltbHVZWEo1SnpwY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUd4aGRHbHVNVk5zYVdObEtIUm9hWE1zSUhOMFlYSjBMQ0JsYm1RcFhHNWNiaUFnSUNBZ0lHTmhjMlVnSjJKaGMyVTJOQ2M2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJpWVhObE5qUlRiR2xqWlNoMGFHbHpMQ0J6ZEdGeWRDd2daVzVrS1Z4dVhHNGdJQ0FnSUNCallYTmxJQ2QxWTNNeUp6cGNiaUFnSUNBZ0lHTmhjMlVnSjNWamN5MHlKenBjYmlBZ0lDQWdJR05oYzJVZ0ozVjBaakUyYkdVbk9seHVJQ0FnSUNBZ1kyRnpaU0FuZFhSbUxURTJiR1VuT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZFhSbU1UWnNaVk5zYVdObEtIUm9hWE1zSUhOMFlYSjBMQ0JsYm1RcFhHNWNiaUFnSUNBZ0lHUmxabUYxYkhRNlhHNGdJQ0FnSUNBZ0lHbG1JQ2hzYjNkbGNtVmtRMkZ6WlNrZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpZ25WVzVyYm05M2JpQmxibU52WkdsdVp6b2dKeUFySUdWdVkyOWthVzVuS1Z4dUlDQWdJQ0FnSUNCbGJtTnZaR2x1WnlBOUlDaGxibU52WkdsdVp5QXJJQ2NuS1M1MGIweHZkMlZ5UTJGelpTZ3BYRzRnSUNBZ0lDQWdJR3h2ZDJWeVpXUkRZWE5sSUQwZ2RISjFaVnh1SUNBZ0lIMWNiaUFnZlZ4dWZWeHVYRzR2THlCVWFHbHpJSEJ5YjNCbGNuUjVJR2x6SUhWelpXUWdZbmtnWUVKMVptWmxjaTVwYzBKMVptWmxjbUFnS0dGdVpDQjBhR1VnWUdsekxXSjFabVpsY21BZ2JuQnRJSEJoWTJ0aFoyVXBYRzR2THlCMGJ5QmtaWFJsWTNRZ1lTQkNkV1ptWlhJZ2FXNXpkR0Z1WTJVdUlFbDBKM01nYm05MElIQnZjM05wWW14bElIUnZJSFZ6WlNCZ2FXNXpkR0Z1WTJWdlppQkNkV1ptWlhKZ1hHNHZMeUJ5Wld4cFlXSnNlU0JwYmlCaElHSnliM2R6WlhKcFpua2dZMjl1ZEdWNGRDQmlaV05oZFhObElIUm9aWEpsSUdOdmRXeGtJR0psSUcxMWJIUnBjR3hsSUdScFptWmxjbVZ1ZEZ4dUx5OGdZMjl3YVdWeklHOW1JSFJvWlNBblluVm1abVZ5SnlCd1lXTnJZV2RsSUdsdUlIVnpaUzRnVkdocGN5QnRaWFJvYjJRZ2QyOXlhM01nWlhabGJpQm1iM0lnUW5WbVptVnlYRzR2THlCcGJuTjBZVzVqWlhNZ2RHaGhkQ0IzWlhKbElHTnlaV0YwWldRZ1puSnZiU0JoYm05MGFHVnlJR052Y0hrZ2IyWWdkR2hsSUdCaWRXWm1aWEpnSUhCaFkydGhaMlV1WEc0dkx5QlRaV1U2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5bVpYSnZjM012WW5WbVptVnlMMmx6YzNWbGN5OHhOVFJjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1WDJselFuVm1abVZ5SUQwZ2RISjFaVnh1WEc1bWRXNWpkR2x2YmlCemQyRndJQ2hpTENCdUxDQnRLU0I3WEc0Z0lIWmhjaUJwSUQwZ1lsdHVYVnh1SUNCaVcyNWRJRDBnWWx0dFhWeHVJQ0JpVzIxZElEMGdhVnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuTjNZWEF4TmlBOUlHWjFibU4wYVc5dUlITjNZWEF4TmlBb0tTQjdYRzRnSUhaaGNpQnNaVzRnUFNCMGFHbHpMbXhsYm1kMGFGeHVJQ0JwWmlBb2JHVnVJQ1VnTWlBaFBUMGdNQ2tnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJTWVc1blpVVnljbTl5S0NkQ2RXWm1aWElnYzJsNlpTQnRkWE4wSUdKbElHRWdiWFZzZEdsd2JHVWdiMllnTVRZdFltbDBjeWNwWEc0Z0lIMWNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCc1pXNDdJR2tnS3owZ01pa2dlMXh1SUNBZ0lITjNZWEFvZEdocGN5d2dhU3dnYVNBcklERXBYRzRnSUgxY2JpQWdjbVYwZFhKdUlIUm9hWE5jYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXpkMkZ3TXpJZ1BTQm1kVzVqZEdsdmJpQnpkMkZ3TXpJZ0tDa2dlMXh1SUNCMllYSWdiR1Z1SUQwZ2RHaHBjeTVzWlc1bmRHaGNiaUFnYVdZZ0tHeGxiaUFsSURRZ0lUMDlJREFwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVW1GdVoyVkZjbkp2Y2lnblFuVm1abVZ5SUhOcGVtVWdiWFZ6ZENCaVpTQmhJRzExYkhScGNHeGxJRzltSURNeUxXSnBkSE1uS1Z4dUlDQjlYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2JHVnVPeUJwSUNzOUlEUXBJSHRjYmlBZ0lDQnpkMkZ3S0hSb2FYTXNJR2tzSUdrZ0t5QXpLVnh1SUNBZ0lITjNZWEFvZEdocGN5d2dhU0FySURFc0lHa2dLeUF5S1Z4dUlDQjlYRzRnSUhKbGRIVnliaUIwYUdselhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1YzNkaGNEWTBJRDBnWm5WdVkzUnBiMjRnYzNkaGNEWTBJQ2dwSUh0Y2JpQWdkbUZ5SUd4bGJpQTlJSFJvYVhNdWJHVnVaM1JvWEc0Z0lHbG1JQ2hzWlc0Z0pTQTRJQ0U5UFNBd0tTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGSmhibWRsUlhKeWIzSW9KMEoxWm1abGNpQnphWHBsSUcxMWMzUWdZbVVnWVNCdGRXeDBhWEJzWlNCdlppQTJOQzFpYVhSekp5bGNiaUFnZlZ4dUlDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR3hsYmpzZ2FTQXJQU0E0S1NCN1hHNGdJQ0FnYzNkaGNDaDBhR2x6TENCcExDQnBJQ3NnTnlsY2JpQWdJQ0J6ZDJGd0tIUm9hWE1zSUdrZ0t5QXhMQ0JwSUNzZ05pbGNiaUFnSUNCemQyRndLSFJvYVhNc0lHa2dLeUF5TENCcElDc2dOU2xjYmlBZ0lDQnpkMkZ3S0hSb2FYTXNJR2tnS3lBekxDQnBJQ3NnTkNsY2JpQWdmVnh1SUNCeVpYUjFjbTRnZEdocGMxeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuSUQwZ1puVnVZM1JwYjI0Z2RHOVRkSEpwYm1jZ0tDa2dlMXh1SUNCMllYSWdiR1Z1WjNSb0lEMGdkR2hwY3k1c1pXNW5kR2hjYmlBZ2FXWWdLR3hsYm1kMGFDQTlQVDBnTUNrZ2NtVjBkWEp1SUNjblhHNGdJR2xtSUNoaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvSUQwOVBTQXdLU0J5WlhSMWNtNGdkWFJtT0ZOc2FXTmxLSFJvYVhNc0lEQXNJR3hsYm1kMGFDbGNiaUFnY21WMGRYSnVJSE5zYjNkVWIxTjBjbWx1Wnk1aGNIQnNlU2gwYUdsekxDQmhjbWQxYldWdWRITXBYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdVpYRjFZV3h6SUQwZ1puVnVZM1JwYjI0Z1pYRjFZV3h6SUNoaUtTQjdYRzRnSUdsbUlDZ2hRblZtWm1WeUxtbHpRblZtWm1WeUtHSXBLU0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkQmNtZDFiV1Z1ZENCdGRYTjBJR0psSUdFZ1FuVm1abVZ5SnlsY2JpQWdhV1lnS0hSb2FYTWdQVDA5SUdJcElISmxkSFZ5YmlCMGNuVmxYRzRnSUhKbGRIVnliaUJDZFdabVpYSXVZMjl0Y0dGeVpTaDBhR2x6TENCaUtTQTlQVDBnTUZ4dWZWeHVYRzVDZFdabVpYSXVjSEp2ZEc5MGVYQmxMbWx1YzNCbFkzUWdQU0JtZFc1amRHbHZiaUJwYm5Od1pXTjBJQ2dwSUh0Y2JpQWdkbUZ5SUhOMGNpQTlJQ2NuWEc0Z0lIWmhjaUJ0WVhnZ1BTQmxlSEJ2Y25SekxrbE9VMUJGUTFSZlRVRllYMEpaVkVWVFhHNGdJR2xtSUNoMGFHbHpMbXhsYm1kMGFDQStJREFwSUh0Y2JpQWdJQ0J6ZEhJZ1BTQjBhR2x6TG5SdlUzUnlhVzVuS0Nkb1pYZ25MQ0F3TENCdFlYZ3BMbTFoZEdOb0tDOHVleko5TDJjcExtcHZhVzRvSnlBbktWeHVJQ0FnSUdsbUlDaDBhR2x6TG14bGJtZDBhQ0ErSUcxaGVDa2djM1J5SUNzOUlDY2dMaTR1SUNkY2JpQWdmVnh1SUNCeVpYUjFjbTRnSnp4Q2RXWm1aWElnSnlBcklITjBjaUFySUNjK0oxeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG1OdmJYQmhjbVVnUFNCbWRXNWpkR2x2YmlCamIyMXdZWEpsSUNoMFlYSm5aWFFzSUhOMFlYSjBMQ0JsYm1Rc0lIUm9hWE5UZEdGeWRDd2dkR2hwYzBWdVpDa2dlMXh1SUNCcFppQW9JVUoxWm1abGNpNXBjMEoxWm1abGNpaDBZWEpuWlhRcEtTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpZ25RWEpuZFcxbGJuUWdiWFZ6ZENCaVpTQmhJRUoxWm1abGNpY3BYRzRnSUgxY2JseHVJQ0JwWmlBb2MzUmhjblFnUFQwOUlIVnVaR1ZtYVc1bFpDa2dlMXh1SUNBZ0lITjBZWEowSUQwZ01GeHVJQ0I5WEc0Z0lHbG1JQ2hsYm1RZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJR1Z1WkNBOUlIUmhjbWRsZENBL0lIUmhjbWRsZEM1c1pXNW5kR2dnT2lBd1hHNGdJSDFjYmlBZ2FXWWdLSFJvYVhOVGRHRnlkQ0E5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ2RHaHBjMU4wWVhKMElEMGdNRnh1SUNCOVhHNGdJR2xtSUNoMGFHbHpSVzVrSUQwOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQjBhR2x6Ulc1a0lEMGdkR2hwY3k1c1pXNW5kR2hjYmlBZ2ZWeHVYRzRnSUdsbUlDaHpkR0Z5ZENBOElEQWdmSHdnWlc1a0lENGdkR0Z5WjJWMExteGxibWQwYUNCOGZDQjBhR2x6VTNSaGNuUWdQQ0F3SUh4OElIUm9hWE5GYm1RZ1BpQjBhR2x6TG14bGJtZDBhQ2tnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJTWVc1blpVVnljbTl5S0NkdmRYUWdiMllnY21GdVoyVWdhVzVrWlhnbktWeHVJQ0I5WEc1Y2JpQWdhV1lnS0hSb2FYTlRkR0Z5ZENBK1BTQjBhR2x6Ulc1a0lDWW1JSE4wWVhKMElENDlJR1Z1WkNrZ2UxeHVJQ0FnSUhKbGRIVnliaUF3WEc0Z0lIMWNiaUFnYVdZZ0tIUm9hWE5UZEdGeWRDQStQU0IwYUdselJXNWtLU0I3WEc0Z0lDQWdjbVYwZFhKdUlDMHhYRzRnSUgxY2JpQWdhV1lnS0hOMFlYSjBJRDQ5SUdWdVpDa2dlMXh1SUNBZ0lISmxkSFZ5YmlBeFhHNGdJSDFjYmx4dUlDQnpkR0Z5ZENBK1BqNDlJREJjYmlBZ1pXNWtJRDQrUGowZ01GeHVJQ0IwYUdselUzUmhjblFnUGo0K1BTQXdYRzRnSUhSb2FYTkZibVFnUGo0K1BTQXdYRzVjYmlBZ2FXWWdLSFJvYVhNZ1BUMDlJSFJoY21kbGRDa2djbVYwZFhKdUlEQmNibHh1SUNCMllYSWdlQ0E5SUhSb2FYTkZibVFnTFNCMGFHbHpVM1JoY25SY2JpQWdkbUZ5SUhrZ1BTQmxibVFnTFNCemRHRnlkRnh1SUNCMllYSWdiR1Z1SUQwZ1RXRjBhQzV0YVc0b2VDd2dlU2xjYmx4dUlDQjJZWElnZEdocGMwTnZjSGtnUFNCMGFHbHpMbk5zYVdObEtIUm9hWE5UZEdGeWRDd2dkR2hwYzBWdVpDbGNiaUFnZG1GeUlIUmhjbWRsZEVOdmNIa2dQU0IwWVhKblpYUXVjMnhwWTJVb2MzUmhjblFzSUdWdVpDbGNibHh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxianNnS3l0cEtTQjdYRzRnSUNBZ2FXWWdLSFJvYVhORGIzQjVXMmxkSUNFOVBTQjBZWEpuWlhSRGIzQjVXMmxkS1NCN1hHNGdJQ0FnSUNCNElEMGdkR2hwYzBOdmNIbGJhVjFjYmlBZ0lDQWdJSGtnUFNCMFlYSm5aWFJEYjNCNVcybGRYRzRnSUNBZ0lDQmljbVZoYTF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUdsbUlDaDRJRHdnZVNrZ2NtVjBkWEp1SUMweFhHNGdJR2xtSUNoNUlEd2dlQ2tnY21WMGRYSnVJREZjYmlBZ2NtVjBkWEp1SURCY2JuMWNibHh1THk4Z1JtbHVaSE1nWldsMGFHVnlJSFJvWlNCbWFYSnpkQ0JwYm1SbGVDQnZaaUJnZG1Gc1lDQnBiaUJnWW5WbVptVnlZQ0JoZENCdlptWnpaWFFnUGowZ1lHSjVkR1ZQWm1aelpYUmdMRnh1THk4Z1QxSWdkR2hsSUd4aGMzUWdhVzVrWlhnZ2IyWWdZSFpoYkdBZ2FXNGdZR0oxWm1abGNtQWdZWFFnYjJabWMyVjBJRHc5SUdCaWVYUmxUMlptYzJWMFlDNWNiaTh2WEc0dkx5QkJjbWQxYldWdWRITTZYRzR2THlBdElHSjFabVpsY2lBdElHRWdRblZtWm1WeUlIUnZJSE5sWVhKamFGeHVMeThnTFNCMllXd2dMU0JoSUhOMGNtbHVaeXdnUW5WbVptVnlMQ0J2Y2lCdWRXMWlaWEpjYmk4dklDMGdZbmwwWlU5bVpuTmxkQ0F0SUdGdUlHbHVaR1Y0SUdsdWRHOGdZR0oxWm1abGNtQTdJSGRwYkd3Z1ltVWdZMnhoYlhCbFpDQjBieUJoYmlCcGJuUXpNbHh1THk4Z0xTQmxibU52WkdsdVp5QXRJR0Z1SUc5d2RHbHZibUZzSUdWdVkyOWthVzVuTENCeVpXeGxkbUZ1ZENCcGN5QjJZV3dnYVhNZ1lTQnpkSEpwYm1kY2JpOHZJQzBnWkdseUlDMGdkSEoxWlNCbWIzSWdhVzVrWlhoUFppd2dabUZzYzJVZ1ptOXlJR3hoYzNSSmJtUmxlRTltWEc1bWRXNWpkR2x2YmlCaWFXUnBjbVZqZEdsdmJtRnNTVzVrWlhoUFppQW9ZblZtWm1WeUxDQjJZV3dzSUdKNWRHVlBabVp6WlhRc0lHVnVZMjlrYVc1bkxDQmthWElwSUh0Y2JpQWdMeThnUlcxd2RIa2dZblZtWm1WeUlHMWxZVzV6SUc1dklHMWhkR05vWEc0Z0lHbG1JQ2hpZFdabVpYSXViR1Z1WjNSb0lEMDlQU0F3S1NCeVpYUjFjbTRnTFRGY2JseHVJQ0F2THlCT2IzSnRZV3hwZW1VZ1lubDBaVTltWm5ObGRGeHVJQ0JwWmlBb2RIbHdaVzltSUdKNWRHVlBabVp6WlhRZ1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdaVzVqYjJScGJtY2dQU0JpZVhSbFQyWm1jMlYwWEc0Z0lDQWdZbmwwWlU5bVpuTmxkQ0E5SURCY2JpQWdmU0JsYkhObElHbG1JQ2hpZVhSbFQyWm1jMlYwSUQ0Z01IZzNabVptWm1abVppa2dlMXh1SUNBZ0lHSjVkR1ZQWm1aelpYUWdQU0F3ZURkbVptWm1abVptWEc0Z0lIMGdaV3h6WlNCcFppQW9ZbmwwWlU5bVpuTmxkQ0E4SUMwd2VEZ3dNREF3TURBd0tTQjdYRzRnSUNBZ1lubDBaVTltWm5ObGRDQTlJQzB3ZURnd01EQXdNREF3WEc0Z0lIMWNiaUFnWW5sMFpVOW1abk5sZENBOUlDdGllWFJsVDJabWMyVjBJQ0F2THlCRGIyVnlZMlVnZEc4Z1RuVnRZbVZ5TGx4dUlDQnBaaUFvYm5WdFltVnlTWE5PWVU0b1lubDBaVTltWm5ObGRDa3BJSHRjYmlBZ0lDQXZMeUJpZVhSbFQyWm1jMlYwT2lCcGRDQnBkQ2R6SUhWdVpHVm1hVzVsWkN3Z2JuVnNiQ3dnVG1GT0xDQmNJbVp2YjF3aUxDQmxkR01zSUhObFlYSmphQ0IzYUc5c1pTQmlkV1ptWlhKY2JpQWdJQ0JpZVhSbFQyWm1jMlYwSUQwZ1pHbHlJRDhnTUNBNklDaGlkV1ptWlhJdWJHVnVaM1JvSUMwZ01TbGNiaUFnZlZ4dVhHNGdJQzh2SUU1dmNtMWhiR2w2WlNCaWVYUmxUMlptYzJWME9pQnVaV2RoZEdsMlpTQnZabVp6WlhSeklITjBZWEowSUdaeWIyMGdkR2hsSUdWdVpDQnZaaUIwYUdVZ1luVm1abVZ5WEc0Z0lHbG1JQ2hpZVhSbFQyWm1jMlYwSUR3Z01Da2dZbmwwWlU5bVpuTmxkQ0E5SUdKMVptWmxjaTVzWlc1bmRHZ2dLeUJpZVhSbFQyWm1jMlYwWEc0Z0lHbG1JQ2hpZVhSbFQyWm1jMlYwSUQ0OUlHSjFabVpsY2k1c1pXNW5kR2dwSUh0Y2JpQWdJQ0JwWmlBb1pHbHlLU0J5WlhSMWNtNGdMVEZjYmlBZ0lDQmxiSE5sSUdKNWRHVlBabVp6WlhRZ1BTQmlkV1ptWlhJdWJHVnVaM1JvSUMwZ01WeHVJQ0I5SUdWc2MyVWdhV1lnS0dKNWRHVlBabVp6WlhRZ1BDQXdLU0I3WEc0Z0lDQWdhV1lnS0dScGNpa2dZbmwwWlU5bVpuTmxkQ0E5SURCY2JpQWdJQ0JsYkhObElISmxkSFZ5YmlBdE1WeHVJQ0I5WEc1Y2JpQWdMeThnVG05eWJXRnNhWHBsSUhaaGJGeHVJQ0JwWmlBb2RIbHdaVzltSUhaaGJDQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0IyWVd3Z1BTQkNkV1ptWlhJdVpuSnZiU2gyWVd3c0lHVnVZMjlrYVc1bktWeHVJQ0I5WEc1Y2JpQWdMeThnUm1sdVlXeHNlU3dnYzJWaGNtTm9JR1ZwZEdobGNpQnBibVJsZUU5bUlDaHBaaUJrYVhJZ2FYTWdkSEoxWlNrZ2IzSWdiR0Z6ZEVsdVpHVjRUMlpjYmlBZ2FXWWdLRUoxWm1abGNpNXBjMEoxWm1abGNpaDJZV3dwS1NCN1hHNGdJQ0FnTHk4Z1UzQmxZMmxoYkNCallYTmxPaUJzYjI5cmFXNW5JR1p2Y2lCbGJYQjBlU0J6ZEhKcGJtY3ZZblZtWm1WeUlHRnNkMkY1Y3lCbVlXbHNjMXh1SUNBZ0lHbG1JQ2gyWVd3dWJHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdMVEZjYmlBZ0lDQjlYRzRnSUNBZ2NtVjBkWEp1SUdGeWNtRjVTVzVrWlhoUFppaGlkV1ptWlhJc0lIWmhiQ3dnWW5sMFpVOW1abk5sZEN3Z1pXNWpiMlJwYm1jc0lHUnBjaWxjYmlBZ2ZTQmxiSE5sSUdsbUlDaDBlWEJsYjJZZ2RtRnNJRDA5UFNBbmJuVnRZbVZ5SnlrZ2UxeHVJQ0FnSUhaaGJDQTlJSFpoYkNBbUlEQjRSa1lnTHk4Z1UyVmhjbU5vSUdadmNpQmhJR0o1ZEdVZ2RtRnNkV1VnV3pBdE1qVTFYVnh1SUNBZ0lHbG1JQ2gwZVhCbGIyWWdWV2x1ZERoQmNuSmhlUzV3Y205MGIzUjVjR1V1YVc1a1pYaFBaaUE5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lDQWdhV1lnS0dScGNpa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdWV2x1ZERoQmNuSmhlUzV3Y205MGIzUjVjR1V1YVc1a1pYaFBaaTVqWVd4c0tHSjFabVpsY2l3Z2RtRnNMQ0JpZVhSbFQyWm1jMlYwS1Z4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRlZwYm5RNFFYSnlZWGt1Y0hKdmRHOTBlWEJsTG14aGMzUkpibVJsZUU5bUxtTmhiR3dvWW5WbVptVnlMQ0IyWVd3c0lHSjVkR1ZQWm1aelpYUXBYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJoY25KaGVVbHVaR1Y0VDJZb1luVm1abVZ5TENCYklIWmhiQ0JkTENCaWVYUmxUMlptYzJWMExDQmxibU52WkdsdVp5d2daR2x5S1Z4dUlDQjlYRzVjYmlBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpZ25kbUZzSUcxMWMzUWdZbVVnYzNSeWFXNW5MQ0J1ZFcxaVpYSWdiM0lnUW5WbVptVnlKeWxjYm4xY2JseHVablZ1WTNScGIyNGdZWEp5WVhsSmJtUmxlRTltSUNoaGNuSXNJSFpoYkN3Z1lubDBaVTltWm5ObGRDd2daVzVqYjJScGJtY3NJR1JwY2lrZ2UxeHVJQ0IyWVhJZ2FXNWtaWGhUYVhwbElEMGdNVnh1SUNCMllYSWdZWEp5VEdWdVozUm9JRDBnWVhKeUxteGxibWQwYUZ4dUlDQjJZWElnZG1Gc1RHVnVaM1JvSUQwZ2RtRnNMbXhsYm1kMGFGeHVYRzRnSUdsbUlDaGxibU52WkdsdVp5QWhQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnWlc1amIyUnBibWNnUFNCVGRISnBibWNvWlc1amIyUnBibWNwTG5SdlRHOTNaWEpEWVhObEtDbGNiaUFnSUNCcFppQW9aVzVqYjJScGJtY2dQVDA5SUNkMVkzTXlKeUI4ZkNCbGJtTnZaR2x1WnlBOVBUMGdKM1ZqY3kweUp5QjhmRnh1SUNBZ0lDQWdJQ0JsYm1OdlpHbHVaeUE5UFQwZ0ozVjBaakUyYkdVbklIeDhJR1Z1WTI5a2FXNW5JRDA5UFNBbmRYUm1MVEUyYkdVbktTQjdYRzRnSUNBZ0lDQnBaaUFvWVhKeUxteGxibWQwYUNBOElESWdmSHdnZG1Gc0xteGxibWQwYUNBOElESXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJQzB4WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0JwYm1SbGVGTnBlbVVnUFNBeVhHNGdJQ0FnSUNCaGNuSk1aVzVuZEdnZ0x6MGdNbHh1SUNBZ0lDQWdkbUZzVEdWdVozUm9JQzg5SURKY2JpQWdJQ0FnSUdKNWRHVlBabVp6WlhRZ0x6MGdNbHh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR1oxYm1OMGFXOXVJSEpsWVdRZ0tHSjFaaXdnYVNrZ2UxeHVJQ0FnSUdsbUlDaHBibVJsZUZOcGVtVWdQVDA5SURFcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCaWRXWmJhVjFjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdKMVppNXlaV0ZrVlVsdWRERTJRa1VvYVNBcUlHbHVaR1Y0VTJsNlpTbGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQjJZWElnYVZ4dUlDQnBaaUFvWkdseUtTQjdYRzRnSUNBZ2RtRnlJR1p2ZFc1a1NXNWtaWGdnUFNBdE1WeHVJQ0FnSUdadmNpQW9hU0E5SUdKNWRHVlBabVp6WlhRN0lHa2dQQ0JoY25KTVpXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdhV1lnS0hKbFlXUW9ZWEp5TENCcEtTQTlQVDBnY21WaFpDaDJZV3dzSUdadmRXNWtTVzVrWlhnZ1BUMDlJQzB4SUQ4Z01DQTZJR2tnTFNCbWIzVnVaRWx1WkdWNEtTa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb1ptOTFibVJKYm1SbGVDQTlQVDBnTFRFcElHWnZkVzVrU1c1a1pYZ2dQU0JwWEc0Z0lDQWdJQ0FnSUdsbUlDaHBJQzBnWm05MWJtUkpibVJsZUNBcklERWdQVDA5SUhaaGJFeGxibWQwYUNrZ2NtVjBkWEp1SUdadmRXNWtTVzVrWlhnZ0tpQnBibVJsZUZOcGVtVmNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2htYjNWdVpFbHVaR1Y0SUNFOVBTQXRNU2tnYVNBdFBTQnBJQzBnWm05MWJtUkpibVJsZUZ4dUlDQWdJQ0FnSUNCbWIzVnVaRWx1WkdWNElEMGdMVEZjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdhV1lnS0dKNWRHVlBabVp6WlhRZ0t5QjJZV3hNWlc1bmRHZ2dQaUJoY25KTVpXNW5kR2dwSUdKNWRHVlBabVp6WlhRZ1BTQmhjbkpNWlc1bmRHZ2dMU0IyWVd4TVpXNW5kR2hjYmlBZ0lDQm1iM0lnS0drZ1BTQmllWFJsVDJabWMyVjBPeUJwSUQ0OUlEQTdJR2t0TFNrZ2UxeHVJQ0FnSUNBZ2RtRnlJR1p2ZFc1a0lEMGdkSEoxWlZ4dUlDQWdJQ0FnWm05eUlDaDJZWElnYWlBOUlEQTdJR29nUENCMllXeE1aVzVuZEdnN0lHb3JLeWtnZTF4dUlDQWdJQ0FnSUNCcFppQW9jbVZoWkNoaGNuSXNJR2tnS3lCcUtTQWhQVDBnY21WaFpDaDJZV3dzSUdvcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnWm05MWJtUWdQU0JtWVd4elpWeHVJQ0FnSUNBZ0lDQWdJR0p5WldGclhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lHbG1JQ2htYjNWdVpDa2djbVYwZFhKdUlHbGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z0xURmNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1cGJtTnNkV1JsY3lBOUlHWjFibU4wYVc5dUlHbHVZMngxWkdWeklDaDJZV3dzSUdKNWRHVlBabVp6WlhRc0lHVnVZMjlrYVc1bktTQjdYRzRnSUhKbGRIVnliaUIwYUdsekxtbHVaR1Y0VDJZb2RtRnNMQ0JpZVhSbFQyWm1jMlYwTENCbGJtTnZaR2x1WnlrZ0lUMDlJQzB4WEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVhVzVrWlhoUFppQTlJR1oxYm1OMGFXOXVJR2x1WkdWNFQyWWdLSFpoYkN3Z1lubDBaVTltWm5ObGRDd2daVzVqYjJScGJtY3BJSHRjYmlBZ2NtVjBkWEp1SUdKcFpHbHlaV04wYVc5dVlXeEpibVJsZUU5bUtIUm9hWE1zSUhaaGJDd2dZbmwwWlU5bVpuTmxkQ3dnWlc1amIyUnBibWNzSUhSeWRXVXBYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWJHRnpkRWx1WkdWNFQyWWdQU0JtZFc1amRHbHZiaUJzWVhOMFNXNWtaWGhQWmlBb2RtRnNMQ0JpZVhSbFQyWm1jMlYwTENCbGJtTnZaR2x1WnlrZ2UxeHVJQ0J5WlhSMWNtNGdZbWxrYVhKbFkzUnBiMjVoYkVsdVpHVjRUMllvZEdocGN5d2dkbUZzTENCaWVYUmxUMlptYzJWMExDQmxibU52WkdsdVp5d2dabUZzYzJVcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdobGVGZHlhWFJsSUNoaWRXWXNJSE4wY21sdVp5d2diMlptYzJWMExDQnNaVzVuZEdncElIdGNiaUFnYjJabWMyVjBJRDBnVG5WdFltVnlLRzltWm5ObGRDa2dmSHdnTUZ4dUlDQjJZWElnY21WdFlXbHVhVzVuSUQwZ1luVm1MbXhsYm1kMGFDQXRJRzltWm5ObGRGeHVJQ0JwWmlBb0lXeGxibWQwYUNrZ2UxeHVJQ0FnSUd4bGJtZDBhQ0E5SUhKbGJXRnBibWx1WjF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUd4bGJtZDBhQ0E5SUU1MWJXSmxjaWhzWlc1bmRHZ3BYRzRnSUNBZ2FXWWdLR3hsYm1kMGFDQStJSEpsYldGcGJtbHVaeWtnZTF4dUlDQWdJQ0FnYkdWdVozUm9JRDBnY21WdFlXbHVhVzVuWEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnTHk4Z2JYVnpkQ0JpWlNCaGJpQmxkbVZ1SUc1MWJXSmxjaUJ2WmlCa2FXZHBkSE5jYmlBZ2RtRnlJSE4wY2t4bGJpQTlJSE4wY21sdVp5NXNaVzVuZEdoY2JpQWdhV1lnS0hOMGNreGxiaUFsSURJZ0lUMDlJREFwSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0owbHVkbUZzYVdRZ2FHVjRJSE4wY21sdVp5Y3BYRzVjYmlBZ2FXWWdLR3hsYm1kMGFDQStJSE4wY2t4bGJpQXZJRElwSUh0Y2JpQWdJQ0JzWlc1bmRHZ2dQU0J6ZEhKTVpXNGdMeUF5WEc0Z0lIMWNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCc1pXNW5kR2c3SUNzcmFTa2dlMXh1SUNBZ0lIWmhjaUJ3WVhKelpXUWdQU0J3WVhKelpVbHVkQ2h6ZEhKcGJtY3VjM1ZpYzNSeUtHa2dLaUF5TENBeUtTd2dNVFlwWEc0Z0lDQWdhV1lnS0c1MWJXSmxja2x6VG1GT0tIQmhjbk5sWkNrcElISmxkSFZ5YmlCcFhHNGdJQ0FnWW5WbVcyOW1abk5sZENBcklHbGRJRDBnY0dGeWMyVmtYRzRnSUgxY2JpQWdjbVYwZFhKdUlHbGNibjFjYmx4dVpuVnVZM1JwYjI0Z2RYUm1PRmR5YVhSbElDaGlkV1lzSUhOMGNtbHVaeXdnYjJabWMyVjBMQ0JzWlc1bmRHZ3BJSHRjYmlBZ2NtVjBkWEp1SUdKc2FYUkNkV1ptWlhJb2RYUm1PRlJ2UW5sMFpYTW9jM1J5YVc1bkxDQmlkV1l1YkdWdVozUm9JQzBnYjJabWMyVjBLU3dnWW5WbUxDQnZabVp6WlhRc0lHeGxibWQwYUNsY2JuMWNibHh1Wm5WdVkzUnBiMjRnWVhOamFXbFhjbWwwWlNBb1luVm1MQ0J6ZEhKcGJtY3NJRzltWm5ObGRDd2diR1Z1WjNSb0tTQjdYRzRnSUhKbGRIVnliaUJpYkdsMFFuVm1abVZ5S0dGelkybHBWRzlDZVhSbGN5aHpkSEpwYm1jcExDQmlkV1lzSUc5bVpuTmxkQ3dnYkdWdVozUm9LVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnNZWFJwYmpGWGNtbDBaU0FvWW5WbUxDQnpkSEpwYm1jc0lHOW1abk5sZEN3Z2JHVnVaM1JvS1NCN1hHNGdJSEpsZEhWeWJpQmhjMk5wYVZkeWFYUmxLR0oxWml3Z2MzUnlhVzVuTENCdlptWnpaWFFzSUd4bGJtZDBhQ2xjYm4xY2JseHVablZ1WTNScGIyNGdZbUZ6WlRZMFYzSnBkR1VnS0dKMVppd2djM1J5YVc1bkxDQnZabVp6WlhRc0lHeGxibWQwYUNrZ2UxeHVJQ0J5WlhSMWNtNGdZbXhwZEVKMVptWmxjaWhpWVhObE5qUlViMEo1ZEdWektITjBjbWx1Wnlrc0lHSjFaaXdnYjJabWMyVjBMQ0JzWlc1bmRHZ3BYRzU5WEc1Y2JtWjFibU4wYVc5dUlIVmpjekpYY21sMFpTQW9ZblZtTENCemRISnBibWNzSUc5bVpuTmxkQ3dnYkdWdVozUm9LU0I3WEc0Z0lISmxkSFZ5YmlCaWJHbDBRblZtWm1WeUtIVjBaakUyYkdWVWIwSjVkR1Z6S0hOMGNtbHVaeXdnWW5WbUxteGxibWQwYUNBdElHOW1abk5sZENrc0lHSjFaaXdnYjJabWMyVjBMQ0JzWlc1bmRHZ3BYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWQzSnBkR1VnUFNCbWRXNWpkR2x2YmlCM2NtbDBaU0FvYzNSeWFXNW5MQ0J2Wm1aelpYUXNJR3hsYm1kMGFDd2daVzVqYjJScGJtY3BJSHRjYmlBZ0x5OGdRblZtWm1WeUkzZHlhWFJsS0hOMGNtbHVaeWxjYmlBZ2FXWWdLRzltWm5ObGRDQTlQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnWlc1amIyUnBibWNnUFNBbmRYUm1PQ2RjYmlBZ0lDQnNaVzVuZEdnZ1BTQjBhR2x6TG14bGJtZDBhRnh1SUNBZ0lHOW1abk5sZENBOUlEQmNiaUFnTHk4Z1FuVm1abVZ5STNkeWFYUmxLSE4wY21sdVp5d2daVzVqYjJScGJtY3BYRzRnSUgwZ1pXeHpaU0JwWmlBb2JHVnVaM1JvSUQwOVBTQjFibVJsWm1sdVpXUWdKaVlnZEhsd1pXOW1JRzltWm5ObGRDQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0JsYm1OdlpHbHVaeUE5SUc5bVpuTmxkRnh1SUNBZ0lHeGxibWQwYUNBOUlIUm9hWE11YkdWdVozUm9YRzRnSUNBZ2IyWm1jMlYwSUQwZ01GeHVJQ0F2THlCQ2RXWm1aWElqZDNKcGRHVW9jM1J5YVc1bkxDQnZabVp6WlhSYkxDQnNaVzVuZEdoZFd5d2daVzVqYjJScGJtZGRLVnh1SUNCOUlHVnNjMlVnYVdZZ0tHbHpSbWx1YVhSbEtHOW1abk5sZENrcElIdGNiaUFnSUNCdlptWnpaWFFnUFNCdlptWnpaWFFnUGo0K0lEQmNiaUFnSUNCcFppQW9hWE5HYVc1cGRHVW9iR1Z1WjNSb0tTa2dlMXh1SUNBZ0lDQWdiR1Z1WjNSb0lEMGdiR1Z1WjNSb0lENCtQaUF3WEc0Z0lDQWdJQ0JwWmlBb1pXNWpiMlJwYm1jZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnWlc1amIyUnBibWNnUFNBbmRYUm1PQ2RjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ1pXNWpiMlJwYm1jZ1BTQnNaVzVuZEdoY2JpQWdJQ0FnSUd4bGJtZDBhQ0E5SUhWdVpHVm1hVzVsWkZ4dUlDQWdJSDFjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9YRzRnSUNBZ0lDQW5RblZtWm1WeUxuZHlhWFJsS0hOMGNtbHVaeXdnWlc1amIyUnBibWNzSUc5bVpuTmxkRnNzSUd4bGJtZDBhRjBwSUdseklHNXZJR3h2Ym1kbGNpQnpkWEJ3YjNKMFpXUW5YRzRnSUNBZ0tWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhKbGJXRnBibWx1WnlBOUlIUm9hWE11YkdWdVozUm9JQzBnYjJabWMyVjBYRzRnSUdsbUlDaHNaVzVuZEdnZ1BUMDlJSFZ1WkdWbWFXNWxaQ0I4ZkNCc1pXNW5kR2dnUGlCeVpXMWhhVzVwYm1jcElHeGxibWQwYUNBOUlISmxiV0ZwYm1sdVoxeHVYRzRnSUdsbUlDZ29jM1J5YVc1bkxteGxibWQwYUNBK0lEQWdKaVlnS0d4bGJtZDBhQ0E4SURBZ2ZId2diMlptYzJWMElEd2dNQ2twSUh4OElHOW1abk5sZENBK0lIUm9hWE11YkdWdVozUm9LU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRkpoYm1kbFJYSnliM0lvSjBGMGRHVnRjSFFnZEc4Z2QzSnBkR1VnYjNWMGMybGtaU0JpZFdabVpYSWdZbTkxYm1Sekp5bGNiaUFnZlZ4dVhHNGdJR2xtSUNnaFpXNWpiMlJwYm1jcElHVnVZMjlrYVc1bklEMGdKM1YwWmpnblhHNWNiaUFnZG1GeUlHeHZkMlZ5WldSRFlYTmxJRDBnWm1Gc2MyVmNiaUFnWm05eUlDZzdPeWtnZTF4dUlDQWdJSE4zYVhSamFDQW9aVzVqYjJScGJtY3BJSHRjYmlBZ0lDQWdJR05oYzJVZ0oyaGxlQ2M2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJvWlhoWGNtbDBaU2gwYUdsekxDQnpkSEpwYm1jc0lHOW1abk5sZEN3Z2JHVnVaM1JvS1Z4dVhHNGdJQ0FnSUNCallYTmxJQ2QxZEdZNEp6cGNiaUFnSUNBZ0lHTmhjMlVnSjNWMFppMDRKenBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFYwWmpoWGNtbDBaU2gwYUdsekxDQnpkSEpwYm1jc0lHOW1abk5sZEN3Z2JHVnVaM1JvS1Z4dVhHNGdJQ0FnSUNCallYTmxJQ2RoYzJOcGFTYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmhjMk5wYVZkeWFYUmxLSFJvYVhNc0lITjBjbWx1Wnl3Z2IyWm1jMlYwTENCc1pXNW5kR2dwWEc1Y2JpQWdJQ0FnSUdOaGMyVWdKMnhoZEdsdU1TYzZYRzRnSUNBZ0lDQmpZWE5sSUNkaWFXNWhjbmtuT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYkdGMGFXNHhWM0pwZEdVb2RHaHBjeXdnYzNSeWFXNW5MQ0J2Wm1aelpYUXNJR3hsYm1kMGFDbGNibHh1SUNBZ0lDQWdZMkZ6WlNBblltRnpaVFkwSnpwY2JpQWdJQ0FnSUNBZ0x5OGdWMkZ5Ym1sdVp6b2diV0Y0VEdWdVozUm9JRzV2ZENCMFlXdGxiaUJwYm5SdklHRmpZMjkxYm5RZ2FXNGdZbUZ6WlRZMFYzSnBkR1ZjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR0poYzJVMk5GZHlhWFJsS0hSb2FYTXNJSE4wY21sdVp5d2diMlptYzJWMExDQnNaVzVuZEdncFhHNWNiaUFnSUNBZ0lHTmhjMlVnSjNWamN6SW5PbHh1SUNBZ0lDQWdZMkZ6WlNBbmRXTnpMVEluT2x4dUlDQWdJQ0FnWTJGelpTQW5kWFJtTVRac1pTYzZYRzRnSUNBZ0lDQmpZWE5sSUNkMWRHWXRNVFpzWlNjNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMVkzTXlWM0pwZEdVb2RHaHBjeXdnYzNSeWFXNW5MQ0J2Wm1aelpYUXNJR3hsYm1kMGFDbGNibHh1SUNBZ0lDQWdaR1ZtWVhWc2REcGNiaUFnSUNBZ0lDQWdhV1lnS0d4dmQyVnlaV1JEWVhObEtTQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLQ2RWYm10dWIzZHVJR1Z1WTI5a2FXNW5PaUFuSUNzZ1pXNWpiMlJwYm1jcFhHNGdJQ0FnSUNBZ0lHVnVZMjlrYVc1bklEMGdLQ2NuSUNzZ1pXNWpiMlJwYm1jcExuUnZURzkzWlhKRFlYTmxLQ2xjYmlBZ0lDQWdJQ0FnYkc5M1pYSmxaRU5oYzJVZ1BTQjBjblZsWEc0Z0lDQWdmVnh1SUNCOVhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1ZEc5S1UwOU9JRDBnWm5WdVkzUnBiMjRnZEc5S1UwOU9JQ2dwSUh0Y2JpQWdjbVYwZFhKdUlIdGNiaUFnSUNCMGVYQmxPaUFuUW5WbVptVnlKeXhjYmlBZ0lDQmtZWFJoT2lCQmNuSmhlUzV3Y205MGIzUjVjR1V1YzJ4cFkyVXVZMkZzYkNoMGFHbHpMbDloY25JZ2ZId2dkR2hwY3l3Z01DbGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJpWVhObE5qUlRiR2xqWlNBb1luVm1MQ0J6ZEdGeWRDd2daVzVrS1NCN1hHNGdJR2xtSUNoemRHRnlkQ0E5UFQwZ01DQW1KaUJsYm1RZ1BUMDlJR0oxWmk1c1pXNW5kR2dwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdZbUZ6WlRZMExtWnliMjFDZVhSbFFYSnlZWGtvWW5WbUtWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxkSFZ5YmlCaVlYTmxOalF1Wm5KdmJVSjVkR1ZCY25KaGVTaGlkV1l1YzJ4cFkyVW9jM1JoY25Rc0lHVnVaQ2twWEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z2RYUm1PRk5zYVdObElDaGlkV1lzSUhOMFlYSjBMQ0JsYm1RcElIdGNiaUFnWlc1a0lEMGdUV0YwYUM1dGFXNG9ZblZtTG14bGJtZDBhQ3dnWlc1a0tWeHVJQ0IyWVhJZ2NtVnpJRDBnVzExY2JseHVJQ0IyWVhJZ2FTQTlJSE4wWVhKMFhHNGdJSGRvYVd4bElDaHBJRHdnWlc1a0tTQjdYRzRnSUNBZ2RtRnlJR1pwY25OMFFubDBaU0E5SUdKMVpsdHBYVnh1SUNBZ0lIWmhjaUJqYjJSbFVHOXBiblFnUFNCdWRXeHNYRzRnSUNBZ2RtRnlJR0o1ZEdWelVHVnlVMlZ4ZFdWdVkyVWdQU0FvWm1seWMzUkNlWFJsSUQ0Z01IaEZSaWtnUHlBMFhHNGdJQ0FnSUNBNklDaG1hWEp6ZEVKNWRHVWdQaUF3ZUVSR0tTQS9JRE5jYmlBZ0lDQWdJRG9nS0dacGNuTjBRbmwwWlNBK0lEQjRRa1lwSUQ4Z01seHVJQ0FnSUNBZ09pQXhYRzVjYmlBZ0lDQnBaaUFvYVNBcklHSjVkR1Z6VUdWeVUyVnhkV1Z1WTJVZ1BEMGdaVzVrS1NCN1hHNGdJQ0FnSUNCMllYSWdjMlZqYjI1a1FubDBaU3dnZEdocGNtUkNlWFJsTENCbWIzVnlkR2hDZVhSbExDQjBaVzF3UTI5a1pWQnZhVzUwWEc1Y2JpQWdJQ0FnSUhOM2FYUmphQ0FvWW5sMFpYTlFaWEpUWlhGMVpXNWpaU2tnZTF4dUlDQWdJQ0FnSUNCallYTmxJREU2WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLR1pwY25OMFFubDBaU0E4SURCNE9EQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZaR1ZRYjJsdWRDQTlJR1pwY25OMFFubDBaVnh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQmljbVZoYTF4dUlDQWdJQ0FnSUNCallYTmxJREk2WEc0Z0lDQWdJQ0FnSUNBZ2MyVmpiMjVrUW5sMFpTQTlJR0oxWmx0cElDc2dNVjFjYmlBZ0lDQWdJQ0FnSUNCcFppQW9LSE5sWTI5dVpFSjVkR1VnSmlBd2VFTXdLU0E5UFQwZ01IZzRNQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkR1Z0Y0VOdlpHVlFiMmx1ZENBOUlDaG1hWEp6ZEVKNWRHVWdKaUF3ZURGR0tTQThQQ0F3ZURZZ2ZDQW9jMlZqYjI1a1FubDBaU0FtSURCNE0wWXBYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR1Z0Y0VOdlpHVlFiMmx1ZENBK0lEQjROMFlwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pWQnZhVzUwSUQwZ2RHVnRjRU52WkdWUWIybHVkRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCaWNtVmhhMXh1SUNBZ0lDQWdJQ0JqWVhObElETTZYRzRnSUNBZ0lDQWdJQ0FnYzJWamIyNWtRbmwwWlNBOUlHSjFabHRwSUNzZ01WMWNiaUFnSUNBZ0lDQWdJQ0IwYUdseVpFSjVkR1VnUFNCaWRXWmJhU0FySURKZFhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0NoelpXTnZibVJDZVhSbElDWWdNSGhETUNrZ1BUMDlJREI0T0RBZ0ppWWdLSFJvYVhKa1FubDBaU0FtSURCNFF6QXBJRDA5UFNBd2VEZ3dLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBaVzF3UTI5a1pWQnZhVzUwSUQwZ0tHWnBjbk4wUW5sMFpTQW1JREI0UmlrZ1BEd2dNSGhESUh3Z0tITmxZMjl1WkVKNWRHVWdKaUF3ZUROR0tTQThQQ0F3ZURZZ2ZDQW9kR2hwY21SQ2VYUmxJQ1lnTUhnelJpbGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaDBaVzF3UTI5a1pWQnZhVzUwSUQ0Z01IZzNSa1lnSmlZZ0tIUmxiWEJEYjJSbFVHOXBiblFnUENBd2VFUTRNREFnZkh3Z2RHVnRjRU52WkdWUWIybHVkQ0ErSURCNFJFWkdSaWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pWQnZhVzUwSUQwZ2RHVnRjRU52WkdWUWIybHVkRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCaWNtVmhhMXh1SUNBZ0lDQWdJQ0JqWVhObElEUTZYRzRnSUNBZ0lDQWdJQ0FnYzJWamIyNWtRbmwwWlNBOUlHSjFabHRwSUNzZ01WMWNiaUFnSUNBZ0lDQWdJQ0IwYUdseVpFSjVkR1VnUFNCaWRXWmJhU0FySURKZFhHNGdJQ0FnSUNBZ0lDQWdabTkxY25Sb1FubDBaU0E5SUdKMVpsdHBJQ3NnTTExY2JpQWdJQ0FnSUNBZ0lDQnBaaUFvS0hObFkyOXVaRUo1ZEdVZ0ppQXdlRU13S1NBOVBUMGdNSGc0TUNBbUppQW9kR2hwY21SQ2VYUmxJQ1lnTUhoRE1Da2dQVDA5SURCNE9EQWdKaVlnS0dadmRYSjBhRUo1ZEdVZ0ppQXdlRU13S1NBOVBUMGdNSGc0TUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdWdGNFTnZaR1ZRYjJsdWRDQTlJQ2htYVhKemRFSjVkR1VnSmlBd2VFWXBJRHc4SURCNE1USWdmQ0FvYzJWamIyNWtRbmwwWlNBbUlEQjRNMFlwSUR3OElEQjRReUI4SUNoMGFHbHlaRUo1ZEdVZ0ppQXdlRE5HS1NBOFBDQXdlRFlnZkNBb1ptOTFjblJvUW5sMFpTQW1JREI0TTBZcFhHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2RHVnRjRU52WkdWUWIybHVkQ0ErSURCNFJrWkdSaUFtSmlCMFpXMXdRMjlrWlZCdmFXNTBJRHdnTUhneE1UQXdNREFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pWQnZhVzUwSUQwZ2RHVnRjRU52WkdWUWIybHVkRnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvWTI5a1pWQnZhVzUwSUQwOVBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNBdkx5QjNaU0JrYVdRZ2JtOTBJR2RsYm1WeVlYUmxJR0VnZG1Gc2FXUWdZMjlrWlZCdmFXNTBJSE52SUdsdWMyVnlkQ0JoWEc0Z0lDQWdJQ0F2THlCeVpYQnNZV05sYldWdWRDQmphR0Z5SUNoVkswWkdSa1FwSUdGdVpDQmhaSFpoYm1ObElHOXViSGtnTVNCaWVYUmxYRzRnSUNBZ0lDQmpiMlJsVUc5cGJuUWdQU0F3ZUVaR1JrUmNiaUFnSUNBZ0lHSjVkR1Z6VUdWeVUyVnhkV1Z1WTJVZ1BTQXhYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaGpiMlJsVUc5cGJuUWdQaUF3ZUVaR1JrWXBJSHRjYmlBZ0lDQWdJQzh2SUdWdVkyOWtaU0IwYnlCMWRHWXhOaUFvYzNWeWNtOW5ZWFJsSUhCaGFYSWdaR0Z1WTJVcFhHNGdJQ0FnSUNCamIyUmxVRzlwYm5RZ0xUMGdNSGd4TURBd01GeHVJQ0FnSUNBZ2NtVnpMbkIxYzJnb1kyOWtaVkJ2YVc1MElENCtQaUF4TUNBbUlEQjRNMFpHSUh3Z01IaEVPREF3S1Z4dUlDQWdJQ0FnWTI5a1pWQnZhVzUwSUQwZ01IaEVRekF3SUh3Z1kyOWtaVkJ2YVc1MElDWWdNSGd6UmtaY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhNdWNIVnphQ2hqYjJSbFVHOXBiblFwWEc0Z0lDQWdhU0FyUFNCaWVYUmxjMUJsY2xObGNYVmxibU5sWEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnWkdWamIyUmxRMjlrWlZCdmFXNTBjMEZ5Y21GNUtISmxjeWxjYm4xY2JseHVMeThnUW1GelpXUWdiMjRnYUhSMGNEb3ZMM04wWVdOcmIzWmxjbVpzYjNjdVkyOXRMMkV2TWpJM05EY3lOekl2Tmpnd056UXlMQ0IwYUdVZ1luSnZkM05sY2lCM2FYUm9YRzR2THlCMGFHVWdiRzkzWlhOMElHeHBiV2wwSUdseklFTm9jbTl0WlN3Z2QybDBhQ0F3ZURFd01EQXdJR0Z5WjNNdVhHNHZMeUJYWlNCbmJ5QXhJRzFoWjI1cGRIVmtaU0JzWlhOekxDQm1iM0lnYzJGbVpYUjVYRzUyWVhJZ1RVRllYMEZTUjFWTlJVNVVVMTlNUlU1SFZFZ2dQU0F3ZURFd01EQmNibHh1Wm5WdVkzUnBiMjRnWkdWamIyUmxRMjlrWlZCdmFXNTBjMEZ5Y21GNUlDaGpiMlJsVUc5cGJuUnpLU0I3WEc0Z0lIWmhjaUJzWlc0Z1BTQmpiMlJsVUc5cGJuUnpMbXhsYm1kMGFGeHVJQ0JwWmlBb2JHVnVJRHc5SUUxQldGOUJVa2RWVFVWT1ZGTmZURVZPUjFSSUtTQjdYRzRnSUNBZ2NtVjBkWEp1SUZOMGNtbHVaeTVtY205dFEyaGhja052WkdVdVlYQndiSGtvVTNSeWFXNW5MQ0JqYjJSbFVHOXBiblJ6S1NBdkx5QmhkbTlwWkNCbGVIUnlZU0J6YkdsalpTZ3BYRzRnSUgxY2JseHVJQ0F2THlCRVpXTnZaR1VnYVc0Z1kyaDFibXR6SUhSdklHRjJiMmxrSUZ3aVkyRnNiQ0J6ZEdGamF5QnphWHBsSUdWNFkyVmxaR1ZrWENJdVhHNGdJSFpoY2lCeVpYTWdQU0FuSjF4dUlDQjJZWElnYVNBOUlEQmNiaUFnZDJocGJHVWdLR2tnUENCc1pXNHBJSHRjYmlBZ0lDQnlaWE1nS3owZ1UzUnlhVzVuTG1aeWIyMURhR0Z5UTI5a1pTNWhjSEJzZVNoY2JpQWdJQ0FnSUZOMGNtbHVaeXhjYmlBZ0lDQWdJR052WkdWUWIybHVkSE11YzJ4cFkyVW9hU3dnYVNBclBTQk5RVmhmUVZKSFZVMUZUbFJUWDB4RlRrZFVTQ2xjYmlBZ0lDQXBYRzRnSUgxY2JpQWdjbVYwZFhKdUlISmxjMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmhjMk5wYVZOc2FXTmxJQ2hpZFdZc0lITjBZWEowTENCbGJtUXBJSHRjYmlBZ2RtRnlJSEpsZENBOUlDY25YRzRnSUdWdVpDQTlJRTFoZEdndWJXbHVLR0oxWmk1c1pXNW5kR2dzSUdWdVpDbGNibHh1SUNCbWIzSWdLSFpoY2lCcElEMGdjM1JoY25RN0lHa2dQQ0JsYm1RN0lDc3JhU2tnZTF4dUlDQWdJSEpsZENBclBTQlRkSEpwYm1jdVpuSnZiVU5vWVhKRGIyUmxLR0oxWmx0cFhTQW1JREI0TjBZcFhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhKbGRGeHVmVnh1WEc1bWRXNWpkR2x2YmlCc1lYUnBiakZUYkdsalpTQW9ZblZtTENCemRHRnlkQ3dnWlc1a0tTQjdYRzRnSUhaaGNpQnlaWFFnUFNBbkoxeHVJQ0JsYm1RZ1BTQk5ZWFJvTG0xcGJpaGlkV1l1YkdWdVozUm9MQ0JsYm1RcFhHNWNiaUFnWm05eUlDaDJZWElnYVNBOUlITjBZWEowT3lCcElEd2daVzVrT3lBcksya3BJSHRjYmlBZ0lDQnlaWFFnS3owZ1UzUnlhVzVuTG1aeWIyMURhR0Z5UTI5a1pTaGlkV1piYVYwcFhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhKbGRGeHVmVnh1WEc1bWRXNWpkR2x2YmlCb1pYaFRiR2xqWlNBb1luVm1MQ0J6ZEdGeWRDd2daVzVrS1NCN1hHNGdJSFpoY2lCc1pXNGdQU0JpZFdZdWJHVnVaM1JvWEc1Y2JpQWdhV1lnS0NGemRHRnlkQ0I4ZkNCemRHRnlkQ0E4SURBcElITjBZWEowSUQwZ01GeHVJQ0JwWmlBb0lXVnVaQ0I4ZkNCbGJtUWdQQ0F3SUh4OElHVnVaQ0ErSUd4bGJpa2daVzVrSUQwZ2JHVnVYRzVjYmlBZ2RtRnlJRzkxZENBOUlDY25YRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQnpkR0Z5ZERzZ2FTQThJR1Z1WkRzZ0t5dHBLU0I3WEc0Z0lDQWdiM1YwSUNzOUlIUnZTR1Y0S0dKMVpsdHBYU2xjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdiM1YwWEc1OVhHNWNibVoxYm1OMGFXOXVJSFYwWmpFMmJHVlRiR2xqWlNBb1luVm1MQ0J6ZEdGeWRDd2daVzVrS1NCN1hHNGdJSFpoY2lCaWVYUmxjeUE5SUdKMVppNXpiR2xqWlNoemRHRnlkQ3dnWlc1a0tWeHVJQ0IyWVhJZ2NtVnpJRDBnSnlkY2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JpZVhSbGN5NXNaVzVuZEdnN0lHa2dLejBnTWlrZ2UxeHVJQ0FnSUhKbGN5QXJQU0JUZEhKcGJtY3Vabkp2YlVOb1lYSkRiMlJsS0dKNWRHVnpXMmxkSUNzZ0tHSjVkR1Z6VzJrZ0t5QXhYU0FxSURJMU5pa3BYRzRnSUgxY2JpQWdjbVYwZFhKdUlISmxjMXh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuTnNhV05sSUQwZ1puVnVZM1JwYjI0Z2MyeHBZMlVnS0hOMFlYSjBMQ0JsYm1RcElIdGNiaUFnZG1GeUlHeGxiaUE5SUhSb2FYTXViR1Z1WjNSb1hHNGdJSE4wWVhKMElEMGdmbjV6ZEdGeWRGeHVJQ0JsYm1RZ1BTQmxibVFnUFQwOUlIVnVaR1ZtYVc1bFpDQS9JR3hsYmlBNklINStaVzVrWEc1Y2JpQWdhV1lnS0hOMFlYSjBJRHdnTUNrZ2UxeHVJQ0FnSUhOMFlYSjBJQ3M5SUd4bGJseHVJQ0FnSUdsbUlDaHpkR0Z5ZENBOElEQXBJSE4wWVhKMElEMGdNRnh1SUNCOUlHVnNjMlVnYVdZZ0tITjBZWEowSUQ0Z2JHVnVLU0I3WEc0Z0lDQWdjM1JoY25RZ1BTQnNaVzVjYmlBZ2ZWeHVYRzRnSUdsbUlDaGxibVFnUENBd0tTQjdYRzRnSUNBZ1pXNWtJQ3M5SUd4bGJseHVJQ0FnSUdsbUlDaGxibVFnUENBd0tTQmxibVFnUFNBd1hHNGdJSDBnWld4elpTQnBaaUFvWlc1a0lENGdiR1Z1S1NCN1hHNGdJQ0FnWlc1a0lEMGdiR1Z1WEc0Z0lIMWNibHh1SUNCcFppQW9aVzVrSUR3Z2MzUmhjblFwSUdWdVpDQTlJSE4wWVhKMFhHNWNiaUFnZG1GeUlHNWxkMEoxWmlBOUlIUm9hWE11YzNWaVlYSnlZWGtvYzNSaGNuUXNJR1Z1WkNsY2JpQWdMeThnVW1WMGRYSnVJR0Z1SUdGMVoyMWxiblJsWkNCZ1ZXbHVkRGhCY25KaGVXQWdhVzV6ZEdGdVkyVmNiaUFnYm1WM1FuVm1MbDlmY0hKdmRHOWZYeUE5SUVKMVptWmxjaTV3Y205MGIzUjVjR1ZjYmlBZ2NtVjBkWEp1SUc1bGQwSjFabHh1ZlZ4dVhHNHZLbHh1SUNvZ1RtVmxaQ0IwYnlCdFlXdGxJSE4xY21VZ2RHaGhkQ0JpZFdabVpYSWdhWE51SjNRZ2RISjVhVzVuSUhSdklIZHlhWFJsSUc5MWRDQnZaaUJpYjNWdVpITXVYRzRnS2k5Y2JtWjFibU4wYVc5dUlHTm9aV05yVDJabWMyVjBJQ2h2Wm1aelpYUXNJR1Y0ZEN3Z2JHVnVaM1JvS1NCN1hHNGdJR2xtSUNnb2IyWm1jMlYwSUNVZ01Ta2dJVDA5SURBZ2ZId2diMlptYzJWMElEd2dNQ2tnZEdoeWIzY2dibVYzSUZKaGJtZGxSWEp5YjNJb0oyOW1abk5sZENCcGN5QnViM1FnZFdsdWRDY3BYRzRnSUdsbUlDaHZabVp6WlhRZ0t5QmxlSFFnUGlCc1pXNW5kR2dwSUhSb2NtOTNJRzVsZHlCU1lXNW5aVVZ5Y205eUtDZFVjbmxwYm1jZ2RHOGdZV05qWlhOeklHSmxlVzl1WkNCaWRXWm1aWElnYkdWdVozUm9KeWxjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXlaV0ZrVlVsdWRFeEZJRDBnWm5WdVkzUnBiMjRnY21WaFpGVkpiblJNUlNBb2IyWm1jMlYwTENCaWVYUmxUR1Z1WjNSb0xDQnViMEZ6YzJWeWRDa2dlMXh1SUNCdlptWnpaWFFnUFNCdlptWnpaWFFnUGo0K0lEQmNiaUFnWW5sMFpVeGxibWQwYUNBOUlHSjVkR1ZNWlc1bmRHZ2dQajQrSURCY2JpQWdhV1lnS0NGdWIwRnpjMlZ5ZENrZ1kyaGxZMnRQWm1aelpYUW9iMlptYzJWMExDQmllWFJsVEdWdVozUm9MQ0IwYUdsekxteGxibWQwYUNsY2JseHVJQ0IyWVhJZ2RtRnNJRDBnZEdocGMxdHZabVp6WlhSZFhHNGdJSFpoY2lCdGRXd2dQU0F4WEc0Z0lIWmhjaUJwSUQwZ01GeHVJQ0IzYUdsc1pTQW9LeXRwSUR3Z1lubDBaVXhsYm1kMGFDQW1KaUFvYlhWc0lDbzlJREI0TVRBd0tTa2dlMXh1SUNBZ0lIWmhiQ0FyUFNCMGFHbHpXMjltWm5ObGRDQXJJR2xkSUNvZ2JYVnNYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdkbUZzWEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVjbVZoWkZWSmJuUkNSU0E5SUdaMWJtTjBhVzl1SUhKbFlXUlZTVzUwUWtVZ0tHOW1abk5sZEN3Z1lubDBaVXhsYm1kMGFDd2dibTlCYzNObGNuUXBJSHRjYmlBZ2IyWm1jMlYwSUQwZ2IyWm1jMlYwSUQ0K1BpQXdYRzRnSUdKNWRHVk1aVzVuZEdnZ1BTQmllWFJsVEdWdVozUm9JRDQrUGlBd1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElIdGNiaUFnSUNCamFHVmphMDltWm5ObGRDaHZabVp6WlhRc0lHSjVkR1ZNWlc1bmRHZ3NJSFJvYVhNdWJHVnVaM1JvS1Z4dUlDQjlYRzVjYmlBZ2RtRnlJSFpoYkNBOUlIUm9hWE5iYjJabWMyVjBJQ3NnTFMxaWVYUmxUR1Z1WjNSb1hWeHVJQ0IyWVhJZ2JYVnNJRDBnTVZ4dUlDQjNhR2xzWlNBb1lubDBaVXhsYm1kMGFDQStJREFnSmlZZ0tHMTFiQ0FxUFNBd2VERXdNQ2twSUh0Y2JpQWdJQ0IyWVd3Z0t6MGdkR2hwYzF0dlptWnpaWFFnS3lBdExXSjVkR1ZNWlc1bmRHaGRJQ29nYlhWc1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2RtRnNYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWNtVmhaRlZKYm5RNElEMGdablZ1WTNScGIyNGdjbVZoWkZWSmJuUTRJQ2h2Wm1aelpYUXNJRzV2UVhOelpYSjBLU0I3WEc0Z0lHOW1abk5sZENBOUlHOW1abk5sZENBK1BqNGdNRnh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0JqYUdWamEwOW1abk5sZENodlptWnpaWFFzSURFc0lIUm9hWE11YkdWdVozUm9LVnh1SUNCeVpYUjFjbTRnZEdocGMxdHZabVp6WlhSZFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1Y21WaFpGVkpiblF4Tmt4RklEMGdablZ1WTNScGIyNGdjbVZoWkZWSmJuUXhOa3hGSUNodlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJRzltWm5ObGRDQTlJRzltWm5ObGRDQStQajRnTUZ4dUlDQnBaaUFvSVc1dlFYTnpaWEowS1NCamFHVmphMDltWm5ObGRDaHZabVp6WlhRc0lESXNJSFJvYVhNdWJHVnVaM1JvS1Z4dUlDQnlaWFIxY200Z2RHaHBjMXR2Wm1aelpYUmRJSHdnS0hSb2FYTmJiMlptYzJWMElDc2dNVjBnUER3Z09DbGNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1eVpXRmtWVWx1ZERFMlFrVWdQU0JtZFc1amRHbHZiaUJ5WldGa1ZVbHVkREUyUWtVZ0tHOW1abk5sZEN3Z2JtOUJjM05sY25RcElIdGNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJRDQrUGlBd1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yVDJabWMyVjBLRzltWm5ObGRDd2dNaXdnZEdocGN5NXNaVzVuZEdncFhHNGdJSEpsZEhWeWJpQW9kR2hwYzF0dlptWnpaWFJkSUR3OElEZ3BJSHdnZEdocGMxdHZabVp6WlhRZ0t5QXhYVnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuSmxZV1JWU1c1ME16Sk1SU0E5SUdaMWJtTjBhVzl1SUhKbFlXUlZTVzUwTXpKTVJTQW9iMlptYzJWMExDQnViMEZ6YzJWeWRDa2dlMXh1SUNCdlptWnpaWFFnUFNCdlptWnpaWFFnUGo0K0lEQmNiaUFnYVdZZ0tDRnViMEZ6YzJWeWRDa2dZMmhsWTJ0UFptWnpaWFFvYjJabWMyVjBMQ0EwTENCMGFHbHpMbXhsYm1kMGFDbGNibHh1SUNCeVpYUjFjbTRnS0NoMGFHbHpXMjltWm5ObGRGMHBJSHhjYmlBZ0lDQWdJQ2gwYUdselcyOW1abk5sZENBcklERmRJRHc4SURncElIeGNiaUFnSUNBZ0lDaDBhR2x6VzI5bVpuTmxkQ0FySURKZElEdzhJREUyS1NrZ0sxeHVJQ0FnSUNBZ0tIUm9hWE5iYjJabWMyVjBJQ3NnTTEwZ0tpQXdlREV3TURBd01EQXBYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWNtVmhaRlZKYm5Rek1rSkZJRDBnWm5WdVkzUnBiMjRnY21WaFpGVkpiblF6TWtKRklDaHZabVp6WlhRc0lHNXZRWE56WlhKMEtTQjdYRzRnSUc5bVpuTmxkQ0E5SUc5bVpuTmxkQ0ErUGo0Z01GeHVJQ0JwWmlBb0lXNXZRWE56WlhKMEtTQmphR1ZqYTA5bVpuTmxkQ2h2Wm1aelpYUXNJRFFzSUhSb2FYTXViR1Z1WjNSb0tWeHVYRzRnSUhKbGRIVnliaUFvZEdocGMxdHZabVp6WlhSZElDb2dNSGd4TURBd01EQXdLU0FyWEc0Z0lDQWdLQ2gwYUdselcyOW1abk5sZENBcklERmRJRHc4SURFMktTQjhYRzRnSUNBZ0tIUm9hWE5iYjJabWMyVjBJQ3NnTWwwZ1BEd2dPQ2tnZkZ4dUlDQWdJSFJvYVhOYmIyWm1jMlYwSUNzZ00xMHBYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWNtVmhaRWx1ZEV4RklEMGdablZ1WTNScGIyNGdjbVZoWkVsdWRFeEZJQ2h2Wm1aelpYUXNJR0o1ZEdWTVpXNW5kR2dzSUc1dlFYTnpaWEowS1NCN1hHNGdJRzltWm5ObGRDQTlJRzltWm5ObGRDQStQajRnTUZ4dUlDQmllWFJsVEdWdVozUm9JRDBnWW5sMFpVeGxibWQwYUNBK1BqNGdNRnh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0JqYUdWamEwOW1abk5sZENodlptWnpaWFFzSUdKNWRHVk1aVzVuZEdnc0lIUm9hWE11YkdWdVozUm9LVnh1WEc0Z0lIWmhjaUIyWVd3Z1BTQjBhR2x6VzI5bVpuTmxkRjFjYmlBZ2RtRnlJRzExYkNBOUlERmNiaUFnZG1GeUlHa2dQU0F3WEc0Z0lIZG9hV3hsSUNncksya2dQQ0JpZVhSbFRHVnVaM1JvSUNZbUlDaHRkV3dnS2owZ01IZ3hNREFwS1NCN1hHNGdJQ0FnZG1Gc0lDczlJSFJvYVhOYmIyWm1jMlYwSUNzZ2FWMGdLaUJ0ZFd4Y2JpQWdmVnh1SUNCdGRXd2dLajBnTUhnNE1GeHVYRzRnSUdsbUlDaDJZV3dnUGowZ2JYVnNLU0IyWVd3Z0xUMGdUV0YwYUM1d2IzY29NaXdnT0NBcUlHSjVkR1ZNWlc1bmRHZ3BYRzVjYmlBZ2NtVjBkWEp1SUhaaGJGeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5KbFlXUkpiblJDUlNBOUlHWjFibU4wYVc5dUlISmxZV1JKYm5SQ1JTQW9iMlptYzJWMExDQmllWFJsVEdWdVozUm9MQ0J1YjBGemMyVnlkQ2tnZTF4dUlDQnZabVp6WlhRZ1BTQnZabVp6WlhRZ1BqNCtJREJjYmlBZ1lubDBaVXhsYm1kMGFDQTlJR0o1ZEdWTVpXNW5kR2dnUGo0K0lEQmNiaUFnYVdZZ0tDRnViMEZ6YzJWeWRDa2dZMmhsWTJ0UFptWnpaWFFvYjJabWMyVjBMQ0JpZVhSbFRHVnVaM1JvTENCMGFHbHpMbXhsYm1kMGFDbGNibHh1SUNCMllYSWdhU0E5SUdKNWRHVk1aVzVuZEdoY2JpQWdkbUZ5SUcxMWJDQTlJREZjYmlBZ2RtRnlJSFpoYkNBOUlIUm9hWE5iYjJabWMyVjBJQ3NnTFMxcFhWeHVJQ0IzYUdsc1pTQW9hU0ErSURBZ0ppWWdLRzExYkNBcVBTQXdlREV3TUNrcElIdGNiaUFnSUNCMllXd2dLejBnZEdocGMxdHZabVp6WlhRZ0t5QXRMV2xkSUNvZ2JYVnNYRzRnSUgxY2JpQWdiWFZzSUNvOUlEQjRPREJjYmx4dUlDQnBaaUFvZG1Gc0lENDlJRzExYkNrZ2RtRnNJQzA5SUUxaGRHZ3VjRzkzS0RJc0lEZ2dLaUJpZVhSbFRHVnVaM1JvS1Z4dVhHNGdJSEpsZEhWeWJpQjJZV3hjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNXlaV0ZrU1c1ME9DQTlJR1oxYm1OMGFXOXVJSEpsWVdSSmJuUTRJQ2h2Wm1aelpYUXNJRzV2UVhOelpYSjBLU0I3WEc0Z0lHOW1abk5sZENBOUlHOW1abk5sZENBK1BqNGdNRnh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0JqYUdWamEwOW1abk5sZENodlptWnpaWFFzSURFc0lIUm9hWE11YkdWdVozUm9LVnh1SUNCcFppQW9JU2gwYUdselcyOW1abk5sZEYwZ0ppQXdlRGd3S1NrZ2NtVjBkWEp1SUNoMGFHbHpXMjltWm5ObGRGMHBYRzRnSUhKbGRIVnliaUFvS0RCNFptWWdMU0IwYUdselcyOW1abk5sZEYwZ0t5QXhLU0FxSUMweEtWeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5KbFlXUkpiblF4Tmt4RklEMGdablZ1WTNScGIyNGdjbVZoWkVsdWRERTJURVVnS0c5bVpuTmxkQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdiMlptYzJWMElEMGdiMlptYzJWMElENCtQaUF3WEc0Z0lHbG1JQ2doYm05QmMzTmxjblFwSUdOb1pXTnJUMlptYzJWMEtHOW1abk5sZEN3Z01pd2dkR2hwY3k1c1pXNW5kR2dwWEc0Z0lIWmhjaUIyWVd3Z1BTQjBhR2x6VzI5bVpuTmxkRjBnZkNBb2RHaHBjMXR2Wm1aelpYUWdLeUF4WFNBOFBDQTRLVnh1SUNCeVpYUjFjbTRnS0haaGJDQW1JREI0T0RBd01Da2dQeUIyWVd3Z2ZDQXdlRVpHUmtZd01EQXdJRG9nZG1Gc1hHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1Y21WaFpFbHVkREUyUWtVZ1BTQm1kVzVqZEdsdmJpQnlaV0ZrU1c1ME1UWkNSU0FvYjJabWMyVjBMQ0J1YjBGemMyVnlkQ2tnZTF4dUlDQnZabVp6WlhRZ1BTQnZabVp6WlhRZ1BqNCtJREJjYmlBZ2FXWWdLQ0Z1YjBGemMyVnlkQ2tnWTJobFkydFBabVp6WlhRb2IyWm1jMlYwTENBeUxDQjBhR2x6TG14bGJtZDBhQ2xjYmlBZ2RtRnlJSFpoYkNBOUlIUm9hWE5iYjJabWMyVjBJQ3NnTVYwZ2ZDQW9kR2hwYzF0dlptWnpaWFJkSUR3OElEZ3BYRzRnSUhKbGRIVnliaUFvZG1Gc0lDWWdNSGc0TURBd0tTQS9JSFpoYkNCOElEQjRSa1pHUmpBd01EQWdPaUIyWVd4Y2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzV5WldGa1NXNTBNekpNUlNBOUlHWjFibU4wYVc5dUlISmxZV1JKYm5Rek1reEZJQ2h2Wm1aelpYUXNJRzV2UVhOelpYSjBLU0I3WEc0Z0lHOW1abk5sZENBOUlHOW1abk5sZENBK1BqNGdNRnh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0JqYUdWamEwOW1abk5sZENodlptWnpaWFFzSURRc0lIUm9hWE11YkdWdVozUm9LVnh1WEc0Z0lISmxkSFZ5YmlBb2RHaHBjMXR2Wm1aelpYUmRLU0I4WEc0Z0lDQWdLSFJvYVhOYmIyWm1jMlYwSUNzZ01WMGdQRHdnT0NrZ2ZGeHVJQ0FnSUNoMGFHbHpXMjltWm5ObGRDQXJJREpkSUR3OElERTJLU0I4WEc0Z0lDQWdLSFJvYVhOYmIyWm1jMlYwSUNzZ00xMGdQRHdnTWpRcFhHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1Y21WaFpFbHVkRE15UWtVZ1BTQm1kVzVqZEdsdmJpQnlaV0ZrU1c1ME16SkNSU0FvYjJabWMyVjBMQ0J1YjBGemMyVnlkQ2tnZTF4dUlDQnZabVp6WlhRZ1BTQnZabVp6WlhRZ1BqNCtJREJjYmlBZ2FXWWdLQ0Z1YjBGemMyVnlkQ2tnWTJobFkydFBabVp6WlhRb2IyWm1jMlYwTENBMExDQjBhR2x6TG14bGJtZDBhQ2xjYmx4dUlDQnlaWFIxY200Z0tIUm9hWE5iYjJabWMyVjBYU0E4UENBeU5Da2dmRnh1SUNBZ0lDaDBhR2x6VzI5bVpuTmxkQ0FySURGZElEdzhJREUyS1NCOFhHNGdJQ0FnS0hSb2FYTmJiMlptYzJWMElDc2dNbDBnUER3Z09Da2dmRnh1SUNBZ0lDaDBhR2x6VzI5bVpuTmxkQ0FySUROZEtWeHVmVnh1WEc1Q2RXWm1aWEl1Y0hKdmRHOTBlWEJsTG5KbFlXUkdiRzloZEV4RklEMGdablZ1WTNScGIyNGdjbVZoWkVac2IyRjBURVVnS0c5bVpuTmxkQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdiMlptYzJWMElEMGdiMlptYzJWMElENCtQaUF3WEc0Z0lHbG1JQ2doYm05QmMzTmxjblFwSUdOb1pXTnJUMlptYzJWMEtHOW1abk5sZEN3Z05Dd2dkR2hwY3k1c1pXNW5kR2dwWEc0Z0lISmxkSFZ5YmlCcFpXVmxOelUwTG5KbFlXUW9kR2hwY3l3Z2IyWm1jMlYwTENCMGNuVmxMQ0F5TXl3Z05DbGNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1eVpXRmtSbXh2WVhSQ1JTQTlJR1oxYm1OMGFXOXVJSEpsWVdSR2JHOWhkRUpGSUNodlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJRzltWm5ObGRDQTlJRzltWm5ObGRDQStQajRnTUZ4dUlDQnBaaUFvSVc1dlFYTnpaWEowS1NCamFHVmphMDltWm5ObGRDaHZabVp6WlhRc0lEUXNJSFJvYVhNdWJHVnVaM1JvS1Z4dUlDQnlaWFIxY200Z2FXVmxaVGMxTkM1eVpXRmtLSFJvYVhNc0lHOW1abk5sZEN3Z1ptRnNjMlVzSURJekxDQTBLVnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuSmxZV1JFYjNWaWJHVk1SU0E5SUdaMWJtTjBhVzl1SUhKbFlXUkViM1ZpYkdWTVJTQW9iMlptYzJWMExDQnViMEZ6YzJWeWRDa2dlMXh1SUNCdlptWnpaWFFnUFNCdlptWnpaWFFnUGo0K0lEQmNiaUFnYVdZZ0tDRnViMEZ6YzJWeWRDa2dZMmhsWTJ0UFptWnpaWFFvYjJabWMyVjBMQ0E0TENCMGFHbHpMbXhsYm1kMGFDbGNiaUFnY21WMGRYSnVJR2xsWldVM05UUXVjbVZoWkNoMGFHbHpMQ0J2Wm1aelpYUXNJSFJ5ZFdVc0lEVXlMQ0E0S1Z4dWZWeHVYRzVDZFdabVpYSXVjSEp2ZEc5MGVYQmxMbkpsWVdSRWIzVmliR1ZDUlNBOUlHWjFibU4wYVc5dUlISmxZV1JFYjNWaWJHVkNSU0FvYjJabWMyVjBMQ0J1YjBGemMyVnlkQ2tnZTF4dUlDQnZabVp6WlhRZ1BTQnZabVp6WlhRZ1BqNCtJREJjYmlBZ2FXWWdLQ0Z1YjBGemMyVnlkQ2tnWTJobFkydFBabVp6WlhRb2IyWm1jMlYwTENBNExDQjBhR2x6TG14bGJtZDBhQ2xjYmlBZ2NtVjBkWEp1SUdsbFpXVTNOVFF1Y21WaFpDaDBhR2x6TENCdlptWnpaWFFzSUdaaGJITmxMQ0ExTWl3Z09DbGNibjFjYmx4dVpuVnVZM1JwYjI0Z1kyaGxZMnRKYm5RZ0tHSjFaaXdnZG1Gc2RXVXNJRzltWm5ObGRDd2daWGgwTENCdFlYZ3NJRzFwYmlrZ2UxeHVJQ0JwWmlBb0lVSjFabVpsY2k1cGMwSjFabVpsY2loaWRXWXBLU0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkY0ltSjFabVpsY2x3aUlHRnlaM1Z0Wlc1MElHMTFjM1FnWW1VZ1lTQkNkV1ptWlhJZ2FXNXpkR0Z1WTJVbktWeHVJQ0JwWmlBb2RtRnNkV1VnUGlCdFlYZ2dmSHdnZG1Gc2RXVWdQQ0J0YVc0cElIUm9jbTkzSUc1bGR5QlNZVzVuWlVWeWNtOXlLQ2RjSW5aaGJIVmxYQ0lnWVhKbmRXMWxiblFnYVhNZ2IzVjBJRzltSUdKdmRXNWtjeWNwWEc0Z0lHbG1JQ2h2Wm1aelpYUWdLeUJsZUhRZ1BpQmlkV1l1YkdWdVozUm9LU0IwYUhKdmR5QnVaWGNnVW1GdVoyVkZjbkp2Y2lnblNXNWtaWGdnYjNWMElHOW1JSEpoYm1kbEp5bGNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1M2NtbDBaVlZKYm5STVJTQTlJR1oxYm1OMGFXOXVJSGR5YVhSbFZVbHVkRXhGSUNoMllXeDFaU3dnYjJabWMyVjBMQ0JpZVhSbFRHVnVaM1JvTENCdWIwRnpjMlZ5ZENrZ2UxeHVJQ0IyWVd4MVpTQTlJQ3QyWVd4MVpWeHVJQ0J2Wm1aelpYUWdQU0J2Wm1aelpYUWdQajQrSURCY2JpQWdZbmwwWlV4bGJtZDBhQ0E5SUdKNWRHVk1aVzVuZEdnZ1BqNCtJREJjYmlBZ2FXWWdLQ0Z1YjBGemMyVnlkQ2tnZTF4dUlDQWdJSFpoY2lCdFlYaENlWFJsY3lBOUlFMWhkR2d1Y0c5M0tESXNJRGdnS2lCaWVYUmxUR1Z1WjNSb0tTQXRJREZjYmlBZ0lDQmphR1ZqYTBsdWRDaDBhR2x6TENCMllXeDFaU3dnYjJabWMyVjBMQ0JpZVhSbFRHVnVaM1JvTENCdFlYaENlWFJsY3l3Z01DbGNiaUFnZlZ4dVhHNGdJSFpoY2lCdGRXd2dQU0F4WEc0Z0lIWmhjaUJwSUQwZ01GeHVJQ0IwYUdselcyOW1abk5sZEYwZ1BTQjJZV3gxWlNBbUlEQjRSa1pjYmlBZ2QyaHBiR1VnS0NzcmFTQThJR0o1ZEdWTVpXNW5kR2dnSmlZZ0tHMTFiQ0FxUFNBd2VERXdNQ2twSUh0Y2JpQWdJQ0IwYUdselcyOW1abk5sZENBcklHbGRJRDBnS0haaGJIVmxJQzhnYlhWc0tTQW1JREI0UmtaY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCdlptWnpaWFFnS3lCaWVYUmxUR1Z1WjNSb1hHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1ZDNKcGRHVlZTVzUwUWtVZ1BTQm1kVzVqZEdsdmJpQjNjbWwwWlZWSmJuUkNSU0FvZG1Gc2RXVXNJRzltWm5ObGRDd2dZbmwwWlV4bGJtZDBhQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdkbUZzZFdVZ1BTQXJkbUZzZFdWY2JpQWdiMlptYzJWMElEMGdiMlptYzJWMElENCtQaUF3WEc0Z0lHSjVkR1ZNWlc1bmRHZ2dQU0JpZVhSbFRHVnVaM1JvSUQ0K1BpQXdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJSHRjYmlBZ0lDQjJZWElnYldGNFFubDBaWE1nUFNCTllYUm9MbkJ2ZHlneUxDQTRJQ29nWW5sMFpVeGxibWQwYUNrZ0xTQXhYRzRnSUNBZ1kyaGxZMnRKYm5Rb2RHaHBjeXdnZG1Gc2RXVXNJRzltWm5ObGRDd2dZbmwwWlV4bGJtZDBhQ3dnYldGNFFubDBaWE1zSURBcFhHNGdJSDFjYmx4dUlDQjJZWElnYVNBOUlHSjVkR1ZNWlc1bmRHZ2dMU0F4WEc0Z0lIWmhjaUJ0ZFd3Z1BTQXhYRzRnSUhSb2FYTmJiMlptYzJWMElDc2dhVjBnUFNCMllXeDFaU0FtSURCNFJrWmNiaUFnZDJocGJHVWdLQzB0YVNBK1BTQXdJQ1ltSUNodGRXd2dLajBnTUhneE1EQXBLU0I3WEc0Z0lDQWdkR2hwYzF0dlptWnpaWFFnS3lCcFhTQTlJQ2gyWVd4MVpTQXZJRzExYkNrZ0ppQXdlRVpHWEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnYjJabWMyVjBJQ3NnWW5sMFpVeGxibWQwYUZ4dWZWeHVYRzVDZFdabVpYSXVjSEp2ZEc5MGVYQmxMbmR5YVhSbFZVbHVkRGdnUFNCbWRXNWpkR2x2YmlCM2NtbDBaVlZKYm5RNElDaDJZV3gxWlN3Z2IyWm1jMlYwTENCdWIwRnpjMlZ5ZENrZ2UxeHVJQ0IyWVd4MVpTQTlJQ3QyWVd4MVpWeHVJQ0J2Wm1aelpYUWdQU0J2Wm1aelpYUWdQajQrSURCY2JpQWdhV1lnS0NGdWIwRnpjMlZ5ZENrZ1kyaGxZMnRKYm5Rb2RHaHBjeXdnZG1Gc2RXVXNJRzltWm5ObGRDd2dNU3dnTUhobVppd2dNQ2xjYmlBZ2RHaHBjMXR2Wm1aelpYUmRJRDBnS0haaGJIVmxJQ1lnTUhobVppbGNiaUFnY21WMGRYSnVJRzltWm5ObGRDQXJJREZjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNTNjbWwwWlZWSmJuUXhOa3hGSUQwZ1puVnVZM1JwYjI0Z2QzSnBkR1ZWU1c1ME1UWk1SU0FvZG1Gc2RXVXNJRzltWm5ObGRDd2dibTlCYzNObGNuUXBJSHRjYmlBZ2RtRnNkV1VnUFNBcmRtRnNkV1ZjYmlBZ2IyWm1jMlYwSUQwZ2IyWm1jMlYwSUQ0K1BpQXdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJR05vWldOclNXNTBLSFJvYVhNc0lIWmhiSFZsTENCdlptWnpaWFFzSURJc0lEQjRabVptWml3Z01DbGNiaUFnZEdocGMxdHZabVp6WlhSZElEMGdLSFpoYkhWbElDWWdNSGhtWmlsY2JpQWdkR2hwYzF0dlptWnpaWFFnS3lBeFhTQTlJQ2gyWVd4MVpTQStQajRnT0NsY2JpQWdjbVYwZFhKdUlHOW1abk5sZENBcklESmNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1M2NtbDBaVlZKYm5ReE5rSkZJRDBnWm5WdVkzUnBiMjRnZDNKcGRHVlZTVzUwTVRaQ1JTQW9kbUZzZFdVc0lHOW1abk5sZEN3Z2JtOUJjM05sY25RcElIdGNiaUFnZG1Gc2RXVWdQU0FyZG1Gc2RXVmNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJRDQrUGlBd1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yU1c1MEtIUm9hWE1zSUhaaGJIVmxMQ0J2Wm1aelpYUXNJRElzSURCNFptWm1aaXdnTUNsY2JpQWdkR2hwYzF0dlptWnpaWFJkSUQwZ0tIWmhiSFZsSUQ0K1BpQTRLVnh1SUNCMGFHbHpXMjltWm5ObGRDQXJJREZkSUQwZ0tIWmhiSFZsSUNZZ01IaG1aaWxjYmlBZ2NtVjBkWEp1SUc5bVpuTmxkQ0FySURKY2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzUzY21sMFpWVkpiblF6TWt4RklEMGdablZ1WTNScGIyNGdkM0pwZEdWVlNXNTBNekpNUlNBb2RtRnNkV1VzSUc5bVpuTmxkQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdkbUZzZFdVZ1BTQXJkbUZzZFdWY2JpQWdiMlptYzJWMElEMGdiMlptYzJWMElENCtQaUF3WEc0Z0lHbG1JQ2doYm05QmMzTmxjblFwSUdOb1pXTnJTVzUwS0hSb2FYTXNJSFpoYkhWbExDQnZabVp6WlhRc0lEUXNJREI0Wm1abVptWm1abVlzSURBcFhHNGdJSFJvYVhOYmIyWm1jMlYwSUNzZ00xMGdQU0FvZG1Gc2RXVWdQajQrSURJMEtWeHVJQ0IwYUdselcyOW1abk5sZENBcklESmRJRDBnS0haaGJIVmxJRDQrUGlBeE5pbGNiaUFnZEdocGMxdHZabVp6WlhRZ0t5QXhYU0E5SUNoMllXeDFaU0ErUGo0Z09DbGNiaUFnZEdocGMxdHZabVp6WlhSZElEMGdLSFpoYkhWbElDWWdNSGhtWmlsY2JpQWdjbVYwZFhKdUlHOW1abk5sZENBcklEUmNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1M2NtbDBaVlZKYm5Rek1rSkZJRDBnWm5WdVkzUnBiMjRnZDNKcGRHVlZTVzUwTXpKQ1JTQW9kbUZzZFdVc0lHOW1abk5sZEN3Z2JtOUJjM05sY25RcElIdGNiaUFnZG1Gc2RXVWdQU0FyZG1Gc2RXVmNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJRDQrUGlBd1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yU1c1MEtIUm9hWE1zSUhaaGJIVmxMQ0J2Wm1aelpYUXNJRFFzSURCNFptWm1abVptWm1Zc0lEQXBYRzRnSUhSb2FYTmJiMlptYzJWMFhTQTlJQ2gyWVd4MVpTQStQajRnTWpRcFhHNGdJSFJvYVhOYmIyWm1jMlYwSUNzZ01WMGdQU0FvZG1Gc2RXVWdQajQrSURFMktWeHVJQ0IwYUdselcyOW1abk5sZENBcklESmRJRDBnS0haaGJIVmxJRDQrUGlBNEtWeHVJQ0IwYUdselcyOW1abk5sZENBcklETmRJRDBnS0haaGJIVmxJQ1lnTUhobVppbGNiaUFnY21WMGRYSnVJRzltWm5ObGRDQXJJRFJjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNTNjbWwwWlVsdWRFeEZJRDBnWm5WdVkzUnBiMjRnZDNKcGRHVkpiblJNUlNBb2RtRnNkV1VzSUc5bVpuTmxkQ3dnWW5sMFpVeGxibWQwYUN3Z2JtOUJjM05sY25RcElIdGNiaUFnZG1Gc2RXVWdQU0FyZG1Gc2RXVmNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJRDQrUGlBd1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElIdGNiaUFnSUNCMllYSWdiR2x0YVhRZ1BTQk5ZWFJvTG5CdmR5Z3lMQ0FvT0NBcUlHSjVkR1ZNWlc1bmRHZ3BJQzBnTVNsY2JseHVJQ0FnSUdOb1pXTnJTVzUwS0hSb2FYTXNJSFpoYkhWbExDQnZabVp6WlhRc0lHSjVkR1ZNWlc1bmRHZ3NJR3hwYldsMElDMGdNU3dnTFd4cGJXbDBLVnh1SUNCOVhHNWNiaUFnZG1GeUlHa2dQU0F3WEc0Z0lIWmhjaUJ0ZFd3Z1BTQXhYRzRnSUhaaGNpQnpkV0lnUFNBd1hHNGdJSFJvYVhOYmIyWm1jMlYwWFNBOUlIWmhiSFZsSUNZZ01IaEdSbHh1SUNCM2FHbHNaU0FvS3l0cElEd2dZbmwwWlV4bGJtZDBhQ0FtSmlBb2JYVnNJQ285SURCNE1UQXdLU2tnZTF4dUlDQWdJR2xtSUNoMllXeDFaU0E4SURBZ0ppWWdjM1ZpSUQwOVBTQXdJQ1ltSUhSb2FYTmJiMlptYzJWMElDc2dhU0F0SURGZElDRTlQU0F3S1NCN1hHNGdJQ0FnSUNCemRXSWdQU0F4WEc0Z0lDQWdmVnh1SUNBZ0lIUm9hWE5iYjJabWMyVjBJQ3NnYVYwZ1BTQW9LSFpoYkhWbElDOGdiWFZzS1NBK1BpQXdLU0F0SUhOMVlpQW1JREI0UmtaY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCdlptWnpaWFFnS3lCaWVYUmxUR1Z1WjNSb1hHNTlYRzVjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1ZDNKcGRHVkpiblJDUlNBOUlHWjFibU4wYVc5dUlIZHlhWFJsU1c1MFFrVWdLSFpoYkhWbExDQnZabVp6WlhRc0lHSjVkR1ZNWlc1bmRHZ3NJRzV2UVhOelpYSjBLU0I3WEc0Z0lIWmhiSFZsSUQwZ0szWmhiSFZsWEc0Z0lHOW1abk5sZENBOUlHOW1abk5sZENBK1BqNGdNRnh1SUNCcFppQW9JVzV2UVhOelpYSjBLU0I3WEc0Z0lDQWdkbUZ5SUd4cGJXbDBJRDBnVFdGMGFDNXdiM2NvTWl3Z0tEZ2dLaUJpZVhSbFRHVnVaM1JvS1NBdElERXBYRzVjYmlBZ0lDQmphR1ZqYTBsdWRDaDBhR2x6TENCMllXeDFaU3dnYjJabWMyVjBMQ0JpZVhSbFRHVnVaM1JvTENCc2FXMXBkQ0F0SURFc0lDMXNhVzFwZENsY2JpQWdmVnh1WEc0Z0lIWmhjaUJwSUQwZ1lubDBaVXhsYm1kMGFDQXRJREZjYmlBZ2RtRnlJRzExYkNBOUlERmNiaUFnZG1GeUlITjFZaUE5SURCY2JpQWdkR2hwYzF0dlptWnpaWFFnS3lCcFhTQTlJSFpoYkhWbElDWWdNSGhHUmx4dUlDQjNhR2xzWlNBb0xTMXBJRDQ5SURBZ0ppWWdLRzExYkNBcVBTQXdlREV3TUNrcElIdGNiaUFnSUNCcFppQW9kbUZzZFdVZ1BDQXdJQ1ltSUhOMVlpQTlQVDBnTUNBbUppQjBhR2x6VzI5bVpuTmxkQ0FySUdrZ0t5QXhYU0FoUFQwZ01Da2dlMXh1SUNBZ0lDQWdjM1ZpSUQwZ01WeHVJQ0FnSUgxY2JpQWdJQ0IwYUdselcyOW1abk5sZENBcklHbGRJRDBnS0NoMllXeDFaU0F2SUcxMWJDa2dQajRnTUNrZ0xTQnpkV0lnSmlBd2VFWkdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdiMlptYzJWMElDc2dZbmwwWlV4bGJtZDBhRnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuZHlhWFJsU1c1ME9DQTlJR1oxYm1OMGFXOXVJSGR5YVhSbFNXNTBPQ0FvZG1Gc2RXVXNJRzltWm5ObGRDd2dibTlCYzNObGNuUXBJSHRjYmlBZ2RtRnNkV1VnUFNBcmRtRnNkV1ZjYmlBZ2IyWm1jMlYwSUQwZ2IyWm1jMlYwSUQ0K1BpQXdYRzRnSUdsbUlDZ2hibTlCYzNObGNuUXBJR05vWldOclNXNTBLSFJvYVhNc0lIWmhiSFZsTENCdlptWnpaWFFzSURFc0lEQjROMllzSUMwd2VEZ3dLVnh1SUNCcFppQW9kbUZzZFdVZ1BDQXdLU0IyWVd4MVpTQTlJREI0Wm1ZZ0t5QjJZV3gxWlNBcklERmNiaUFnZEdocGMxdHZabVp6WlhSZElEMGdLSFpoYkhWbElDWWdNSGhtWmlsY2JpQWdjbVYwZFhKdUlHOW1abk5sZENBcklERmNibjFjYmx4dVFuVm1abVZ5TG5CeWIzUnZkSGx3WlM1M2NtbDBaVWx1ZERFMlRFVWdQU0JtZFc1amRHbHZiaUIzY21sMFpVbHVkREUyVEVVZ0tIWmhiSFZsTENCdlptWnpaWFFzSUc1dlFYTnpaWEowS1NCN1hHNGdJSFpoYkhWbElEMGdLM1poYkhWbFhHNGdJRzltWm5ObGRDQTlJRzltWm5ObGRDQStQajRnTUZ4dUlDQnBaaUFvSVc1dlFYTnpaWEowS1NCamFHVmphMGx1ZENoMGFHbHpMQ0IyWVd4MVpTd2diMlptYzJWMExDQXlMQ0F3ZURkbVptWXNJQzB3ZURnd01EQXBYRzRnSUhSb2FYTmJiMlptYzJWMFhTQTlJQ2gyWVd4MVpTQW1JREI0Wm1ZcFhHNGdJSFJvYVhOYmIyWm1jMlYwSUNzZ01WMGdQU0FvZG1Gc2RXVWdQajQrSURncFhHNGdJSEpsZEhWeWJpQnZabVp6WlhRZ0t5QXlYRzU5WEc1Y2JrSjFabVpsY2k1d2NtOTBiM1I1Y0dVdWQzSnBkR1ZKYm5ReE5rSkZJRDBnWm5WdVkzUnBiMjRnZDNKcGRHVkpiblF4TmtKRklDaDJZV3gxWlN3Z2IyWm1jMlYwTENCdWIwRnpjMlZ5ZENrZ2UxeHVJQ0IyWVd4MVpTQTlJQ3QyWVd4MVpWeHVJQ0J2Wm1aelpYUWdQU0J2Wm1aelpYUWdQajQrSURCY2JpQWdhV1lnS0NGdWIwRnpjMlZ5ZENrZ1kyaGxZMnRKYm5Rb2RHaHBjeXdnZG1Gc2RXVXNJRzltWm5ObGRDd2dNaXdnTUhnM1ptWm1MQ0F0TUhnNE1EQXdLVnh1SUNCMGFHbHpXMjltWm5ObGRGMGdQU0FvZG1Gc2RXVWdQajQrSURncFhHNGdJSFJvYVhOYmIyWm1jMlYwSUNzZ01WMGdQU0FvZG1Gc2RXVWdKaUF3ZUdabUtWeHVJQ0J5WlhSMWNtNGdiMlptYzJWMElDc2dNbHh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuZHlhWFJsU1c1ME16Sk1SU0E5SUdaMWJtTjBhVzl1SUhkeWFYUmxTVzUwTXpKTVJTQW9kbUZzZFdVc0lHOW1abk5sZEN3Z2JtOUJjM05sY25RcElIdGNiaUFnZG1Gc2RXVWdQU0FyZG1Gc2RXVmNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJRDQrUGlBd1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElHTm9aV05yU1c1MEtIUm9hWE1zSUhaaGJIVmxMQ0J2Wm1aelpYUXNJRFFzSURCNE4yWm1abVptWm1Zc0lDMHdlRGd3TURBd01EQXdLVnh1SUNCMGFHbHpXMjltWm5ObGRGMGdQU0FvZG1Gc2RXVWdKaUF3ZUdabUtWeHVJQ0IwYUdselcyOW1abk5sZENBcklERmRJRDBnS0haaGJIVmxJRDQrUGlBNEtWeHVJQ0IwYUdselcyOW1abk5sZENBcklESmRJRDBnS0haaGJIVmxJRDQrUGlBeE5pbGNiaUFnZEdocGMxdHZabVp6WlhRZ0t5QXpYU0E5SUNoMllXeDFaU0ErUGo0Z01qUXBYRzRnSUhKbGRIVnliaUJ2Wm1aelpYUWdLeUEwWEc1OVhHNWNia0oxWm1abGNpNXdjbTkwYjNSNWNHVXVkM0pwZEdWSmJuUXpNa0pGSUQwZ1puVnVZM1JwYjI0Z2QzSnBkR1ZKYm5Rek1rSkZJQ2gyWVd4MVpTd2diMlptYzJWMExDQnViMEZ6YzJWeWRDa2dlMXh1SUNCMllXeDFaU0E5SUN0MllXeDFaVnh1SUNCdlptWnpaWFFnUFNCdlptWnpaWFFnUGo0K0lEQmNiaUFnYVdZZ0tDRnViMEZ6YzJWeWRDa2dZMmhsWTJ0SmJuUW9kR2hwY3l3Z2RtRnNkV1VzSUc5bVpuTmxkQ3dnTkN3Z01IZzNabVptWm1abVppd2dMVEI0T0RBd01EQXdNREFwWEc0Z0lHbG1JQ2gyWVd4MVpTQThJREFwSUhaaGJIVmxJRDBnTUhobVptWm1abVptWmlBcklIWmhiSFZsSUNzZ01WeHVJQ0IwYUdselcyOW1abk5sZEYwZ1BTQW9kbUZzZFdVZ1BqNCtJREkwS1Z4dUlDQjBhR2x6VzI5bVpuTmxkQ0FySURGZElEMGdLSFpoYkhWbElENCtQaUF4TmlsY2JpQWdkR2hwYzF0dlptWnpaWFFnS3lBeVhTQTlJQ2gyWVd4MVpTQStQajRnT0NsY2JpQWdkR2hwYzF0dlptWnpaWFFnS3lBelhTQTlJQ2gyWVd4MVpTQW1JREI0Wm1ZcFhHNGdJSEpsZEhWeWJpQnZabVp6WlhRZ0t5QTBYRzU5WEc1Y2JtWjFibU4wYVc5dUlHTm9aV05yU1VWRlJUYzFOQ0FvWW5WbUxDQjJZV3gxWlN3Z2IyWm1jMlYwTENCbGVIUXNJRzFoZUN3Z2JXbHVLU0I3WEc0Z0lHbG1JQ2h2Wm1aelpYUWdLeUJsZUhRZ1BpQmlkV1l1YkdWdVozUm9LU0IwYUhKdmR5QnVaWGNnVW1GdVoyVkZjbkp2Y2lnblNXNWtaWGdnYjNWMElHOW1JSEpoYm1kbEp5bGNiaUFnYVdZZ0tHOW1abk5sZENBOElEQXBJSFJvY205M0lHNWxkeUJTWVc1blpVVnljbTl5S0NkSmJtUmxlQ0J2ZFhRZ2IyWWdjbUZ1WjJVbktWeHVmVnh1WEc1bWRXNWpkR2x2YmlCM2NtbDBaVVpzYjJGMElDaGlkV1lzSUhaaGJIVmxMQ0J2Wm1aelpYUXNJR3hwZEhSc1pVVnVaR2xoYml3Z2JtOUJjM05sY25RcElIdGNiaUFnZG1Gc2RXVWdQU0FyZG1Gc2RXVmNiaUFnYjJabWMyVjBJRDBnYjJabWMyVjBJRDQrUGlBd1hHNGdJR2xtSUNnaGJtOUJjM05sY25RcElIdGNiaUFnSUNCamFHVmphMGxGUlVVM05UUW9ZblZtTENCMllXeDFaU3dnYjJabWMyVjBMQ0EwTENBekxqUXdNamd5TXpRMk5qTTROVEk0T0RabEt6TTRMQ0F0TXk0ME1ESTRNak0wTmpZek9EVXlPRGcyWlNzek9DbGNiaUFnZlZ4dUlDQnBaV1ZsTnpVMExuZHlhWFJsS0dKMVppd2dkbUZzZFdVc0lHOW1abk5sZEN3Z2JHbDBkR3hsUlc1a2FXRnVMQ0F5TXl3Z05DbGNiaUFnY21WMGRYSnVJRzltWm5ObGRDQXJJRFJjYm4xY2JseHVRblZtWm1WeUxuQnliM1J2ZEhsd1pTNTNjbWwwWlVac2IyRjBURVVnUFNCbWRXNWpkR2x2YmlCM2NtbDBaVVpzYjJGMFRFVWdLSFpoYkhWbExDQnZabVp6WlhRc0lHNXZRWE56WlhKMEtTQjdYRzRnSUhKbGRIVnliaUIzY21sMFpVWnNiMkYwS0hSb2FYTXNJSFpoYkhWbExDQnZabVp6WlhRc0lIUnlkV1VzSUc1dlFYTnpaWEowS1Z4dWZWeHVYRzVDZFdabVpYSXVjSEp2ZEc5MGVYQmxMbmR5YVhSbFJteHZZWFJDUlNBOUlHWjFibU4wYVc5dUlIZHlhWFJsUm14dllYUkNSU0FvZG1Gc2RXVXNJRzltWm5ObGRDd2dibTlCYzNObGNuUXBJSHRjYmlBZ2NtVjBkWEp1SUhkeWFYUmxSbXh2WVhRb2RHaHBjeXdnZG1Gc2RXVXNJRzltWm5ObGRDd2dabUZzYzJVc0lHNXZRWE56WlhKMEtWeHVmVnh1WEc1bWRXNWpkR2x2YmlCM2NtbDBaVVJ2ZFdKc1pTQW9ZblZtTENCMllXeDFaU3dnYjJabWMyVjBMQ0JzYVhSMGJHVkZibVJwWVc0c0lHNXZRWE56WlhKMEtTQjdYRzRnSUhaaGJIVmxJRDBnSzNaaGJIVmxYRzRnSUc5bVpuTmxkQ0E5SUc5bVpuTmxkQ0ErUGo0Z01GeHVJQ0JwWmlBb0lXNXZRWE56WlhKMEtTQjdYRzRnSUNBZ1kyaGxZMnRKUlVWRk56VTBLR0oxWml3Z2RtRnNkV1VzSUc5bVpuTmxkQ3dnT0N3Z01TNDNPVGMyT1RNeE16UTROakl6TVRVM1JTc3pNRGdzSUMweExqYzVOelk1TXpFek5EZzJNak14TlRkRkt6TXdPQ2xjYmlBZ2ZWeHVJQ0JwWldWbE56VTBMbmR5YVhSbEtHSjFaaXdnZG1Gc2RXVXNJRzltWm5ObGRDd2diR2wwZEd4bFJXNWthV0Z1TENBMU1pd2dPQ2xjYmlBZ2NtVjBkWEp1SUc5bVpuTmxkQ0FySURoY2JuMWNibHh1UW5WbVptVnlMbkJ5YjNSdmRIbHdaUzUzY21sMFpVUnZkV0pzWlV4RklEMGdablZ1WTNScGIyNGdkM0pwZEdWRWIzVmliR1ZNUlNBb2RtRnNkV1VzSUc5bVpuTmxkQ3dnYm05QmMzTmxjblFwSUh0Y2JpQWdjbVYwZFhKdUlIZHlhWFJsUkc5MVlteGxLSFJvYVhNc0lIWmhiSFZsTENCdlptWnpaWFFzSUhSeWRXVXNJRzV2UVhOelpYSjBLVnh1ZlZ4dVhHNUNkV1ptWlhJdWNISnZkRzkwZVhCbExuZHlhWFJsUkc5MVlteGxRa1VnUFNCbWRXNWpkR2x2YmlCM2NtbDBaVVJ2ZFdKc1pVSkZJQ2gyWVd4MVpTd2diMlptYzJWMExDQnViMEZ6YzJWeWRDa2dlMXh1SUNCeVpYUjFjbTRnZDNKcGRHVkViM1ZpYkdVb2RHaHBjeXdnZG1Gc2RXVXNJRzltWm5ObGRDd2dabUZzYzJVc0lHNXZRWE56WlhKMEtWeHVmVnh1WEc0dkx5QmpiM0I1S0hSaGNtZGxkRUoxWm1abGNpd2dkR0Z5WjJWMFUzUmhjblE5TUN3Z2MyOTFjbU5sVTNSaGNuUTlNQ3dnYzI5MWNtTmxSVzVrUFdKMVptWmxjaTVzWlc1bmRHZ3BYRzVDZFdabVpYSXVjSEp2ZEc5MGVYQmxMbU52Y0hrZ1BTQm1kVzVqZEdsdmJpQmpiM0I1SUNoMFlYSm5aWFFzSUhSaGNtZGxkRk4wWVhKMExDQnpkR0Z5ZEN3Z1pXNWtLU0I3WEc0Z0lHbG1JQ2doYzNSaGNuUXBJSE4wWVhKMElEMGdNRnh1SUNCcFppQW9JV1Z1WkNBbUppQmxibVFnSVQwOUlEQXBJR1Z1WkNBOUlIUm9hWE11YkdWdVozUm9YRzRnSUdsbUlDaDBZWEpuWlhSVGRHRnlkQ0ErUFNCMFlYSm5aWFF1YkdWdVozUm9LU0IwWVhKblpYUlRkR0Z5ZENBOUlIUmhjbWRsZEM1c1pXNW5kR2hjYmlBZ2FXWWdLQ0YwWVhKblpYUlRkR0Z5ZENrZ2RHRnlaMlYwVTNSaGNuUWdQU0F3WEc0Z0lHbG1JQ2hsYm1RZ1BpQXdJQ1ltSUdWdVpDQThJSE4wWVhKMEtTQmxibVFnUFNCemRHRnlkRnh1WEc0Z0lDOHZJRU52Y0hrZ01DQmllWFJsY3pzZ2QyVW5jbVVnWkc5dVpWeHVJQ0JwWmlBb1pXNWtJRDA5UFNCemRHRnlkQ2tnY21WMGRYSnVJREJjYmlBZ2FXWWdLSFJoY21kbGRDNXNaVzVuZEdnZ1BUMDlJREFnZkh3Z2RHaHBjeTVzWlc1bmRHZ2dQVDA5SURBcElISmxkSFZ5YmlBd1hHNWNiaUFnTHk4Z1JtRjBZV3dnWlhKeWIzSWdZMjl1WkdsMGFXOXVjMXh1SUNCcFppQW9kR0Z5WjJWMFUzUmhjblFnUENBd0tTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGSmhibWRsUlhKeWIzSW9KM1JoY21kbGRGTjBZWEowSUc5MWRDQnZaaUJpYjNWdVpITW5LVnh1SUNCOVhHNGdJR2xtSUNoemRHRnlkQ0E4SURBZ2ZId2djM1JoY25RZ1BqMGdkR2hwY3k1c1pXNW5kR2dwSUhSb2NtOTNJRzVsZHlCU1lXNW5aVVZ5Y205eUtDZHpiM1Z5WTJWVGRHRnlkQ0J2ZFhRZ2IyWWdZbTkxYm1Sekp5bGNiaUFnYVdZZ0tHVnVaQ0E4SURBcElIUm9jbTkzSUc1bGR5QlNZVzVuWlVWeWNtOXlLQ2R6YjNWeVkyVkZibVFnYjNWMElHOW1JR0p2ZFc1a2N5Y3BYRzVjYmlBZ0x5OGdRWEpsSUhkbElHOXZZajljYmlBZ2FXWWdLR1Z1WkNBK0lIUm9hWE11YkdWdVozUm9LU0JsYm1RZ1BTQjBhR2x6TG14bGJtZDBhRnh1SUNCcFppQW9kR0Z5WjJWMExteGxibWQwYUNBdElIUmhjbWRsZEZOMFlYSjBJRHdnWlc1a0lDMGdjM1JoY25RcElIdGNiaUFnSUNCbGJtUWdQU0IwWVhKblpYUXViR1Z1WjNSb0lDMGdkR0Z5WjJWMFUzUmhjblFnS3lCemRHRnlkRnh1SUNCOVhHNWNiaUFnZG1GeUlHeGxiaUE5SUdWdVpDQXRJSE4wWVhKMFhHNGdJSFpoY2lCcFhHNWNiaUFnYVdZZ0tIUm9hWE1nUFQwOUlIUmhjbWRsZENBbUppQnpkR0Z5ZENBOElIUmhjbWRsZEZOMFlYSjBJQ1ltSUhSaGNtZGxkRk4wWVhKMElEd2daVzVrS1NCN1hHNGdJQ0FnTHk4Z1pHVnpZMlZ1WkdsdVp5QmpiM0I1SUdaeWIyMGdaVzVrWEc0Z0lDQWdabTl5SUNocElEMGdiR1Z1SUMwZ01Uc2dhU0ErUFNBd095QXRMV2twSUh0Y2JpQWdJQ0FnSUhSaGNtZGxkRnRwSUNzZ2RHRnlaMlYwVTNSaGNuUmRJRDBnZEdocGMxdHBJQ3NnYzNSaGNuUmRYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdhV1lnS0d4bGJpQThJREV3TURBcElIdGNiaUFnSUNBdkx5QmhjMk5sYm1ScGJtY2dZMjl3ZVNCbWNtOXRJSE4wWVhKMFhHNGdJQ0FnWm05eUlDaHBJRDBnTURzZ2FTQThJR3hsYmpzZ0t5dHBLU0I3WEc0Z0lDQWdJQ0IwWVhKblpYUmJhU0FySUhSaGNtZGxkRk4wWVhKMFhTQTlJSFJvYVhOYmFTQXJJSE4wWVhKMFhWeHVJQ0FnSUgxY2JpQWdmU0JsYkhObElIdGNiaUFnSUNCVmFXNTBPRUZ5Y21GNUxuQnliM1J2ZEhsd1pTNXpaWFF1WTJGc2JDaGNiaUFnSUNBZ0lIUmhjbWRsZEN4Y2JpQWdJQ0FnSUhSb2FYTXVjM1ZpWVhKeVlYa29jM1JoY25Rc0lITjBZWEowSUNzZ2JHVnVLU3hjYmlBZ0lDQWdJSFJoY21kbGRGTjBZWEowWEc0Z0lDQWdLVnh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR3hsYmx4dWZWeHVYRzR2THlCVmMyRm5aVHBjYmk4dklDQWdJR0oxWm1abGNpNW1hV3hzS0c1MWJXSmxjbHNzSUc5bVpuTmxkRnNzSUdWdVpGMWRLVnh1THk4Z0lDQWdZblZtWm1WeUxtWnBiR3dvWW5WbVptVnlXeXdnYjJabWMyVjBXeXdnWlc1a1hWMHBYRzR2THlBZ0lDQmlkV1ptWlhJdVptbHNiQ2h6ZEhKcGJtZGJMQ0J2Wm1aelpYUmJMQ0JsYm1SZFhWc3NJR1Z1WTI5a2FXNW5YU2xjYmtKMVptWmxjaTV3Y205MGIzUjVjR1V1Wm1sc2JDQTlJR1oxYm1OMGFXOXVJR1pwYkd3Z0tIWmhiQ3dnYzNSaGNuUXNJR1Z1WkN3Z1pXNWpiMlJwYm1jcElIdGNiaUFnTHk4Z1NHRnVaR3hsSUhOMGNtbHVaeUJqWVhObGN6cGNiaUFnYVdZZ0tIUjVjR1Z2WmlCMllXd2dQVDA5SUNkemRISnBibWNuS1NCN1hHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCemRHRnlkQ0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNBZ0lHVnVZMjlrYVc1bklEMGdjM1JoY25SY2JpQWdJQ0FnSUhOMFlYSjBJRDBnTUZ4dUlDQWdJQ0FnWlc1a0lEMGdkR2hwY3k1c1pXNW5kR2hjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppQmxibVFnUFQwOUlDZHpkSEpwYm1jbktTQjdYRzRnSUNBZ0lDQmxibU52WkdsdVp5QTlJR1Z1WkZ4dUlDQWdJQ0FnWlc1a0lEMGdkR2hwY3k1c1pXNW5kR2hjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLSFpoYkM1c1pXNW5kR2dnUFQwOUlERXBJSHRjYmlBZ0lDQWdJSFpoY2lCamIyUmxJRDBnZG1Gc0xtTm9ZWEpEYjJSbFFYUW9NQ2xjYmlBZ0lDQWdJR2xtSUNoamIyUmxJRHdnTWpVMktTQjdYRzRnSUNBZ0lDQWdJSFpoYkNBOUlHTnZaR1ZjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR1Z1WTI5a2FXNW5JQ0U5UFNCMWJtUmxabWx1WldRZ0ppWWdkSGx3Wlc5bUlHVnVZMjlrYVc1bklDRTlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2lnblpXNWpiMlJwYm1jZ2JYVnpkQ0JpWlNCaElITjBjbWx1WnljcFhHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNoMGVYQmxiMllnWlc1amIyUnBibWNnUFQwOUlDZHpkSEpwYm1jbklDWW1JQ0ZDZFdabVpYSXVhWE5GYm1OdlpHbHVaeWhsYm1OdlpHbHVaeWtwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0oxVnVhMjV2ZDI0Z1pXNWpiMlJwYm1jNklDY2dLeUJsYm1OdlpHbHVaeWxjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUhaaGJDQTlQVDBnSjI1MWJXSmxjaWNwSUh0Y2JpQWdJQ0IyWVd3Z1BTQjJZV3dnSmlBeU5UVmNiaUFnZlZ4dVhHNGdJQzh2SUVsdWRtRnNhV1FnY21GdVoyVnpJR0Z5WlNCdWIzUWdjMlYwSUhSdklHRWdaR1ZtWVhWc2RDd2djMjhnWTJGdUlISmhibWRsSUdOb1pXTnJJR1ZoY214NUxseHVJQ0JwWmlBb2MzUmhjblFnUENBd0lIeDhJSFJvYVhNdWJHVnVaM1JvSUR3Z2MzUmhjblFnZkh3Z2RHaHBjeTVzWlc1bmRHZ2dQQ0JsYm1RcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1VtRnVaMlZGY25KdmNpZ25UM1YwSUc5bUlISmhibWRsSUdsdVpHVjRKeWxjYmlBZ2ZWeHVYRzRnSUdsbUlDaGxibVFnUEQwZ2MzUmhjblFwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwYzF4dUlDQjlYRzVjYmlBZ2MzUmhjblFnUFNCemRHRnlkQ0ErUGo0Z01GeHVJQ0JsYm1RZ1BTQmxibVFnUFQwOUlIVnVaR1ZtYVc1bFpDQS9JSFJvYVhNdWJHVnVaM1JvSURvZ1pXNWtJRDQrUGlBd1hHNWNiaUFnYVdZZ0tDRjJZV3dwSUhaaGJDQTlJREJjYmx4dUlDQjJZWElnYVZ4dUlDQnBaaUFvZEhsd1pXOW1JSFpoYkNBOVBUMGdKMjUxYldKbGNpY3BJSHRjYmlBZ0lDQm1iM0lnS0drZ1BTQnpkR0Z5ZERzZ2FTQThJR1Z1WkRzZ0t5dHBLU0I3WEc0Z0lDQWdJQ0IwYUdselcybGRJRDBnZG1Gc1hHNGdJQ0FnZlZ4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhaaGNpQmllWFJsY3lBOUlFSjFabVpsY2k1cGMwSjFabVpsY2loMllXd3BYRzRnSUNBZ0lDQS9JSFpoYkZ4dUlDQWdJQ0FnT2lCdVpYY2dRblZtWm1WeUtIWmhiQ3dnWlc1amIyUnBibWNwWEc0Z0lDQWdkbUZ5SUd4bGJpQTlJR0o1ZEdWekxteGxibWQwYUZ4dUlDQWdJR1p2Y2lBb2FTQTlJREE3SUdrZ1BDQmxibVFnTFNCemRHRnlkRHNnS3l0cEtTQjdYRzRnSUNBZ0lDQjBhR2x6VzJrZ0t5QnpkR0Z5ZEYwZ1BTQmllWFJsYzF0cElDVWdiR1Z1WFZ4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUIwYUdselhHNTlYRzVjYmk4dklFaEZURkJGVWlCR1ZVNURWRWxQVGxOY2JpOHZJRDA5UFQwOVBUMDlQVDA5UFQwOVBUMWNibHh1ZG1GeUlFbE9Wa0ZNU1VSZlFrRlRSVFkwWDFKRklEMGdMMXRlS3k4d0xUbEJMVnBoTFhvdFgxMHZaMXh1WEc1bWRXNWpkR2x2YmlCaVlYTmxOalJqYkdWaGJpQW9jM1J5S1NCN1hHNGdJQzh2SUU1dlpHVWdjM1J5YVhCeklHOTFkQ0JwYm5aaGJHbGtJR05vWVhKaFkzUmxjbk1nYkdsclpTQmNYRzRnWVc1a0lGeGNkQ0JtY205dElIUm9aU0J6ZEhKcGJtY3NJR0poYzJVMk5DMXFjeUJrYjJWeklHNXZkRnh1SUNCemRISWdQU0J6ZEhJdWRISnBiU2dwTG5KbGNHeGhZMlVvU1U1V1FVeEpSRjlDUVZORk5qUmZVa1VzSUNjbktWeHVJQ0F2THlCT2IyUmxJR052Ym5abGNuUnpJSE4wY21sdVozTWdkMmwwYUNCc1pXNW5kR2dnUENBeUlIUnZJQ2NuWEc0Z0lHbG1JQ2h6ZEhJdWJHVnVaM1JvSUR3Z01pa2djbVYwZFhKdUlDY25YRzRnSUM4dklFNXZaR1VnWVd4c2IzZHpJR1p2Y2lCdWIyNHRjR0ZrWkdWa0lHSmhjMlUyTkNCemRISnBibWR6SUNodGFYTnphVzVuSUhSeVlXbHNhVzVuSUQwOVBTa3NJR0poYzJVMk5DMXFjeUJrYjJWeklHNXZkRnh1SUNCM2FHbHNaU0FvYzNSeUxteGxibWQwYUNBbElEUWdJVDA5SURBcElIdGNiaUFnSUNCemRISWdQU0J6ZEhJZ0t5QW5QU2RjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdjM1J5WEc1OVhHNWNibVoxYm1OMGFXOXVJSFJ2U0dWNElDaHVLU0I3WEc0Z0lHbG1JQ2h1SUR3Z01UWXBJSEpsZEhWeWJpQW5NQ2NnS3lCdUxuUnZVM1J5YVc1bktERTJLVnh1SUNCeVpYUjFjbTRnYmk1MGIxTjBjbWx1WnlneE5pbGNibjFjYmx4dVpuVnVZM1JwYjI0Z2RYUm1PRlJ2UW5sMFpYTWdLSE4wY21sdVp5d2dkVzVwZEhNcElIdGNiaUFnZFc1cGRITWdQU0IxYm1sMGN5QjhmQ0JKYm1acGJtbDBlVnh1SUNCMllYSWdZMjlrWlZCdmFXNTBYRzRnSUhaaGNpQnNaVzVuZEdnZ1BTQnpkSEpwYm1jdWJHVnVaM1JvWEc0Z0lIWmhjaUJzWldGa1UzVnljbTluWVhSbElEMGdiblZzYkZ4dUlDQjJZWElnWW5sMFpYTWdQU0JiWFZ4dVhHNGdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYkdWdVozUm9PeUFySzJrcElIdGNiaUFnSUNCamIyUmxVRzlwYm5RZ1BTQnpkSEpwYm1jdVkyaGhja052WkdWQmRDaHBLVnh1WEc0Z0lDQWdMeThnYVhNZ2MzVnljbTluWVhSbElHTnZiWEJ2Ym1WdWRGeHVJQ0FnSUdsbUlDaGpiMlJsVUc5cGJuUWdQaUF3ZUVRM1JrWWdKaVlnWTI5a1pWQnZhVzUwSUR3Z01IaEZNREF3S1NCN1hHNGdJQ0FnSUNBdkx5QnNZWE4wSUdOb1lYSWdkMkZ6SUdFZ2JHVmhaRnh1SUNBZ0lDQWdhV1lnS0NGc1pXRmtVM1Z5Y205bllYUmxLU0I3WEc0Z0lDQWdJQ0FnSUM4dklHNXZJR3hsWVdRZ2VXVjBYRzRnSUNBZ0lDQWdJR2xtSUNoamIyUmxVRzlwYm5RZ1BpQXdlRVJDUmtZcElIdGNiaUFnSUNBZ0lDQWdJQ0F2THlCMWJtVjRjR1ZqZEdWa0lIUnlZV2xzWEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLQ2gxYm1sMGN5QXRQU0F6S1NBK0lDMHhLU0JpZVhSbGN5NXdkWE5vS0RCNFJVWXNJREI0UWtZc0lEQjRRa1FwWEc0Z0lDQWdJQ0FnSUNBZ1kyOXVkR2x1ZFdWY2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHBJQ3NnTVNBOVBUMGdiR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQWdJQ0FnTHk4Z2RXNXdZV2x5WldRZ2JHVmhaRnh1SUNBZ0lDQWdJQ0FnSUdsbUlDZ29kVzVwZEhNZ0xUMGdNeWtnUGlBdE1Ta2dZbmwwWlhNdWNIVnphQ2d3ZUVWR0xDQXdlRUpHTENBd2VFSkVLVnh1SUNBZ0lDQWdJQ0FnSUdOdmJuUnBiblZsWEc0Z0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQXZMeUIyWVd4cFpDQnNaV0ZrWEc0Z0lDQWdJQ0FnSUd4bFlXUlRkWEp5YjJkaGRHVWdQU0JqYjJSbFVHOXBiblJjYmx4dUlDQWdJQ0FnSUNCamIyNTBhVzUxWlZ4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBdkx5QXlJR3hsWVdSeklHbHVJR0VnY205M1hHNGdJQ0FnSUNCcFppQW9ZMjlrWlZCdmFXNTBJRHdnTUhoRVF6QXdLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDZ29kVzVwZEhNZ0xUMGdNeWtnUGlBdE1Ta2dZbmwwWlhNdWNIVnphQ2d3ZUVWR0xDQXdlRUpHTENBd2VFSkVLVnh1SUNBZ0lDQWdJQ0JzWldGa1UzVnljbTluWVhSbElEMGdZMjlrWlZCdmFXNTBYRzRnSUNBZ0lDQWdJR052Ym5ScGJuVmxYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQzh2SUhaaGJHbGtJSE4xY25KdloyRjBaU0J3WVdseVhHNGdJQ0FnSUNCamIyUmxVRzlwYm5RZ1BTQW9iR1ZoWkZOMWNuSnZaMkYwWlNBdElEQjRSRGd3TUNBOFBDQXhNQ0I4SUdOdlpHVlFiMmx1ZENBdElEQjRSRU13TUNrZ0t5QXdlREV3TURBd1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoc1pXRmtVM1Z5Y205bllYUmxLU0I3WEc0Z0lDQWdJQ0F2THlCMllXeHBaQ0JpYlhBZ1kyaGhjaXdnWW5WMElHeGhjM1FnWTJoaGNpQjNZWE1nWVNCc1pXRmtYRzRnSUNBZ0lDQnBaaUFvS0hWdWFYUnpJQzA5SURNcElENGdMVEVwSUdKNWRHVnpMbkIxYzJnb01IaEZSaXdnTUhoQ1Jpd2dNSGhDUkNsY2JpQWdJQ0I5WEc1Y2JpQWdJQ0JzWldGa1UzVnljbTluWVhSbElEMGdiblZzYkZ4dVhHNGdJQ0FnTHk4Z1pXNWpiMlJsSUhWMFpqaGNiaUFnSUNCcFppQW9ZMjlrWlZCdmFXNTBJRHdnTUhnNE1Da2dlMXh1SUNBZ0lDQWdhV1lnS0NoMWJtbDBjeUF0UFNBeEtTQThJREFwSUdKeVpXRnJYRzRnSUNBZ0lDQmllWFJsY3k1d2RYTm9LR052WkdWUWIybHVkQ2xjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLR052WkdWUWIybHVkQ0E4SURCNE9EQXdLU0I3WEc0Z0lDQWdJQ0JwWmlBb0tIVnVhWFJ6SUMwOUlESXBJRHdnTUNrZ1luSmxZV3RjYmlBZ0lDQWdJR0o1ZEdWekxuQjFjMmdvWEc0Z0lDQWdJQ0FnSUdOdlpHVlFiMmx1ZENBK1BpQXdlRFlnZkNBd2VFTXdMRnh1SUNBZ0lDQWdJQ0JqYjJSbFVHOXBiblFnSmlBd2VETkdJSHdnTUhnNE1GeHVJQ0FnSUNBZ0tWeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1kyOWtaVkJ2YVc1MElEd2dNSGd4TURBd01Da2dlMXh1SUNBZ0lDQWdhV1lnS0NoMWJtbDBjeUF0UFNBektTQThJREFwSUdKeVpXRnJYRzRnSUNBZ0lDQmllWFJsY3k1d2RYTm9LRnh1SUNBZ0lDQWdJQ0JqYjJSbFVHOXBiblFnUGo0Z01IaERJSHdnTUhoRk1DeGNiaUFnSUNBZ0lDQWdZMjlrWlZCdmFXNTBJRDQrSURCNE5pQW1JREI0TTBZZ2ZDQXdlRGd3TEZ4dUlDQWdJQ0FnSUNCamIyUmxVRzlwYm5RZ0ppQXdlRE5HSUh3Z01IZzRNRnh1SUNBZ0lDQWdLVnh1SUNBZ0lIMGdaV3h6WlNCcFppQW9ZMjlrWlZCdmFXNTBJRHdnTUhneE1UQXdNREFwSUh0Y2JpQWdJQ0FnSUdsbUlDZ29kVzVwZEhNZ0xUMGdOQ2tnUENBd0tTQmljbVZoYTF4dUlDQWdJQ0FnWW5sMFpYTXVjSFZ6YUNoY2JpQWdJQ0FnSUNBZ1kyOWtaVkJ2YVc1MElENCtJREI0TVRJZ2ZDQXdlRVl3TEZ4dUlDQWdJQ0FnSUNCamIyUmxVRzlwYm5RZ1BqNGdNSGhESUNZZ01IZ3pSaUI4SURCNE9EQXNYRzRnSUNBZ0lDQWdJR052WkdWUWIybHVkQ0ErUGlBd2VEWWdKaUF3ZUROR0lId2dNSGc0TUN4Y2JpQWdJQ0FnSUNBZ1kyOWtaVkJ2YVc1MElDWWdNSGd6UmlCOElEQjRPREJjYmlBZ0lDQWdJQ2xjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkSmJuWmhiR2xrSUdOdlpHVWdjRzlwYm5RbktWeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCaWVYUmxjMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmhjMk5wYVZSdlFubDBaWE1nS0hOMGNpa2dlMXh1SUNCMllYSWdZbmwwWlVGeWNtRjVJRDBnVzExY2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J6ZEhJdWJHVnVaM1JvT3lBcksya3BJSHRjYmlBZ0lDQXZMeUJPYjJSbEozTWdZMjlrWlNCelpXVnRjeUIwYnlCaVpTQmtiMmx1WnlCMGFHbHpJR0Z1WkNCdWIzUWdKaUF3ZURkR0xpNWNiaUFnSUNCaWVYUmxRWEp5WVhrdWNIVnphQ2h6ZEhJdVkyaGhja052WkdWQmRDaHBLU0FtSURCNFJrWXBYRzRnSUgxY2JpQWdjbVYwZFhKdUlHSjVkR1ZCY25KaGVWeHVmVnh1WEc1bWRXNWpkR2x2YmlCMWRHWXhObXhsVkc5Q2VYUmxjeUFvYzNSeUxDQjFibWwwY3lrZ2UxeHVJQ0IyWVhJZ1l5d2dhR2tzSUd4dlhHNGdJSFpoY2lCaWVYUmxRWEp5WVhrZ1BTQmJYVnh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElITjBjaTVzWlc1bmRHZzdJQ3NyYVNrZ2UxeHVJQ0FnSUdsbUlDZ29kVzVwZEhNZ0xUMGdNaWtnUENBd0tTQmljbVZoYTF4dVhHNGdJQ0FnWXlBOUlITjBjaTVqYUdGeVEyOWtaVUYwS0drcFhHNGdJQ0FnYUdrZ1BTQmpJRDQrSURoY2JpQWdJQ0JzYnlBOUlHTWdKU0F5TlRaY2JpQWdJQ0JpZVhSbFFYSnlZWGt1Y0hWemFDaHNieWxjYmlBZ0lDQmllWFJsUVhKeVlYa3VjSFZ6YUNob2FTbGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQmllWFJsUVhKeVlYbGNibjFjYmx4dVpuVnVZM1JwYjI0Z1ltRnpaVFkwVkc5Q2VYUmxjeUFvYzNSeUtTQjdYRzRnSUhKbGRIVnliaUJpWVhObE5qUXVkRzlDZVhSbFFYSnlZWGtvWW1GelpUWTBZMnhsWVc0b2MzUnlLU2xjYm4xY2JseHVablZ1WTNScGIyNGdZbXhwZEVKMVptWmxjaUFvYzNKakxDQmtjM1FzSUc5bVpuTmxkQ3dnYkdWdVozUm9LU0I3WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2diR1Z1WjNSb095QXJLMmtwSUh0Y2JpQWdJQ0JwWmlBb0tHa2dLeUJ2Wm1aelpYUWdQajBnWkhOMExteGxibWQwYUNrZ2ZId2dLR2tnUGowZ2MzSmpMbXhsYm1kMGFDa3BJR0p5WldGclhHNGdJQ0FnWkhOMFcya2dLeUJ2Wm1aelpYUmRJRDBnYzNKalcybGRYRzRnSUgxY2JpQWdjbVYwZFhKdUlHbGNibjFjYmx4dUx5OGdRWEp5WVhsQ2RXWm1aWEp6SUdaeWIyMGdZVzV2ZEdobGNpQmpiMjUwWlhoMElDaHBMbVV1SUdGdUlHbG1jbUZ0WlNrZ1pHOGdibTkwSUhCaGMzTWdkR2hsSUdCcGJuTjBZVzVqWlc5bVlDQmphR1ZqYTF4dUx5OGdZblYwSUhSb1pYa2djMmh2ZFd4a0lHSmxJSFJ5WldGMFpXUWdZWE1nZG1Gc2FXUXVJRk5sWlRvZ2FIUjBjSE02THk5bmFYUm9kV0l1WTI5dEwyWmxjbTl6Y3k5aWRXWm1aWEl2YVhOemRXVnpMekUyTmx4dVpuVnVZM1JwYjI0Z2FYTkJjbkpoZVVKMVptWmxjaUFvYjJKcUtTQjdYRzRnSUhKbGRIVnliaUJ2WW1vZ2FXNXpkR0Z1WTJWdlppQkJjbkpoZVVKMVptWmxjaUI4ZkZ4dUlDQWdJQ2h2WW1vZ0lUMGdiblZzYkNBbUppQnZZbW91WTI5dWMzUnlkV04wYjNJZ0lUMGdiblZzYkNBbUppQnZZbW91WTI5dWMzUnlkV04wYjNJdWJtRnRaU0E5UFQwZ0owRnljbUY1UW5WbVptVnlKeUFtSmx4dUlDQWdJQ0FnZEhsd1pXOW1JRzlpYWk1aWVYUmxUR1Z1WjNSb0lEMDlQU0FuYm5WdFltVnlKeWxjYm4xY2JseHVMeThnVG05a1pTQXdMakV3SUhOMWNIQnZjblJ6SUdCQmNuSmhlVUoxWm1abGNtQWdZblYwSUd4aFkydHpJR0JCY25KaGVVSjFabVpsY2k1cGMxWnBaWGRnWEc1bWRXNWpkR2x2YmlCcGMwRnljbUY1UW5WbVptVnlWbWxsZHlBb2IySnFLU0I3WEc0Z0lISmxkSFZ5YmlBb2RIbHdaVzltSUVGeWNtRjVRblZtWm1WeUxtbHpWbWxsZHlBOVBUMGdKMloxYm1OMGFXOXVKeWtnSmlZZ1FYSnlZWGxDZFdabVpYSXVhWE5XYVdWM0tHOWlhaWxjYm4xY2JseHVablZ1WTNScGIyNGdiblZ0WW1WeVNYTk9ZVTRnS0c5aWFpa2dlMXh1SUNCeVpYUjFjbTRnYjJKcUlDRTlQU0J2WW1vZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJHbHVaU0J1YnkxelpXeG1MV052YlhCaGNtVmNibjFjYmlJc0ltVjRjRzl5ZEhNdWNtVmhaQ0E5SUdaMWJtTjBhVzl1SUNoaWRXWm1aWElzSUc5bVpuTmxkQ3dnYVhOTVJTd2diVXhsYml3Z2JrSjVkR1Z6S1NCN1hHNGdJSFpoY2lCbExDQnRYRzRnSUhaaGNpQmxUR1Z1SUQwZ2JrSjVkR1Z6SUNvZ09DQXRJRzFNWlc0Z0xTQXhYRzRnSUhaaGNpQmxUV0Y0SUQwZ0tERWdQRHdnWlV4bGJpa2dMU0F4WEc0Z0lIWmhjaUJsUW1saGN5QTlJR1ZOWVhnZ1BqNGdNVnh1SUNCMllYSWdia0pwZEhNZ1BTQXROMXh1SUNCMllYSWdhU0E5SUdselRFVWdQeUFvYmtKNWRHVnpJQzBnTVNrZ09pQXdYRzRnSUhaaGNpQmtJRDBnYVhOTVJTQS9JQzB4SURvZ01WeHVJQ0IyWVhJZ2N5QTlJR0oxWm1abGNsdHZabVp6WlhRZ0t5QnBYVnh1WEc0Z0lHa2dLejBnWkZ4dVhHNGdJR1VnUFNCeklDWWdLQ2d4SUR3OElDZ3Ria0pwZEhNcEtTQXRJREVwWEc0Z0lITWdQajQ5SUNndGJrSnBkSE1wWEc0Z0lHNUNhWFJ6SUNzOUlHVk1aVzVjYmlBZ1ptOXlJQ2c3SUc1Q2FYUnpJRDRnTURzZ1pTQTlJR1VnS2lBeU5UWWdLeUJpZFdabVpYSmJiMlptYzJWMElDc2dhVjBzSUdrZ0t6MGdaQ3dnYmtKcGRITWdMVDBnT0NrZ2UzMWNibHh1SUNCdElEMGdaU0FtSUNnb01TQThQQ0FvTFc1Q2FYUnpLU2tnTFNBeEtWeHVJQ0JsSUQ0K1BTQW9MVzVDYVhSektWeHVJQ0J1UW1sMGN5QXJQU0J0VEdWdVhHNGdJR1p2Y2lBb095QnVRbWwwY3lBK0lEQTdJRzBnUFNCdElDb2dNalUySUNzZ1luVm1abVZ5VzI5bVpuTmxkQ0FySUdsZExDQnBJQ3M5SUdRc0lHNUNhWFJ6SUMwOUlEZ3BJSHQ5WEc1Y2JpQWdhV1lnS0dVZ1BUMDlJREFwSUh0Y2JpQWdJQ0JsSUQwZ01TQXRJR1ZDYVdGelhHNGdJSDBnWld4elpTQnBaaUFvWlNBOVBUMGdaVTFoZUNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ0SUQ4Z1RtRk9JRG9nS0NoeklEOGdMVEVnT2lBeEtTQXFJRWx1Wm1sdWFYUjVLVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJRzBnUFNCdElDc2dUV0YwYUM1d2IzY29NaXdnYlV4bGJpbGNiaUFnSUNCbElEMGdaU0F0SUdWQ2FXRnpYRzRnSUgxY2JpQWdjbVYwZFhKdUlDaHpJRDhnTFRFZ09pQXhLU0FxSUcwZ0tpQk5ZWFJvTG5CdmR5Z3lMQ0JsSUMwZ2JVeGxiaWxjYm4xY2JseHVaWGh3YjNKMGN5NTNjbWwwWlNBOUlHWjFibU4wYVc5dUlDaGlkV1ptWlhJc0lIWmhiSFZsTENCdlptWnpaWFFzSUdselRFVXNJRzFNWlc0c0lHNUNlWFJsY3lrZ2UxeHVJQ0IyWVhJZ1pTd2diU3dnWTF4dUlDQjJZWElnWlV4bGJpQTlJRzVDZVhSbGN5QXFJRGdnTFNCdFRHVnVJQzBnTVZ4dUlDQjJZWElnWlUxaGVDQTlJQ2d4SUR3OElHVk1aVzRwSUMwZ01WeHVJQ0IyWVhJZ1pVSnBZWE1nUFNCbFRXRjRJRDQrSURGY2JpQWdkbUZ5SUhKMElEMGdLRzFNWlc0Z1BUMDlJREl6SUQ4Z1RXRjBhQzV3YjNjb01pd2dMVEkwS1NBdElFMWhkR2d1Y0c5M0tESXNJQzAzTnlrZ09pQXdLVnh1SUNCMllYSWdhU0E5SUdselRFVWdQeUF3SURvZ0tHNUNlWFJsY3lBdElERXBYRzRnSUhaaGNpQmtJRDBnYVhOTVJTQS9JREVnT2lBdE1WeHVJQ0IyWVhJZ2N5QTlJSFpoYkhWbElEd2dNQ0I4ZkNBb2RtRnNkV1VnUFQwOUlEQWdKaVlnTVNBdklIWmhiSFZsSUR3Z01Da2dQeUF4SURvZ01GeHVYRzRnSUhaaGJIVmxJRDBnVFdGMGFDNWhZbk1vZG1Gc2RXVXBYRzVjYmlBZ2FXWWdLR2x6VG1GT0tIWmhiSFZsS1NCOGZDQjJZV3gxWlNBOVBUMGdTVzVtYVc1cGRIa3BJSHRjYmlBZ0lDQnRJRDBnYVhOT1lVNG9kbUZzZFdVcElEOGdNU0E2SURCY2JpQWdJQ0JsSUQwZ1pVMWhlRnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR1VnUFNCTllYUm9MbVpzYjI5eUtFMWhkR2d1Ykc5bktIWmhiSFZsS1NBdklFMWhkR2d1VEU0eUtWeHVJQ0FnSUdsbUlDaDJZV3gxWlNBcUlDaGpJRDBnVFdGMGFDNXdiM2NvTWl3Z0xXVXBLU0E4SURFcElIdGNiaUFnSUNBZ0lHVXRMVnh1SUNBZ0lDQWdZeUFxUFNBeVhHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNobElDc2daVUpwWVhNZ1BqMGdNU2tnZTF4dUlDQWdJQ0FnZG1Gc2RXVWdLejBnY25RZ0x5QmpYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUhaaGJIVmxJQ3M5SUhKMElDb2dUV0YwYUM1d2IzY29NaXdnTVNBdElHVkNhV0Z6S1Z4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvZG1Gc2RXVWdLaUJqSUQ0OUlESXBJSHRjYmlBZ0lDQWdJR1VySzF4dUlDQWdJQ0FnWXlBdlBTQXlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLR1VnS3lCbFFtbGhjeUErUFNCbFRXRjRLU0I3WEc0Z0lDQWdJQ0J0SUQwZ01GeHVJQ0FnSUNBZ1pTQTlJR1ZOWVhoY2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0dVZ0t5QmxRbWxoY3lBK1BTQXhLU0I3WEc0Z0lDQWdJQ0J0SUQwZ0tIWmhiSFZsSUNvZ1l5QXRJREVwSUNvZ1RXRjBhQzV3YjNjb01pd2diVXhsYmlsY2JpQWdJQ0FnSUdVZ1BTQmxJQ3NnWlVKcFlYTmNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnYlNBOUlIWmhiSFZsSUNvZ1RXRjBhQzV3YjNjb01pd2daVUpwWVhNZ0xTQXhLU0FxSUUxaGRHZ3VjRzkzS0RJc0lHMU1aVzRwWEc0Z0lDQWdJQ0JsSUQwZ01GeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHWnZjaUFvT3lCdFRHVnVJRDQ5SURnN0lHSjFabVpsY2x0dlptWnpaWFFnS3lCcFhTQTlJRzBnSmlBd2VHWm1MQ0JwSUNzOUlHUXNJRzBnTHowZ01qVTJMQ0J0VEdWdUlDMDlJRGdwSUh0OVhHNWNiaUFnWlNBOUlDaGxJRHc4SUcxTVpXNHBJSHdnYlZ4dUlDQmxUR1Z1SUNzOUlHMU1aVzVjYmlBZ1ptOXlJQ2c3SUdWTVpXNGdQaUF3T3lCaWRXWm1aWEpiYjJabWMyVjBJQ3NnYVYwZ1BTQmxJQ1lnTUhobVppd2dhU0FyUFNCa0xDQmxJQzg5SURJMU5pd2daVXhsYmlBdFBTQTRLU0I3ZlZ4dVhHNGdJR0oxWm1abGNsdHZabVp6WlhRZ0t5QnBJQzBnWkYwZ2ZEMGdjeUFxSURFeU9GeHVmVnh1SWl3aUx5b3FYRzRnS2lCRGIyNXpkR0Z1ZEhNZ2RYTmxaQ0JwYmlCd2JHRjVaWEl1WEc0Z0tpOWNiblpoY2lCRGIyNXpkR0Z1ZEhNZ1BTQjdYRzVjZEZaRlVsTkpUMDQ2SUNjeUxqQXVOU2NzWEc1Y2RFNVBWRVZUT2lCYlhTeGNibHgwUTBsU1EweEZYMDlHWDBaUFZWSlVTRk02SUZzblF5Y3NJQ2RHSnl3Z0owSmlKeXdnSjBWaUp5d2dKMEZpSnl3Z0owUmlKeXdnSjBkaUp5d2dKME5pSnl3Z0owWmlKeXdnSjBKaVlpY3NJQ2RGWW1JbkxDQW5RV0ppSjEwc1hHNWNkRU5KVWtOTVJWOVBSbDlHU1VaVVNGTTZJRnNuUXljc0lDZEhKeXdnSjBRbkxDQW5RU2NzSUNkRkp5d2dKMEluTENBblJpTW5MQ0FuUXlNbkxDQW5SeU1uTENBblJDTW5MQ0FuUVNNbkxDQW5SU01uWFZ4dWZUdGNibHh1THk4Z1FuVnBiR1J6SUc1dmRHVnpJRzlpYW1WamRDQm1iM0lnY21WbVpYSmxibU5sSUdGbllXbHVjM1FnWW1sdVlYSjVJSFpoYkhWbGN5NWNiblpoY2lCaGJHeE9iM1JsY3lBOUlGdGJKME1uWFN3Z1d5ZERJeWNzSjBSaUoxMHNJRnNuUkNkZExDQmJKMFFqSnl3blJXSW5YU3dnV3lkRkoxMHNXeWRHSjEwc0lGc25SaU1uTENkSFlpZGRMQ0JiSjBjblhTd2dXeWRISXljc0owRmlKMTBzSUZzblFTZGRMQ0JiSjBFakp5d25RbUluWFN3Z1d5ZENKMTFkTzF4dWRtRnlJR052ZFc1MFpYSWdQU0F3TzF4dVhHNHZMeUJCYkd3Z1lYWmhhV3hoWW14bElHOWpkR0YyWlhNdVhHNW1iM0lnS0d4bGRDQnBJRDBnTFRFN0lHa2dQRDBnT1RzZ2FTc3JLU0I3WEc1Y2RHRnNiRTV2ZEdWekxtWnZja1ZoWTJnb2JtOTBaVWR5YjNWd0lEMCtJSHRjYmx4MFhIUnViM1JsUjNKdmRYQXVabTl5UldGamFDaHViM1JsSUQwK0lFTnZibk4wWVc1MGN5NU9UMVJGVTF0amIzVnVkR1Z5WFNBOUlHNXZkR1VnS3lCcEtUdGNibHgwWEhSamIzVnVkR1Z5SUNzck8xeHVYSFI5S1R0Y2JuMWNibHh1Wlhod2IzSjBjeTVEYjI1emRHRnVkSE1nUFNCRGIyNXpkR0Z1ZEhNN0lpd2lZMjl1YzNRZ1VHeGhlV1Z5SUQwZ2NtVnhkV2x5WlNoY0lpNHZjR3hoZVdWeVhDSXBPMXh1WTI5dWMzUWdWWFJwYkhNZ1BTQnlaWEYxYVhKbEtGd2lMaTkxZEdsc2Mxd2lLVHRjYm1OdmJuTjBJRU52Ym5OMFlXNTBjeUE5SUhKbGNYVnBjbVVvWENJdUwyTnZibk4wWVc1MGMxd2lLVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN1hHNGdJQ0FnVUd4aGVXVnlPbEJzWVhsbGNpNVFiR0Y1WlhJc1hHNGdJQ0FnVlhScGJITTZWWFJwYkhNdVZYUnBiSE1zWEc0Z0lDQWdRMjl1YzNSaGJuUnpPa052Ym5OMFlXNTBjeTVEYjI1emRHRnVkSE5jYm4waUxDSmpiMjV6ZENCVmRHbHNjeUE5SUhKbGNYVnBjbVVvWENJdUwzVjBhV3h6WENJcExsVjBhV3h6TzF4dVkyOXVjM1FnVkhKaFkyc2dQU0J5WlhGMWFYSmxLRndpTGk5MGNtRmphMXdpS1M1VWNtRmphenRjYmx4dUx5OGdVRzlzZVdacGJHd2dWV2x1ZERoQmNuSmhlUzVtYjNKRllXTm9PaUJFYjJWemJpZDBJR1Y0YVhOMElHOXVJRk5oWm1GeWFTQThNVEJjYm1sbUlDZ2hWV2x1ZERoQmNuSmhlUzV3Y205MGIzUjVjR1V1Wm05eVJXRmphQ2tnZTF4dVhIUlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvVldsdWREaEJjbkpoZVM1d2NtOTBiM1I1Y0dVc0lDZG1iM0pGWVdOb0p5d2dlMXh1WEhSY2RIWmhiSFZsT2lCQmNuSmhlUzV3Y205MGIzUjVjR1V1Wm05eVJXRmphRnh1WEhSOUtUdGNibjFjYmx4dUx5b3FYRzRnS2lCTllXbHVJSEJzWVhsbGNpQmpiR0Z6Y3k0Z0lFTnZiblJoYVc1eklHMWxkR2h2WkhNZ2RHOGdiRzloWkNCbWFXeGxjeXdnYzNSaGNuUXNJSE4wYjNBdVhHNGdLaUJBY0dGeVlXMGdlMloxYm1OMGFXOXVmU0F0SUVOaGJHeGlZV05ySUhSdklHWnBjbVVnWm05eUlHVmhZMmdnVFVsRVNTQmxkbVZ1ZEM0Z0lFTmhiaUJoYkhOdklHSmxJR0ZrWkdWa0lIZHBkR2dnYjI0b0oyMXBaR2xGZG1WdWRDY3NJR1p1S1Z4dUlDb2dRSEJoY21GdElIdGhjbkpoZVgwZ0xTQkJjbkpoZVNCaWRXWm1aWElnYjJZZ1RVbEVTU0JtYVd4bElDaHZjSFJwYjI1aGJDa3VYRzRnS2k5Y2JtTnNZWE56SUZCc1lYbGxjaUI3WEc1Y2RHTnZibk4wY25WamRHOXlLR1YyWlc1MFNHRnVaR3hsY2l3Z1luVm1abVZ5S1NCN1hHNWNkRngwZEdocGN5NXpZVzF3YkdWU1lYUmxJRDBnTlRzZ0x5OGdiV2xzYkdselpXTnZibVJ6WEc1Y2RGeDBkR2hwY3k1emRHRnlkRlJwYldVZ1BTQXdPMXh1WEhSY2RIUm9hWE11WW5WbVptVnlJRDBnWW5WbVptVnlJSHg4SUc1MWJHdzdYRzVjZEZ4MGRHaHBjeTVrYVhacGMybHZianRjYmx4MFhIUjBhR2x6TG1admNtMWhkRHRjYmx4MFhIUjBhR2x6TG5ObGRFbHVkR1Z5ZG1Gc1NXUWdQU0JtWVd4elpUdGNibHgwWEhSMGFHbHpMblJ5WVdOcmN5QTlJRnRkTzF4dVhIUmNkSFJvYVhNdWFXNXpkSEoxYldWdWRITWdQU0JiWFR0Y2JseDBYSFIwYUdsekxtUmxabUYxYkhSVVpXMXdieUE5SURFeU1EdGNibHgwWEhSMGFHbHpMblJsYlhCdklEMGdiblZzYkR0Y2JseDBYSFIwYUdsekxuTjBZWEowVkdsamF5QTlJREE3WEc1Y2RGeDBkR2hwY3k1MGFXTnJJRDBnTUR0Y2JseDBYSFIwYUdsekxteGhjM1JVYVdOcklEMGdiblZzYkR0Y2JseDBYSFIwYUdsekxtbHVURzl2Y0NBOUlHWmhiSE5sTzF4dVhIUmNkSFJvYVhNdWRHOTBZV3hVYVdOcmN5QTlJREE3WEc1Y2RGeDBkR2hwY3k1bGRtVnVkSE1nUFNCYlhUdGNibHgwWEhSMGFHbHpMblJ2ZEdGc1JYWmxiblJ6SUQwZ01EdGNibHgwWEhSMGFHbHpMbVYyWlc1MFRHbHpkR1Z1WlhKeklEMGdlMzA3WEc1Y2JseDBYSFJwWmlBb2RIbHdaVzltS0dWMlpXNTBTR0Z1Wkd4bGNpa2dQVDA5SUNkbWRXNWpkR2x2YmljcElIUm9hWE11YjI0b0oyMXBaR2xGZG1WdWRDY3NJR1YyWlc1MFNHRnVaR3hsY2lrN1hHNWNkSDFjYmx4dVhIUXZLaXBjYmx4MElDb2dURzloWkNCaElHWnBiR1VnYVc1MGJ5QjBhR1VnY0d4aGVXVnlJQ2hPYjJSbExtcHpJRzl1YkhrcExseHVYSFFnS2lCQWNHRnlZVzBnZTNOMGNtbHVaMzBnY0dGMGFDQXRJRkJoZEdnZ2IyWWdabWxzWlM1Y2JseDBJQ29nUUhKbGRIVnliaUI3VUd4aGVXVnlmVnh1WEhRZ0tpOWNibHgwYkc5aFpFWnBiR1VvY0dGMGFDa2dlMXh1WEhSY2RIWmhjaUJtY3lBOUlISmxjWFZwY21Vb0oyWnpKeWs3WEc1Y2RGeDBkR2hwY3k1aWRXWm1aWElnUFNCbWN5NXlaV0ZrUm1sc1pWTjVibU1vY0dGMGFDazdYRzVjZEZ4MGNtVjBkWEp1SUhSb2FYTXVabWxzWlV4dllXUmxaQ2dwTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFeHZZV1FnWVc0Z1lYSnlZWGtnWW5WbVptVnlJR2x1ZEc4Z2RHaGxJSEJzWVhsbGNpNWNibHgwSUNvZ1FIQmhjbUZ0SUh0aGNuSmhlWDBnWVhKeVlYbENkV1ptWlhJZ0xTQkJjbkpoZVNCaWRXWm1aWElnYjJZZ1ptbHNaU0IwYnlCaVpTQnNiMkZrWldRdVhHNWNkQ0FxSUVCeVpYUjFjbTRnZTFCc1lYbGxjbjFjYmx4MElDb3ZYRzVjZEd4dllXUkJjbkpoZVVKMVptWmxjaWhoY25KaGVVSjFabVpsY2lrZ2UxeHVYSFJjZEhSb2FYTXVZblZtWm1WeUlEMGdibVYzSUZWcGJuUTRRWEp5WVhrb1lYSnlZWGxDZFdabVpYSXBPMXh1WEhSY2RISmxkSFZ5YmlCMGFHbHpMbVpwYkdWTWIyRmtaV1FvS1R0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQk1iMkZrSUdFZ1pHRjBZU0JWVWtrZ2FXNTBieUIwYUdVZ2NHeGhlV1Z5TGx4dVhIUWdLaUJBY0dGeVlXMGdlM04wY21sdVozMGdaR0YwWVZWeWFTQXRJRVJoZEdFZ1ZWSkpJSFJ2SUdKbElHeHZZV1JsWkM1Y2JseDBJQ29nUUhKbGRIVnliaUI3VUd4aGVXVnlmVnh1WEhRZ0tpOWNibHgwYkc5aFpFUmhkR0ZWY21rb1pHRjBZVlZ5YVNrZ2UxeHVYSFJjZEM4dklHTnZiblpsY25RZ1ltRnpaVFkwSUhSdklISmhkeUJpYVc1aGNua2daR0YwWVNCb1pXeGtJR2x1SUdFZ2MzUnlhVzVuTGx4dVhIUmNkQzh2SUdSdlpYTnVKM1FnYUdGdVpHeGxJRlZTVEVWdVkyOWtaV1FnUkdGMFlWVlNTWE1nTFNCelpXVWdVMDhnWVc1emQyVnlJQ00yT0RVd01qYzJJR1p2Y2lCamIyUmxJSFJvWVhRZ1pHOWxjeUIwYUdselhHNWNkRngwZG1GeUlHSjVkR1ZUZEhKcGJtY2dQU0JWZEdsc2N5NWhkRzlpS0dSaGRHRlZjbWt1YzNCc2FYUW9KeXduS1ZzeFhTazdYRzVjYmx4MFhIUXZMeUIzY21sMFpTQjBhR1VnWW5sMFpYTWdiMllnZEdobElITjBjbWx1WnlCMGJ5QmhiaUJCY25KaGVVSjFabVpsY2x4dVhIUmNkSFpoY2lCcFlTQTlJRzVsZHlCVmFXNTBPRUZ5Y21GNUtHSjVkR1ZUZEhKcGJtY3ViR1Z1WjNSb0tUdGNibHgwWEhSbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHSjVkR1ZUZEhKcGJtY3ViR1Z1WjNSb095QnBLeXNwSUh0Y2JseDBYSFJjZEdsaFcybGRJRDBnWW5sMFpWTjBjbWx1Wnk1amFHRnlRMjlrWlVGMEtHa3BPMXh1WEhSY2RIMWNibHh1WEhSY2RIUm9hWE11WW5WbVptVnlJRDBnYVdFN1hHNWNkRngwY21WMGRYSnVJSFJvYVhNdVptbHNaVXh2WVdSbFpDZ3BPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUVkbGRDQm1hV3hsYzJsNlpTQnZaaUJzYjJGa1pXUWdabWxzWlNCcGJpQnVkVzFpWlhJZ2IyWWdZbmwwWlhNdVhHNWNkQ0FxSUVCeVpYUjFjbTRnZTI1MWJXSmxjbjBnTFNCVWFHVWdabWxzWlhOcGVtVXVYRzVjZENBcUwxeHVYSFJuWlhSR2FXeGxjMmw2WlNncElIdGNibHgwWEhSeVpYUjFjbTRnZEdocGN5NWlkV1ptWlhJZ1B5QjBhR2x6TG1KMVptWmxjaTVzWlc1bmRHZ2dPaUF3TzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlGTmxkSE1nWkdWbVlYVnNkQ0IwWlcxd2J5d2djR0Z5YzJWeklHWnBiR1VnWm05eUlHNWxZMlZ6YzJGeWVTQnBibVp2Y20xaGRHbHZiaXdnWVc1a0lHUnZaWE1nWVNCa2Nua2djblZ1SUhSdklHTmhiR04xYkdGMFpTQjBiM1JoYkNCc1pXNW5kR2d1WEc1Y2RDQXFJRkJ2Y0hWc1lYUmxjeUIwYUdsekxtVjJaVzUwY3lBbUlIUm9hWE11ZEc5MFlXeFVhV05yY3k1Y2JseDBJQ29nUUhKbGRIVnliaUI3VUd4aGVXVnlmVnh1WEhRZ0tpOWNibHgwWm1sc1pVeHZZV1JsWkNncElIdGNibHgwWEhScFppQW9JWFJvYVhNdWRtRnNhV1JoZEdVb0tTa2dkR2h5YjNjZ0owbHVkbUZzYVdRZ1RVbEVTU0JtYVd4bE95QnphRzkxYkdRZ2MzUmhjblFnZDJsMGFDQk5WR2hrSnp0Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3k1elpYUlVaVzF3YnloMGFHbHpMbVJsWm1GMWJIUlVaVzF3YnlrdVoyVjBSR2wyYVhOcGIyNG9LUzVuWlhSR2IzSnRZWFFvS1M1blpYUlVjbUZqYTNNb0tTNWtjbmxTZFc0b0tUdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJXWVd4cFpHRjBaWE1nWm1sc1pTQjFjMmx1WnlCemFXMXdiR1VnYldWaGJuTWdMU0JtYVhKemRDQm1iM1Z5SUdKNWRHVnpJSE5vYjNWc1pDQTlQU0JOVkdoa0xseHVYSFFnS2lCQWNtVjBkWEp1SUh0aWIyOXNaV0Z1ZlZ4dVhIUWdLaTljYmx4MGRtRnNhV1JoZEdVb0tTQjdYRzVjZEZ4MGNtVjBkWEp1SUZWMGFXeHpMbUo1ZEdWelZHOU1aWFIwWlhKektIUm9hWE11WW5WbVptVnlMbk4xWW1GeWNtRjVLREFzSURRcEtTQTlQVDBnSjAxVWFHUW5PMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUVkbGRITWdUVWxFU1NCbWFXeGxJR1p2Y20xaGRDQm1iM0lnYkc5aFpHVmtJR1pwYkdVdVhHNWNkQ0FxSUVCeVpYUjFjbTRnZTFCc1lYbGxjbjFjYmx4MElDb3ZYRzVjZEdkbGRFWnZjbTFoZENncElIdGNibHgwWEhRdktseHVYSFJjZEUxSlJFa2dabWxzWlhNZ1kyOXRaU0JwYmlBeklIWmhjbWxoZEdsdmJuTTZYRzVjZEZ4MFJtOXliV0YwSURBZ2QyaHBZMmdnWTI5dWRHRnBiaUJoSUhOcGJtZHNaU0IwY21GamExeHVYSFJjZEVadmNtMWhkQ0F4SUhkb2FXTm9JR052Ym5SaGFXNGdiMjVsSUc5eUlHMXZjbVVnYzJsdGRXeDBZVzVsYjNWeklIUnlZV05yYzF4dVhIUmNkQ2hwWlNCaGJHd2dkSEpoWTJ0eklHRnlaU0IwYnlCaVpTQndiR0Y1WldRZ2MybHRkV3gwWVc1bGIzVnpiSGtwTGx4dVhIUmNkRVp2Y20xaGRDQXlJSGRvYVdOb0lHTnZiblJoYVc0Z2IyNWxJRzl5SUcxdmNtVWdhVzVrWlhCbGJtUmhiblFnZEhKaFkydHpYRzVjZEZ4MEtHbGxJR1ZoWTJnZ2RISmhZMnNnYVhNZ2RHOGdZbVVnY0d4aGVXVmtJR2x1WkdWd1pXNWtZVzUwYkhrZ2IyWWdkR2hsSUc5MGFHVnljeWt1WEc1Y2RGeDBjbVYwZFhKdUlGVjBhV3h6TG1KNWRHVnpWRzlPZFcxaVpYSW9kR2hwY3k1aWRXWm1aWEl1YzNWaVlYSnlZWGtvT0N3Z01UQXBLVHRjYmx4MFhIUXFMMXh1WEc1Y2RGeDBkR2hwY3k1bWIzSnRZWFFnUFNCVmRHbHNjeTVpZVhSbGMxUnZUblZ0WW1WeUtIUm9hWE11WW5WbVptVnlMbk4xWW1GeWNtRjVLRGdzSURFd0tTazdYRzVjZEZ4MGNtVjBkWEp1SUhSb2FYTTdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nVUdGeWMyVnpJRzkxZENCMGNtRmphM01zSUhCc1lXTmxjeUIwYUdWdElHbHVJSFJvYVhNdWRISmhZMnR6SUdGdVpDQnBibWwwYVdGc2FYcGxjeUIwYUdsekxuQnZhVzUwWlhKelhHNWNkQ0FxSUVCeVpYUjFjbTRnZTFCc1lYbGxjbjFjYmx4MElDb3ZYRzVjZEdkbGRGUnlZV05yY3lncElIdGNibHgwWEhSMGFHbHpMblJ5WVdOcmN5QTlJRnRkTzF4dVhIUmNkR3hsZENCMGNtRmphMDltWm5ObGRDQTlJREE3WEc1Y2RGeDBkMmhwYkdVZ0tIUnlZV05yVDJabWMyVjBJRHdnZEdocGN5NWlkV1ptWlhJdWJHVnVaM1JvS1NCN1hHNWNkRngwWEhScFppQW9WWFJwYkhNdVlubDBaWE5VYjB4bGRIUmxjbk1vZEdocGN5NWlkV1ptWlhJdWMzVmlZWEp5WVhrb2RISmhZMnRQWm1aelpYUXNJSFJ5WVdOclQyWm1jMlYwSUNzZ05Da3BJRDA5SUNkTlZISnJKeWtnZTF4dVhIUmNkRngwWEhSc1pYUWdkSEpoWTJ0TVpXNW5kR2dnUFNCVmRHbHNjeTVpZVhSbGMxUnZUblZ0WW1WeUtIUm9hWE11WW5WbVptVnlMbk4xWW1GeWNtRjVLSFJ5WVdOclQyWm1jMlYwSUNzZ05Dd2dkSEpoWTJ0UFptWnpaWFFnS3lBNEtTazdYRzVjZEZ4MFhIUmNkSFJvYVhNdWRISmhZMnR6TG5CMWMyZ29ibVYzSUZSeVlXTnJLSFJvYVhNdWRISmhZMnR6TG14bGJtZDBhQ3dnZEdocGN5NWlkV1ptWlhJdWMzVmlZWEp5WVhrb2RISmhZMnRQWm1aelpYUWdLeUE0TENCMGNtRmphMDltWm5ObGRDQXJJRGdnS3lCMGNtRmphMHhsYm1kMGFDa3BLVHRjYmx4MFhIUmNkSDFjYmx4dVhIUmNkRngwZEhKaFkydFBabVp6WlhRZ0t6MGdWWFJwYkhNdVlubDBaWE5VYjA1MWJXSmxjaWgwYUdsekxtSjFabVpsY2k1emRXSmhjbkpoZVNoMGNtRmphMDltWm5ObGRDQXJJRFFzSUhSeVlXTnJUMlptYzJWMElDc2dPQ2twSUNzZ09EdGNibHgwWEhSOVhHNWNkRngwY21WMGRYSnVJSFJvYVhNN1hHNWNkSDFjYmx4dVhIUXZLaXBjYmx4MElDb2dSVzVoWW14bGN5QmhJSFJ5WVdOcklHWnZjaUJ3YkdGNWFXNW5MbHh1WEhRZ0tpQkFjR0Z5WVcwZ2UyNTFiV0psY24wZ2RISmhZMnRPZFcxaVpYSWdMU0JVY21GamF5QnVkVzFpWlhKY2JseDBJQ29nUUhKbGRIVnliaUI3VUd4aGVXVnlmVnh1WEhRZ0tpOWNibHgwWlc1aFlteGxWSEpoWTJzb2RISmhZMnRPZFcxaVpYSXBJSHRjYmx4MFhIUjBhR2x6TG5SeVlXTnJjMXQwY21GamEwNTFiV0psY2lBdElERmRMbVZ1WVdKc1pTZ3BPMXh1WEhSY2RISmxkSFZ5YmlCMGFHbHpPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUVScGMyRmliR1Z6SUdFZ2RISmhZMnNnWm05eUlIQnNZWGxwYm1jdVhHNWNkQ0FxSUVCd1lYSmhiU0I3Ym5WdFltVnlmU0F0SUZSeVlXTnJJRzUxYldKbGNseHVYSFFnS2lCQWNtVjBkWEp1SUh0UWJHRjVaWEo5WEc1Y2RDQXFMMXh1WEhSa2FYTmhZbXhsVkhKaFkyc29kSEpoWTJ0T2RXMWlaWElwSUh0Y2JseDBYSFIwYUdsekxuUnlZV05yYzF0MGNtRmphMDUxYldKbGNpQXRJREZkTG1ScGMyRmliR1VvS1R0Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3p0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkhaWFJ6SUhGMVlYSjBaWElnYm05MFpTQmthWFpwYzJsdmJpQnZaaUJzYjJGa1pXUWdUVWxFU1NCbWFXeGxMbHh1WEhRZ0tpQkFjbVYwZFhKdUlIdFFiR0Y1WlhKOVhHNWNkQ0FxTDF4dVhIUm5aWFJFYVhacGMybHZiaWdwSUh0Y2JseDBYSFIwYUdsekxtUnBkbWx6YVc5dUlEMGdWWFJwYkhNdVlubDBaWE5VYjA1MWJXSmxjaWgwYUdsekxtSjFabVpsY2k1emRXSmhjbkpoZVNneE1pd2dNVFFwS1R0Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3p0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQlVhR1VnYldGcGJpQndiR0Y1SUd4dmIzQXVYRzVjZENBcUlFQndZWEpoYlNCN1ltOXZiR1ZoYm4wZ0xTQkpibVJwWTJGMFpYTWdkMmhsZEdobGNpQnZjaUJ1YjNRZ2RHaHBjeUJwY3lCaVpXbHVaeUJqWVd4c1pXUWdjMmx0Y0d4NUlHWnZjaUJ3WVhKemFXNW5JSEIxY25CdmMyVnpMaUFnUkdsemNtVm5ZWEprY3lCMGFXMXBibWNnYVdZZ2MyOHVYRzVjZENBcUlFQnlaWFIxY200Z2UzVnVaR1ZtYVc1bFpIMWNibHgwSUNvdlhHNWNkSEJzWVhsTWIyOXdLR1J5ZVZKMWJpa2dlMXh1WEhSY2RHbG1JQ2doZEdocGN5NXBia3h2YjNBcElIdGNibHgwWEhSY2RIUm9hWE11YVc1TWIyOXdJRDBnZEhKMVpUdGNibHgwWEhSY2RIUm9hWE11ZEdsamF5QTlJSFJvYVhNdVoyVjBRM1Z5Y21WdWRGUnBZMnNvS1R0Y2JseHVYSFJjZEZ4MGRHaHBjeTUwY21GamEzTXVabTl5UldGamFDaG1kVzVqZEdsdmJpaDBjbUZqYXlrZ2UxeHVYSFJjZEZ4MFhIUXZMeUJJWVc1a2JHVWdibVY0ZENCbGRtVnVkRnh1WEhSY2RGeDBYSFJwWmlBb0lXUnllVkoxYmlBbUppQjBhR2x6TG1WdVpFOW1SbWxzWlNncEtTQjdYRzVjZEZ4MFhIUmNkRngwTHk5amIyNXpiMnhsTG14dlp5Z25aVzVrSUc5bUlHWnBiR1VuS1Z4dVhIUmNkRngwWEhSY2RIUm9hWE11ZEhKcFoyZGxjbEJzWVhsbGNrVjJaVzUwS0NkbGJtUlBaa1pwYkdVbktUdGNibHgwWEhSY2RGeDBYSFIwYUdsekxuTjBiM0FvS1R0Y2JseDBYSFJjZEZ4MGZTQmxiSE5sSUh0Y2JseDBYSFJjZEZ4MFhIUnNaWFFnWlhabGJuUWdQU0IwY21GamF5NW9ZVzVrYkdWRmRtVnVkQ2gwYUdsekxuUnBZMnNzSUdSeWVWSjFiaWs3WEc1Y2JseDBYSFJjZEZ4MFhIUnBaaUFvWkhKNVVuVnVJQ1ltSUdWMlpXNTBLU0I3WEc1Y2RGeDBYSFJjZEZ4MFhIUnBaaUFvWlhabGJuUXVhR0Z6VDNkdVVISnZjR1Z5ZEhrb0oyNWhiV1VuS1NBbUppQmxkbVZ1ZEM1dVlXMWxJRDA5UFNBblUyVjBJRlJsYlhCdkp5a2dlMXh1WEhSY2RGeDBYSFJjZEZ4MFhIUXZMeUJIY21GaUlIUmxiWEJ2SUdsbUlHRjJZV2xzWVdKc1pTNWNibHgwWEhSY2RGeDBYSFJjZEZ4MGRHaHBjeTVrWldaaGRXeDBWR1Z0Y0c4Z1BTQmxkbVZ1ZEM1a1lYUmhPMXh1WEhSY2RGeDBYSFJjZEZ4MFhIUjBhR2x6TG5ObGRGUmxiWEJ2S0dWMlpXNTBMbVJoZEdFcE8xeHVYSFJjZEZ4MFhIUmNkRngwZlZ4dVhIUmNkRngwWEhSY2RGeDBhV1lnS0dWMlpXNTBMbWhoYzA5M2JsQnliM0JsY25SNUtDZHVZVzFsSnlrZ0ppWWdaWFpsYm5RdWJtRnRaU0E5UFQwZ0oxQnliMmR5WVcwZ1EyaGhibWRsSnlrZ2UxeHVYSFJjZEZ4MFhIUmNkRngwWEhScFppQW9JWFJvYVhNdWFXNXpkSEoxYldWdWRITXVhVzVqYkhWa1pYTW9aWFpsYm5RdWRtRnNkV1VwS1NCN1hHNWNkRngwWEhSY2RGeDBYSFJjZEZ4MGRHaHBjeTVwYm5OMGNuVnRaVzUwY3k1d2RYTm9LR1YyWlc1MExuWmhiSFZsS1R0Y2JseDBYSFJjZEZ4MFhIUmNkRngwZlZ4dVhIUmNkRngwWEhSY2RGeDBmVnh1WEhSY2RGeDBYSFJjZEgwZ1pXeHpaU0JwWmlBb1pYWmxiblFwSUhSb2FYTXVaVzFwZEVWMlpXNTBLR1YyWlc1MEtUdGNibHgwWEhSY2RGeDBmVnh1WEc1Y2RGeDBYSFI5TENCMGFHbHpLVHRjYmx4dVhIUmNkRngwYVdZZ0tDRmtjbmxTZFc0cElIUm9hWE11ZEhKcFoyZGxjbEJzWVhsbGNrVjJaVzUwS0Nkd2JHRjVhVzVuSnl3Z2UzUnBZMnM2SUhSb2FYTXVkR2xqYTMwcE8xeHVYSFJjZEZ4MGRHaHBjeTVwYmt4dmIzQWdQU0JtWVd4elpUdGNibHgwWEhSOVhHNWNkSDFjYmx4dVhIUXZLaXBjYmx4MElDb2dVMlYwZEdWeUlHWnZjaUIwWlcxd2J5NWNibHgwSUNvZ1FIQmhjbUZ0SUh0dWRXMWlaWEo5SUMwZ1ZHVnRjRzhnYVc0Z1luQnRJQ2hrWldaaGRXeDBjeUIwYnlBeE1qQXBYRzVjZENBcUwxeHVYSFJ6WlhSVVpXMXdieWgwWlcxd2J5a2dlMXh1WEhSY2RIUm9hWE11ZEdWdGNHOGdQU0IwWlcxd2J6dGNibHgwWEhSeVpYUjFjbTRnZEdocGN6dGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJUWlhSMFpYSWdabTl5SUhOMFlYSjBWR2x0WlM1Y2JseDBJQ29nUUhCaGNtRnRJSHR1ZFcxaVpYSjlJQzBnVlZSRElIUnBiV1Z6ZEdGdGNGeHVYSFFnS2k5Y2JseDBjMlYwVTNSaGNuUlVhVzFsS0hOMFlYSjBWR2x0WlNrZ2UxeHVYSFJjZEhSb2FYTXVjM1JoY25SVWFXMWxJRDBnYzNSaGNuUlVhVzFsTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlGTjBZWEowSUhCc1lYbHBibWNnYkc5aFpHVmtJRTFKUkVrZ1ptbHNaU0JwWmlCdWIzUWdZV3h5WldGa2VTQndiR0Y1YVc1bkxseHVYSFFnS2lCQWNtVjBkWEp1SUh0UWJHRjVaWEo5WEc1Y2RDQXFMMXh1WEhSd2JHRjVLQ2tnZTF4dVhIUmNkR2xtSUNoMGFHbHpMbWx6VUd4aGVXbHVaeWdwS1NCMGFISnZkeUFuUVd4eVpXRmtlU0J3YkdGNWFXNW5MaTR1Snp0Y2JseHVYSFJjZEM4dklFbHVhWFJwWVd4cGVtVmNibHgwWEhScFppQW9JWFJvYVhNdWMzUmhjblJVYVcxbEtTQjBhR2x6TG5OMFlYSjBWR2x0WlNBOUlDaHVaWGNnUkdGMFpTZ3BLUzVuWlhSVWFXMWxLQ2s3WEc1Y2JseDBYSFF2THlCVGRHRnlkQ0J3YkdGNUlHeHZiM0JjYmx4MFhIUXZMM2RwYm1SdmR5NXlaWEYxWlhOMFFXNXBiV0YwYVc5dVJuSmhiV1VvZEdocGN5NXdiR0Y1VEc5dmNDNWlhVzVrS0hSb2FYTXBLVHRjYmx4MFhIUjBhR2x6TG5ObGRFbHVkR1Z5ZG1Gc1NXUWdQU0J6WlhSSmJuUmxjblpoYkNoMGFHbHpMbkJzWVhsTWIyOXdMbUpwYm1Rb2RHaHBjeWtzSUhSb2FYTXVjMkZ0Y0d4bFVtRjBaU2s3WEc1Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3p0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQlFZWFZ6WlhNZ2NHeGhlV0poWTJzZ2FXWWdjR3hoZVdsdVp5NWNibHgwSUNvZ1FISmxkSFZ5YmlCN1VHeGhlV1Z5ZlZ4dVhIUWdLaTljYmx4MGNHRjFjMlVvS1NCN1hHNWNkRngwWTJ4bFlYSkpiblJsY25aaGJDaDBhR2x6TG5ObGRFbHVkR1Z5ZG1Gc1NXUXBPMXh1WEhSY2RIUm9hWE11YzJWMFNXNTBaWEoyWVd4SlpDQTlJR1poYkhObE8xeHVYSFJjZEhSb2FYTXVjM1JoY25SVWFXTnJJRDBnZEdocGN5NTBhV05yTzF4dVhIUmNkSFJvYVhNdWMzUmhjblJVYVcxbElEMGdNRHRjYmx4MFhIUnlaWFIxY200Z2RHaHBjenRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCVGRHOXdjeUJ3YkdGNVltRmpheUJwWmlCd2JHRjVhVzVuTGx4dVhIUWdLaUJBY21WMGRYSnVJSHRRYkdGNVpYSjlYRzVjZENBcUwxeHVYSFJ6ZEc5d0tDa2dlMXh1WEhSY2RHTnNaV0Z5U1c1MFpYSjJZV3dvZEdocGN5NXpaWFJKYm5SbGNuWmhiRWxrS1R0Y2JseDBYSFIwYUdsekxuTmxkRWx1ZEdWeWRtRnNTV1FnUFNCbVlXeHpaVHRjYmx4MFhIUjBhR2x6TG5OMFlYSjBWR2xqYXlBOUlEQTdYRzVjZEZ4MGRHaHBjeTV6ZEdGeWRGUnBiV1VnUFNBd08xeHVYSFJjZEhSb2FYTXVjbVZ6WlhSVWNtRmphM01vS1R0Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3p0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQlRhMmx3Y3lCd2JHRjVaWElnY0c5cGJuUmxjaUIwYnlCemNHVmphV1pwWldRZ2RHbGpheTVjYmx4MElDb2dRSEJoY21GdElIdHVkVzFpWlhKOUlDMGdWR2xqYXlCMGJ5QnphMmx3SUhSdkxseHVYSFFnS2lCQWNtVjBkWEp1SUh0UWJHRjVaWEo5WEc1Y2RDQXFMMXh1WEhSemEybHdWRzlVYVdOcktIUnBZMnNwSUh0Y2JseDBYSFIwYUdsekxuTjBiM0FvS1R0Y2JseDBYSFIwYUdsekxuTjBZWEowVkdsamF5QTlJSFJwWTJzN1hHNWNibHgwWEhRdkx5Qk9aV1ZrSUhSdklITmxkQ0IwY21GamF5QmxkbVZ1ZENCcGJtUmxlR1Z6SUhSdklIUm9aU0J1WldGeVpYTjBJSEJ2YzNOcFlteGxJR1YyWlc1MElIUnZJSFJvWlNCemNHVmphV1pwWldRZ2RHbGpheTVjYmx4MFhIUjBhR2x6TG5SeVlXTnJjeTVtYjNKRllXTm9LR1oxYm1OMGFXOXVLSFJ5WVdOcktTQjdYRzVjZEZ4MFhIUjBjbUZqYXk1elpYUkZkbVZ1ZEVsdVpHVjRRbmxVYVdOcktIUnBZMnNwTzF4dVhIUmNkSDBwTzF4dVhIUmNkSEpsZEhWeWJpQjBhR2x6TzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlGTnJhWEJ6SUhCc1lYbGxjaUJ3YjJsdWRHVnlJSFJ2SUhOd1pXTnBabWxsWkNCd1pYSmpaVzUwWVdkbExseHVYSFFnS2lCQWNHRnlZVzBnZTI1MWJXSmxjbjBnTFNCUVpYSmpaVzUwSUhaaGJIVmxJR2x1SUdsdWRHVm5aWElnWm05eWJXRjBMbHh1WEhRZ0tpQkFjbVYwZFhKdUlIdFFiR0Y1WlhKOVhHNWNkQ0FxTDF4dVhIUnphMmx3Vkc5UVpYSmpaVzUwS0hCbGNtTmxiblFwSUh0Y2JseDBYSFJwWmlBb2NHVnlZMlZ1ZENBOElEQWdmSHdnY0dWeVkyVnVkQ0ErSURFd01Da2dkR2h5YjNjZ1hDSlFaWEpqWlc1MElHMTFjM1FnWW1VZ2JuVnRZbVZ5SUdKbGRIZGxaVzRnTVNCaGJtUWdNVEF3TGx3aU8xeHVYSFJjZEhSb2FYTXVjMnRwY0ZSdlZHbGpheWhOWVhSb0xuSnZkVzVrS0hCbGNtTmxiblFnTHlBeE1EQWdLaUIwYUdsekxuUnZkR0ZzVkdsamEzTXBLVHRjYmx4MFhIUnlaWFIxY200Z2RHaHBjenRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCVGEybHdjeUJ3YkdGNVpYSWdjRzlwYm5SbGNpQjBieUJ6Y0dWamFXWnBaV1FnYzJWamIyNWtjeTVjYmx4MElDb2dRSEJoY21GdElIdHVkVzFpWlhKOUlDMGdVMlZqYjI1a2N5QjBieUJ6YTJsd0lIUnZMbHh1WEhRZ0tpQkFjbVYwZFhKdUlIdFFiR0Y1WlhKOVhHNWNkQ0FxTDF4dVhIUnphMmx3Vkc5VFpXTnZibVJ6S0hObFkyOXVaSE1wSUh0Y2JseDBYSFIyWVhJZ2MyOXVaMVJwYldVZ1BTQjBhR2x6TG1kbGRGTnZibWRVYVcxbEtDazdYRzVjZEZ4MGFXWWdLSE5sWTI5dVpITWdQQ0F3SUh4OElITmxZMjl1WkhNZ1BpQnpiMjVuVkdsdFpTa2dkR2h5YjNjZ2MyVmpiMjVrY3lBcklGd2lJSE5sWTI5dVpITWdibTkwSUhkcGRHaHBiaUJ6YjI1bklIUnBiV1VnYjJZZ1hDSWdLeUJ6YjI1blZHbHRaVHRjYmx4MFhIUjBhR2x6TG5OcmFYQlViMUJsY21ObGJuUW9jMlZqYjI1a2N5QXZJSE52Ym1kVWFXMWxJQ29nTVRBd0tUdGNibHgwWEhSeVpYUjFjbTRnZEdocGN6dGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJEYUdWamEzTWdhV1lnY0d4aGVXVnlJR2x6SUhCc1lYbHBibWRjYmx4MElDb2dRSEpsZEhWeWJpQjdZbTl2YkdWaGJuMWNibHgwSUNvdlhHNWNkR2x6VUd4aGVXbHVaeWdwSUh0Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3k1elpYUkpiblJsY25aaGJFbGtJRDRnTUNCOGZDQjBlWEJsYjJZZ2RHaHBjeTV6WlhSSmJuUmxjblpoYkVsa0lEMDlQU0FuYjJKcVpXTjBKenRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCUWJHRjVjeUIwYUdVZ2JHOWhaR1ZrSUUxSlJFa2dabWxzWlNCM2FYUm9iM1YwSUhKbFoyRnlaQ0JtYjNJZ2RHbHRhVzVuSUdGdVpDQnpZWFpsY3lCbGRtVnVkSE1nYVc0Z2RHaHBjeTVsZG1WdWRITXVJQ0JGYzNObGJuUnBZV3hzZVNCMWMyVmtJR0Z6SUdFZ2NHRnljMlZ5TGx4dVhIUWdLaUJBY21WMGRYSnVJSHRRYkdGNVpYSjlYRzVjZENBcUwxeHVYSFJrY25sU2RXNG9LU0I3WEc1Y2RGeDBMeThnVW1WelpYUWdkSEpoWTJ0eklHWnBjbk4wWEc1Y2RGeDBkR2hwY3k1eVpYTmxkRlJ5WVdOcmN5Z3BPMXh1WEhSY2RIZG9hV3hsSUNnaGRHaHBjeTVsYm1SUFprWnBiR1VvS1NrZ2RHaHBjeTV3YkdGNVRHOXZjQ2gwY25WbEtUdGNibHgwWEhSMGFHbHpMbVYyWlc1MGN5QTlJSFJvYVhNdVoyVjBSWFpsYm5SektDazdYRzVjZEZ4MGRHaHBjeTUwYjNSaGJFVjJaVzUwY3lBOUlIUm9hWE11WjJWMFZHOTBZV3hGZG1WdWRITW9LVHRjYmx4MFhIUjBhR2x6TG5SdmRHRnNWR2xqYTNNZ1BTQjBhR2x6TG1kbGRGUnZkR0ZzVkdsamEzTW9LVHRjYmx4MFhIUjBhR2x6TG5OMFlYSjBWR2xqYXlBOUlEQTdYRzVjZEZ4MGRHaHBjeTV6ZEdGeWRGUnBiV1VnUFNBd08xeHVYRzVjZEZ4MEx5OGdUR1ZoZG1VZ2RISmhZMnR6SUdsdUlIQnlhWE4wYVc1bElHTnZibVJwYzJoY2JseDBYSFIwYUdsekxuSmxjMlYwVkhKaFkydHpLQ2s3WEc1Y2JseDBYSFF2TDJOdmJuTnZiR1V1Ykc5bktDZFRiMjVuSUhScGJXVTZJQ2NnS3lCMGFHbHpMbWRsZEZOdmJtZFVhVzFsS0NrZ0t5QW5JSE5sWTI5dVpITWdMeUFuSUNzZ2RHaHBjeTUwYjNSaGJGUnBZMnR6SUNzZ0p5QjBhV05yY3k0bktUdGNibHh1WEhSY2RIUm9hWE11ZEhKcFoyZGxjbEJzWVhsbGNrVjJaVzUwS0NkbWFXeGxURzloWkdWa0p5d2dkR2hwY3lrN1hHNWNkRngwY21WMGRYSnVJSFJvYVhNN1hHNWNkSDFjYmx4dVhIUXZLaXBjYmx4MElDb2dVbVZ6WlhSeklIQnNZWGtnY0c5cGJuUmxjbk1nWm05eUlHRnNiQ0IwY21GamEzTXVYRzVjZENBcUlFQnlaWFIxY200Z2UxQnNZWGxsY24xY2JseDBJQ292WEc1Y2RISmxjMlYwVkhKaFkydHpLQ2tnZTF4dVhIUmNkSFJvYVhNdWRISmhZMnR6TG1admNrVmhZMmdvZEhKaFkyc2dQVDRnZEhKaFkyc3VjbVZ6WlhRb0tTazdYRzVjZEZ4MGNtVjBkWEp1SUhSb2FYTTdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nUjJWMGN5QmhiaUJoY25KaGVTQnZaaUJsZG1WdWRITWdaM0p2ZFhCbFpDQmllU0IwY21GamF5NWNibHgwSUNvZ1FISmxkSFZ5YmlCN1lYSnlZWGw5WEc1Y2RDQXFMMXh1WEhSblpYUkZkbVZ1ZEhNb0tTQjdYRzVjZEZ4MGNtVjBkWEp1SUhSb2FYTXVkSEpoWTJ0ekxtMWhjQ2gwY21GamF5QTlQaUIwY21GamF5NWxkbVZ1ZEhNcE8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRWRsZEhNZ2RHOTBZV3dnYm5WdFltVnlJRzltSUhScFkydHpJR2x1SUhSb1pTQnNiMkZrWldRZ1RVbEVTU0JtYVd4bExseHVYSFFnS2lCQWNtVjBkWEp1SUh0dWRXMWlaWEo5WEc1Y2RDQXFMMXh1WEhSblpYUlViM1JoYkZScFkydHpLQ2tnZTF4dVhIUmNkSEpsZEhWeWJpQk5ZWFJvTG0xaGVDNWhjSEJzZVNodWRXeHNMQ0IwYUdsekxuUnlZV05yY3k1dFlYQW9kSEpoWTJzZ1BUNGdkSEpoWTJzdVpHVnNkR0VwS1R0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkhaWFJ6SUhSdmRHRnNJRzUxYldKbGNpQnZaaUJsZG1WdWRITWdhVzRnZEdobElHeHZZV1JsWkNCTlNVUkpJR1pwYkdVdVhHNWNkQ0FxSUVCeVpYUjFjbTRnZTI1MWJXSmxjbjFjYmx4MElDb3ZYRzVjZEdkbGRGUnZkR0ZzUlhabGJuUnpLQ2tnZTF4dVhIUmNkSEpsZEhWeWJpQjBhR2x6TG5SeVlXTnJjeTV5WldSMVkyVW9LR0VzSUdJcElEMCtJSHR5WlhSMWNtNGdlMlYyWlc1MGN6b2dlMnhsYm1kMGFEb2dZUzVsZG1WdWRITXViR1Z1WjNSb0lDc2dZaTVsZG1WdWRITXViR1Z1WjNSb2ZYMTlMQ0I3WlhabGJuUnpPaUI3YkdWdVozUm9PaUF3ZlgwcExtVjJaVzUwY3k1c1pXNW5kR2c3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1IyVjBjeUJ6YjI1bklHUjFjbUYwYVc5dUlHbHVJSE5sWTI5dVpITXVYRzVjZENBcUlFQnlaWFIxY200Z2UyNTFiV0psY24xY2JseDBJQ292WEc1Y2RHZGxkRk52Ym1kVWFXMWxLQ2tnZTF4dVhIUmNkSEpsZEhWeWJpQjBhR2x6TG5SdmRHRnNWR2xqYTNNZ0x5QjBhR2x6TG1ScGRtbHphVzl1SUM4Z2RHaHBjeTUwWlcxd2J5QXFJRFl3TzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFZGxkSE1nY21WdFlXbHVhVzVuSUc1MWJXSmxjaUJ2WmlCelpXTnZibVJ6SUdsdUlIQnNZWGxpWVdOckxseHVYSFFnS2lCQWNtVjBkWEp1SUh0dWRXMWlaWEo5WEc1Y2RDQXFMMXh1WEhSblpYUlRiMjVuVkdsdFpWSmxiV0ZwYm1sdVp5Z3BJSHRjYmx4MFhIUnlaWFIxY200Z1RXRjBhQzV5YjNWdVpDZ29kR2hwY3k1MGIzUmhiRlJwWTJ0eklDMGdkR2hwY3k1blpYUkRkWEp5Wlc1MFZHbGpheWdwS1NBdklIUm9hWE11WkdsMmFYTnBiMjRnTHlCMGFHbHpMblJsYlhCdklDb2dOakFwTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFZGxkSE1nY21WdFlXbHVhVzVuSUhCbGNtTmxiblFnYjJZZ2NHeGhlV0poWTJzdVhHNWNkQ0FxSUVCeVpYUjFjbTRnZTI1MWJXSmxjbjFjYmx4MElDb3ZYRzVjZEdkbGRGTnZibWRRWlhKalpXNTBVbVZ0WVdsdWFXNW5LQ2tnZTF4dVhIUmNkSEpsZEhWeWJpQk5ZWFJvTG5KdmRXNWtLSFJvYVhNdVoyVjBVMjl1WjFScGJXVlNaVzFoYVc1cGJtY29LU0F2SUhSb2FYTXVaMlYwVTI5dVoxUnBiV1VvS1NBcUlERXdNQ2s3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1RuVnRZbVZ5SUc5bUlHSjVkR1Z6SUhCeWIyTmxjM05sWkNCcGJpQjBhR1VnYkc5aFpHVmtJRTFKUkVrZ1ptbHNaUzVjYmx4MElDb2dRSEpsZEhWeWJpQjdiblZ0WW1WeWZWeHVYSFFnS2k5Y2JseDBZbmwwWlhOUWNtOWpaWE56WldRb0tTQjdYRzVjZEZ4MEx5OGdRM1Z5Y21WdWRHeDVJR0Z6YzNWdFpTQm9aV0ZrWlhJZ1kyaDFibXNnYVhNZ2MzUnlhV04wYkhrZ01UUWdZbmwwWlhOY2JseDBYSFJ5WlhSMWNtNGdNVFFnS3lCMGFHbHpMblJ5WVdOcmN5NXNaVzVuZEdnZ0tpQTRJQ3NnZEdocGN5NTBjbUZqYTNNdWNtVmtkV05sS0NoaExDQmlLU0E5UGlCN2NtVjBkWEp1SUh0d2IybHVkR1Z5T2lCaExuQnZhVzUwWlhJZ0t5QmlMbkJ2YVc1MFpYSjlmU3dnZTNCdmFXNTBaWEk2SURCOUtTNXdiMmx1ZEdWeU8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRTUxYldKbGNpQnZaaUJsZG1WdWRITWdjR3hoZVdWa0lIVndJSFJ2SUhSb2FYTWdjRzlwYm5RdVhHNWNkQ0FxSUVCeVpYUjFjbTRnZTI1MWJXSmxjbjFjYmx4MElDb3ZYRzVjZEdWMlpXNTBjMUJzWVhsbFpDZ3BJSHRjYmx4MFhIUnlaWFIxY200Z2RHaHBjeTUwY21GamEzTXVjbVZrZFdObEtDaGhMQ0JpS1NBOVBpQjdjbVYwZFhKdUlIdGxkbVZ1ZEVsdVpHVjRPaUJoTG1WMlpXNTBTVzVrWlhnZ0t5QmlMbVYyWlc1MFNXNWtaWGg5ZlN3Z2UyVjJaVzUwU1c1a1pYZzZJREI5S1M1bGRtVnVkRWx1WkdWNE8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRVJsZEdWeWJXbHVaWE1nYVdZZ2RHaGxJSEJzWVhsbGNpQndiMmx1ZEdWeUlHaGhjeUJ5WldGamFHVmtJSFJvWlNCbGJtUWdiMllnZEdobElHeHZZV1JsWkNCTlNVUkpJR1pwYkdVdVhHNWNkQ0FxSUZWelpXUWdhVzRnZEhkdklIZGhlWE02WEc1Y2RDQXFJREV1SUVsbUlIQnNZWGxwYm1jZ2NtVnpkV3gwSUdseklHSmhjMlZrSUc5dUlHeHZZV1JsWkNCS1UwOU9JR1YyWlc1MGN5NWNibHgwSUNvZ01pNGdTV1lnY0dGeWMybHVaeUFvWkhKNVVuVnVLU0JwZENkeklHSmhjMlZrSUc5dUlIUm9aU0JoWTNSMVlXd2dZblZtWm1WeUlHeGxibWQwYUNCMmN5QmllWFJsY3lCd2NtOWpaWE56WldRdVhHNWNkQ0FxSUVCeVpYUjFjbTRnZTJKdmIyeGxZVzU5WEc1Y2RDQXFMMXh1WEhSbGJtUlBaa1pwYkdVb0tTQjdYRzVjZEZ4MGFXWWdLSFJvYVhNdWFYTlFiR0Y1YVc1bktDa3BJSHRjYmx4MFhIUmNkSEpsZEhWeWJpQjBhR2x6TG5SdmRHRnNWR2xqYTNNZ0xTQjBhR2x6TG5ScFkyc2dQRDBnTUR0Y2JseDBYSFI5WEc1Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3k1aWVYUmxjMUJ5YjJObGMzTmxaQ2dwSUQwOUlIUm9hWE11WW5WbVptVnlMbXhsYm1kMGFEdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJIWlhSeklIUm9aU0JqZFhKeVpXNTBJSFJwWTJzZ2JuVnRZbVZ5SUdsdUlIQnNZWGxpWVdOckxseHVYSFFnS2lCQWNtVjBkWEp1SUh0dWRXMWlaWEo5WEc1Y2RDQXFMMXh1WEhSblpYUkRkWEp5Wlc1MFZHbGpheWdwSUh0Y2JseDBYSFJwWmlnaGRHaHBjeTV6ZEdGeWRGUnBiV1VnSmlZZ2RHaHBjeTUwYVdOcktTQnlaWFIxY200Z2RHaHBjeTV6ZEdGeWRGUnBZMnM3WEc1Y2RGeDBaV3h6WlNCcFppZ2hkR2hwY3k1emRHRnlkRlJwYldVcElISmxkSFZ5YmlBd08xeHVYSFJjZEhKbGRIVnliaUJOWVhSb0xuSnZkVzVrS0Nnb2JtVjNJRVJoZEdVb0tTa3VaMlYwVkdsdFpTZ3BJQzBnZEdocGN5NXpkR0Z5ZEZScGJXVXBJQzhnTVRBd01DQXFJQ2gwYUdsekxtUnBkbWx6YVc5dUlDb2dLSFJvYVhNdWRHVnRjRzhnTHlBMk1Da3BLU0FySUhSb2FYTXVjM1JoY25SVWFXTnJPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUZObGJtUnpJRTFKUkVrZ1pYWmxiblFnYjNWMElIUnZJR3hwYzNSbGJtVnlMbHh1WEhRZ0tpQkFjR0Z5WVcwZ2UyOWlhbVZqZEgxY2JseDBJQ29nUUhKbGRIVnliaUI3VUd4aGVXVnlmVnh1WEhRZ0tpOWNibHgwWlcxcGRFVjJaVzUwS0dWMlpXNTBLU0I3WEc1Y2RGeDBkR2hwY3k1MGNtbG5aMlZ5VUd4aGVXVnlSWFpsYm5Rb0oyMXBaR2xGZG1WdWRDY3NJR1YyWlc1MEtUdGNibHgwWEhSeVpYUjFjbTRnZEdocGN6dGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJUZFdKelkzSnBZbVZ6SUdWMlpXNTBjeUIwYnlCc2FYTjBaVzVsY25OY2JseDBJQ29nUUhCaGNtRnRJSHR6ZEhKcGJtZDlJQzBnVG1GdFpTQnZaaUJsZG1WdWRDQjBieUJ6ZFdKelkzSnBZbVVnZEc4dVhHNWNkQ0FxSUVCd1lYSmhiU0I3Wm5WdVkzUnBiMjU5SUMwZ1EyRnNiR0poWTJzZ2RHOGdabWx5WlNCM2FHVnVJR1YyWlc1MElHbHpJR0p5YjJGa1kyRnpkQzVjYmx4MElDb2dRSEpsZEhWeWJpQjdVR3hoZVdWeWZWeHVYSFFnS2k5Y2JseDBiMjRvY0d4aGVXVnlSWFpsYm5Rc0lHWnVLU0I3WEc1Y2RGeDBhV1lnS0NGMGFHbHpMbVYyWlc1MFRHbHpkR1Z1WlhKekxtaGhjMDkzYmxCeWIzQmxjblI1S0hCc1lYbGxja1YyWlc1MEtTa2dkR2hwY3k1bGRtVnVkRXhwYzNSbGJtVnljMXR3YkdGNVpYSkZkbVZ1ZEYwZ1BTQmJYVHRjYmx4MFhIUjBhR2x6TG1WMlpXNTBUR2x6ZEdWdVpYSnpXM0JzWVhsbGNrVjJaVzUwWFM1d2RYTm9LR1p1S1R0Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3p0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkNjbTloWkdOaGMzUnpJR1YyWlc1MElIUnZJSFJ5YVdkblpYSWdjM1ZpYzJOeWFXSmxaQ0JqWVd4c1ltRmphM011WEc1Y2RDQXFJRUJ3WVhKaGJTQjdjM1J5YVc1bmZTQXRJRTVoYldVZ2IyWWdaWFpsYm5RdVhHNWNkQ0FxSUVCd1lYSmhiU0I3YjJKcVpXTjBmU0F0SUVSaGRHRWdkRzhnWW1VZ2NHRnpjMlZrSUhSdklITjFZbk5qY21saVpYSWdZMkZzYkdKaFkyc3VYRzVjZENBcUlFQnlaWFIxY200Z2UxQnNZWGxsY24xY2JseDBJQ292WEc1Y2RIUnlhV2RuWlhKUWJHRjVaWEpGZG1WdWRDaHdiR0Y1WlhKRmRtVnVkQ3dnWkdGMFlTa2dlMXh1WEhSY2RHbG1JQ2gwYUdsekxtVjJaVzUwVEdsemRHVnVaWEp6TG1oaGMwOTNibEJ5YjNCbGNuUjVLSEJzWVhsbGNrVjJaVzUwS1NrZ2RHaHBjeTVsZG1WdWRFeHBjM1JsYm1WeWMxdHdiR0Y1WlhKRmRtVnVkRjB1Wm05eVJXRmphQ2htYmlBOVBpQm1iaWhrWVhSaElIeDhJSHQ5S1NrN1hHNWNkRngwY21WMGRYSnVJSFJvYVhNN1hHNWNkSDFjYmx4dWZWeHVYRzVsZUhCdmNuUnpMbEJzWVhsbGNpQTlJRkJzWVhsbGNqdGNiaUlzSW1OdmJuTjBJRU52Ym5OMFlXNTBjeUE5SUhKbGNYVnBjbVVvWENJdUwyTnZibk4wWVc1MGMxd2lLUzVEYjI1emRHRnVkSE03WEc1amIyNXpkQ0JWZEdsc2N5QTlJSEpsY1hWcGNtVW9YQ0l1TDNWMGFXeHpYQ0lwTGxWMGFXeHpPMXh1WEc0dktpcGNiaUFxSUVOc1lYTnpJSEpsY0hKbGMyVnVkR2x1WnlCaElIUnlZV05yTGlBZ1EyOXVkR0ZwYm5NZ2JXVjBhRzlrY3lCbWIzSWdjR0Z5YzJsdVp5QmxkbVZ1ZEhNZ1lXNWtJR3RsWlhCcGJtY2dkSEpoWTJzZ2IyWWdjRzlwYm5SbGNpNWNiaUFxTDF4dVkyeGhjM01nVkhKaFkydGNkSHRjYmx4MFkyOXVjM1J5ZFdOMGIzSW9hVzVrWlhnc0lHUmhkR0VwSUh0Y2JseDBYSFIwYUdsekxtVnVZV0pzWldRZ1BTQjBjblZsTzF4dVhIUmNkSFJvYVhNdVpYWmxiblJKYm1SbGVDQTlJREE3WEc1Y2RGeDBkR2hwY3k1d2IybHVkR1Z5SUQwZ01EdGNibHgwWEhSMGFHbHpMbXhoYzNSVWFXTnJJRDBnTUR0Y2JseDBYSFIwYUdsekxteGhjM1JUZEdGMGRYTWdQU0J1ZFd4c08xeHVYSFJjZEhSb2FYTXVhVzVrWlhnZ1BTQnBibVJsZUR0Y2JseDBYSFIwYUdsekxtUmhkR0VnUFNCa1lYUmhPMXh1WEhSY2RIUm9hWE11WkdWc2RHRWdQU0F3TzF4dVhIUmNkSFJvYVhNdWNuVnVibWx1WjBSbGJIUmhJRDBnTUR0Y2JseDBYSFIwYUdsekxtVjJaVzUwY3lBOUlGdGRPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUZKbGMyVjBjeUJoYkd3Z2MzUmhkR1ZtZFd3Z2RISmhZMnNnYVc1bWIzSnRZV2x2YmlCMWMyVmtJR1IxY21sdVp5QndiR0Y1WW1GamF5NWNibHgwSUNvZ1FISmxkSFZ5YmlCN1ZISmhZMnQ5WEc1Y2RDQXFMMXh1WEhSeVpYTmxkQ2dwSUh0Y2JseDBYSFIwYUdsekxtVnVZV0pzWldRZ1BTQjBjblZsTzF4dVhIUmNkSFJvYVhNdVpYWmxiblJKYm1SbGVDQTlJREE3WEc1Y2RGeDBkR2hwY3k1d2IybHVkR1Z5SUQwZ01EdGNibHgwWEhSMGFHbHpMbXhoYzNSVWFXTnJJRDBnTUR0Y2JseDBYSFIwYUdsekxteGhjM1JUZEdGMGRYTWdQU0J1ZFd4c08xeHVYSFJjZEhSb2FYTXVaR1ZzZEdFZ1BTQXdPMXh1WEhSY2RIUm9hWE11Y25WdWJtbHVaMFJsYkhSaElEMGdNRHRjYmx4MFhIUnlaWFIxY200Z2RHaHBjenRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCVFpYUnpJSFJvYVhNZ2RISmhZMnNnZEc4Z1ltVWdaVzVoWW14bFpDQmtkWEpwYm1jZ2NHeGhlV0poWTJzdVhHNWNkQ0FxSUVCeVpYUjFjbTRnZTFSeVlXTnJmVnh1WEhRZ0tpOWNibHgwWlc1aFlteGxLQ2tnZTF4dVhIUmNkSFJvYVhNdVpXNWhZbXhsWkNBOUlIUnlkV1U3WEc1Y2RGeDBjbVYwZFhKdUlIUm9hWE03WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1UyVjBjeUIwYUdseklIUnlZV05ySUhSdklHSmxJR1JwYzJGaWJHVmtJR1IxY21sdVp5QndiR0Y1WW1GamF5NWNibHgwSUNvZ1FISmxkSFZ5YmlCN1ZISmhZMnQ5WEc1Y2RDQXFMMXh1WEhSa2FYTmhZbXhsS0NrZ2UxeHVYSFJjZEhSb2FYTXVaVzVoWW14bFpDQTlJR1poYkhObE8xeHVYSFJjZEhKbGRIVnliaUIwYUdsek8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRk5sZEhNZ2RHaGxJSFJ5WVdOcklHVjJaVzUwSUdsdVpHVjRJSFJ2SUhSb1pTQnVaV0Z5WlhOMElHVjJaVzUwSUhSdklIUm9aU0JuYVhabGJpQjBhV05yTGx4dVhIUWdLaUJBY0dGeVlXMGdlMjUxYldKbGNuMGdkR2xqYTF4dVhIUWdLaUJBY21WMGRYSnVJSHRVY21GamEzMWNibHgwSUNvdlhHNWNkSE5sZEVWMlpXNTBTVzVrWlhoQ2VWUnBZMnNvZEdsamF5a2dlMXh1WEhSY2RIUnBZMnNnUFNCMGFXTnJJSHg4SURBN1hHNWNibHgwWEhSbWIzSWdLSFpoY2lCcElHbHVJSFJvYVhNdVpYWmxiblJ6S1NCN1hHNWNkRngwWEhScFppQW9kR2hwY3k1bGRtVnVkSE5iYVYwdWRHbGpheUErUFNCMGFXTnJLU0I3WEc1Y2RGeDBYSFJjZEhSb2FYTXVaWFpsYm5SSmJtUmxlQ0E5SUdrN1hHNWNkRngwWEhSY2RISmxkSFZ5YmlCMGFHbHpPMXh1WEhSY2RGeDBmVnh1WEhSY2RIMWNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJIWlhSeklHSjVkR1VnYkc5allYUmxaQ0JoZENCd2IybHVkR1Z5SUhCdmMybDBhVzl1TGx4dVhIUWdLaUJBY21WMGRYSnVJSHR1ZFcxaVpYSjlYRzVjZENBcUwxeHVYSFJuWlhSRGRYSnlaVzUwUW5sMFpTZ3BJSHRjYmx4MFhIUnlaWFIxY200Z2RHaHBjeTVrWVhSaFczUm9hWE11Y0c5cGJuUmxjbDA3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1IyVjBjeUJqYjNWdWRDQnZaaUJrWld4MFlTQmllWFJsY3lCaGJtUWdZM1Z5Y21WdWRDQndiMmx1ZEdWeUlIQnZjMmwwYVc5dUxseHVYSFFnS2lCQWNtVjBkWEp1SUh0dWRXMWlaWEo5WEc1Y2RDQXFMMXh1WEhSblpYUkVaV3gwWVVKNWRHVkRiM1Z1ZENncElIdGNibHgwWEhRdkx5QkhaWFFnWW5sMFpTQmpiM1Z1ZENCdlppQmtaV3gwWVNCV1RGWmNibHgwWEhRdkx5Qm9kSFJ3T2k4dmQzZDNMbU5qWVhKb0xtOXlaeTlqYjNWeWMyVnpMekkxTXk5b1lXNWtiM1YwTDNac2RpOWNibHgwWEhRdkx5QkpaaUJpZVhSbElHbHpJR2R5WldGMFpYSWdiM0lnWlhGMVlXd2dkRzhnT0RCb0lDZ3hNamdnWkdWamFXMWhiQ2tnZEdobGJpQjBhR1VnYm1WNGRDQmllWFJsWEc1Y2RDQWdJQ0F2THlCcGN5QmhiSE52SUhCaGNuUWdiMllnZEdobElGWk1WaXhjYmx4MElDQWdYSFF2THlCbGJITmxJR0o1ZEdVZ2FYTWdkR2hsSUd4aGMzUWdZbmwwWlNCcGJpQmhJRlpNVmk1Y2JseDBJQ0FnWEhSMllYSWdZM1Z5Y21WdWRFSjVkR1VnUFNCMGFHbHpMbWRsZEVOMWNuSmxiblJDZVhSbEtDazdYRzVjZENBZ0lGeDBkbUZ5SUdKNWRHVkRiM1Z1ZENBOUlERTdYRzVjYmx4MFhIUjNhR2xzWlNBb1kzVnljbVZ1ZEVKNWRHVWdQajBnTVRJNEtTQjdYRzVjZEZ4MFhIUmpkWEp5Wlc1MFFubDBaU0E5SUhSb2FYTXVaR0YwWVZ0MGFHbHpMbkJ2YVc1MFpYSWdLeUJpZVhSbFEyOTFiblJkTzF4dVhIUmNkRngwWW5sMFpVTnZkVzUwS3lzN1hHNWNkRngwZlZ4dVhHNWNkRngwY21WMGRYSnVJR0o1ZEdWRGIzVnVkRHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCSFpYUWdaR1ZzZEdFZ2RtRnNkV1VnWVhRZ1kzVnljbVZ1ZENCd2IybHVkR1Z5SUhCdmMybDBhVzl1TGx4dVhIUWdLaUJBY21WMGRYSnVJSHR1ZFcxaVpYSjlYRzVjZENBcUwxeHVYSFJuWlhSRVpXeDBZU2dwSUh0Y2JseDBYSFJ5WlhSMWNtNGdWWFJwYkhNdWNtVmhaRlpoY2tsdWRDaDBhR2x6TG1SaGRHRXVjM1ZpWVhKeVlYa29kR2hwY3k1d2IybHVkR1Z5TENCMGFHbHpMbkJ2YVc1MFpYSWdLeUIwYUdsekxtZGxkRVJsYkhSaFFubDBaVU52ZFc1MEtDa3BLVHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCSVlXNWtiR1Z6SUdWMlpXNTBJSGRwZEdocGJpQmhJR2RwZG1WdUlIUnlZV05ySUhOMFlYSjBhVzVuSUdGMElITndaV05wWm1sbFpDQnBibVJsZUZ4dVhIUWdLaUJBY0dGeVlXMGdlMjUxYldKbGNuMGdZM1Z5Y21WdWRGUnBZMnRjYmx4MElDb2dRSEJoY21GdElIdGliMjlzWldGdWZTQmtjbmxTZFc0Z0xTQkpaaUIwY25WbElHVjJaVzUwY3lCM2FXeHNJR0psSUhCaGNuTmxaQ0JoYm1RZ2NtVjBkWEp1WldRZ2NtVm5ZWEprYkdWemN5QnZaaUIwYVcxbExseHVYSFFnS2k5Y2JseDBhR0Z1Wkd4bFJYWmxiblFvWTNWeWNtVnVkRlJwWTJzc0lHUnllVkoxYmlrZ2UxeHVYSFJjZEdSeWVWSjFiaUE5SUdSeWVWSjFiaUI4ZkNCbVlXeHpaVHRjYmx4dVhIUmNkR2xtSUNoa2NubFNkVzRwSUh0Y2JseDBYSFJjZEhaaGNpQmxiR0Z3YzJWa1ZHbGphM01nUFNCamRYSnlaVzUwVkdsamF5QXRJSFJvYVhNdWJHRnpkRlJwWTJzN1hHNWNkRngwWEhSMllYSWdaR1ZzZEdFZ1BTQjBhR2x6TG1kbGRFUmxiSFJoS0NrN1hHNWNkRngwWEhSMllYSWdaWFpsYm5SU1pXRmtlU0E5SUdWc1lYQnpaV1JVYVdOcmN5QStQU0JrWld4MFlUdGNibHh1WEhSY2RGeDBhV1lnS0hSb2FYTXVjRzlwYm5SbGNpQThJSFJvYVhNdVpHRjBZUzVzWlc1bmRHZ2dKaVlnS0dSeWVWSjFiaUI4ZkNCbGRtVnVkRkpsWVdSNUtTa2dlMXh1WEhSY2RGeDBYSFJzWlhRZ1pYWmxiblFnUFNCMGFHbHpMbkJoY25ObFJYWmxiblFvS1R0Y2JseDBYSFJjZEZ4MGFXWWdLSFJvYVhNdVpXNWhZbXhsWkNrZ2NtVjBkWEp1SUdWMlpXNTBPMXh1WEhSY2RGeDBYSFF2THlCU1pXTjFjbk5wZG1Wc2VTQmpZV3hzSUhSb2FYTWdablZ1WTNScGIyNGdabTl5SUdWaFkyZ2daWFpsYm5RZ1lXaGxZV1FnZEdoaGRDQm9ZWE1nTUNCa1pXeDBZU0IwYVcxbFAxeHVYSFJjZEZ4MGZWeHVYRzVjZEZ4MGZTQmxiSE5sSUh0Y2JseDBYSFJjZEM4dklFeGxkQ2R6SUdGamRIVmhiR3g1SUhCc1lYa2dkR2hsSUUxSlJFa2dabkp2YlNCMGFHVWdaMlZ1WlhKaGRHVmtJRXBUVDA0Z1pYWmxiblJ6SUdOeVpXRjBaV1FnWW5rZ2RHaGxJR1J5ZVNCeWRXNHVYRzVjZEZ4MFhIUnBaaUFvZEdocGN5NWxkbVZ1ZEhOYmRHaHBjeTVsZG1WdWRFbHVaR1Y0WFNBbUppQjBhR2x6TG1WMlpXNTBjMXQwYUdsekxtVjJaVzUwU1c1a1pYaGRMblJwWTJzZ1BEMGdZM1Z5Y21WdWRGUnBZMnNwSUh0Y2JseDBYSFJjZEZ4MGRHaHBjeTVsZG1WdWRFbHVaR1Y0S3lzN1hHNWNkRngwWEhSY2RHbG1JQ2gwYUdsekxtVnVZV0pzWldRcElISmxkSFZ5YmlCMGFHbHpMbVYyWlc1MGMxdDBhR2x6TG1WMlpXNTBTVzVrWlhnZ0xTQXhYVHRjYmx4MFhIUmNkSDFjYmx4MFhIUjlYRzVjYmx4MFhIUnlaWFIxY200Z2JuVnNiRHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCSFpYUWdjM1J5YVc1bklHUmhkR0VnWm5KdmJTQmxkbVZ1ZEM1Y2JseDBJQ29nUUhCaGNtRnRJSHR1ZFcxaVpYSjlJR1YyWlc1MFUzUmhjblJKYm1SbGVGeHVYSFFnS2lCQWNtVjBkWEp1SUh0emRISnBibWQ5WEc1Y2RDQXFMMXh1WEhSblpYUlRkSEpwYm1kRVlYUmhLR1YyWlc1MFUzUmhjblJKYm1SbGVDa2dlMXh1WEhSY2RIWmhjaUJqZFhKeVpXNTBRbmwwWlNBOUlIUm9hWE11Y0c5cGJuUmxjanRjYmx4MFhIUjJZWElnWW5sMFpVTnZkVzUwSUQwZ01UdGNibHgwWEhSMllYSWdiR1Z1WjNSb0lEMGdWWFJwYkhNdWNtVmhaRlpoY2tsdWRDaDBhR2x6TG1SaGRHRXVjM1ZpWVhKeVlYa29aWFpsYm5SVGRHRnlkRWx1WkdWNElDc2dNaXdnWlhabGJuUlRkR0Z5ZEVsdVpHVjRJQ3NnTWlBcklHSjVkR1ZEYjNWdWRDa3BPMXh1WEhSY2RIWmhjaUJ6ZEhKcGJtZE1aVzVuZEdnZ1BTQnNaVzVuZEdnN1hHNWNibHgwWEhSeVpYUjFjbTRnVlhScGJITXVZbmwwWlhOVWIweGxkSFJsY25Nb2RHaHBjeTVrWVhSaExuTjFZbUZ5Y21GNUtHVjJaVzUwVTNSaGNuUkpibVJsZUNBcklHSjVkR1ZEYjNWdWRDQXJJRElzSUdWMlpXNTBVM1JoY25SSmJtUmxlQ0FySUdKNWRHVkRiM1Z1ZENBcklHeGxibWQwYUNBcklESXBLVHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCUVlYSnpaWE1nWlhabGJuUWdhVzUwYnlCS1UwOU9JR0Z1WkNCaFpIWmhibU5sY3lCd2IybHVkR1Z5SUdadmNpQjBhR1VnZEhKaFkydGNibHgwSUNvZ1FISmxkSFZ5YmlCN2IySnFaV04wZlZ4dVhIUWdLaTljYmx4MGNHRnljMlZGZG1WdWRDZ3BJSHRjYmx4MFhIUjJZWElnWlhabGJuUlRkR0Z5ZEVsdVpHVjRJRDBnZEdocGN5NXdiMmx1ZEdWeUlDc2dkR2hwY3k1blpYUkVaV3gwWVVKNWRHVkRiM1Z1ZENncE8xeHVYSFJjZEhaaGNpQmxkbVZ1ZEVwemIyNGdQU0I3ZlR0Y2JseDBYSFIyWVhJZ1pHVnNkR0ZDZVhSbFEyOTFiblFnUFNCMGFHbHpMbWRsZEVSbGJIUmhRbmwwWlVOdmRXNTBLQ2s3WEc1Y2RGeDBaWFpsYm5SS2MyOXVMblJ5WVdOcklEMGdkR2hwY3k1cGJtUmxlQ0FySURFN1hHNWNkRngwWlhabGJuUktjMjl1TG1SbGJIUmhJRDBnZEdocGN5NW5aWFJFWld4MFlTZ3BPMXh1WEhSY2RIUm9hWE11YkdGemRGUnBZMnNnUFNCMGFHbHpMbXhoYzNSVWFXTnJJQ3NnWlhabGJuUktjMjl1TG1SbGJIUmhPMXh1WEhSY2RIUm9hWE11Y25WdWJtbHVaMFJsYkhSaElDczlJR1YyWlc1MFNuTnZiaTVrWld4MFlUdGNibHgwWEhSbGRtVnVkRXB6YjI0dWRHbGpheUE5SUhSb2FYTXVjblZ1Ym1sdVowUmxiSFJoTzF4dVhIUmNkR1YyWlc1MFNuTnZiaTVpZVhSbFNXNWtaWGdnUFNCMGFHbHpMbkJ2YVc1MFpYSTdYRzVjYmx4MFhIUXZMMlYyWlc1MFNuTnZiaTV5WVhjZ1BTQmxkbVZ1ZER0Y2JseDBYSFJwWmlBb2RHaHBjeTVrWVhSaFcyVjJaVzUwVTNSaGNuUkpibVJsZUYwZ1BUMGdNSGhtWmlrZ2UxeHVYSFJjZEZ4MEx5OGdUV1YwWVNCRmRtVnVkRnh1WEc1Y2RGeDBYSFF2THlCSlppQjBhR2x6SUdseklHRWdiV1YwWVNCbGRtVnVkQ0IzWlNCemFHOTFiR1FnWlcxcGRDQjBhR1VnWkdGMFlTQmhibVFnYVcxdFpXUnBZWFJsYkhrZ2JXOTJaU0IwYnlCMGFHVWdibVY0ZENCbGRtVnVkRnh1WEhSY2RGeDBMeThnYjNSb1pYSjNhWE5sSUdsbUlIZGxJR3hsZENCcGRDQnlkVzRnZEdoeWIzVm5hQ0IwYUdVZ2JtVjRkQ0JqZVdOc1pTQmhJSE5zYVdkb2RDQmtaV3hoZVNCM2FXeHNJR0ZqWTNWdGRXeGhkR1VnYVdZZ2JYVnNkR2x3YkdVZ2RISmhZMnR6WEc1Y2RGeDBYSFF2THlCaGNtVWdZbVZwYm1jZ2NHeGhlV1ZrSUhOcGJYVnNkR0Z1Wlc5MWMyeDVYRzVjYmx4MFhIUmNkSE4zYVhSamFDaDBhR2x6TG1SaGRHRmJaWFpsYm5SVGRHRnlkRWx1WkdWNElDc2dNVjBwSUh0Y2JseDBYSFJjZEZ4MFkyRnpaU0F3ZURBd09pQXZMeUJUWlhGMVpXNWpaU0JPZFcxaVpYSmNibHgwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1Ym1GdFpTQTlJQ2RUWlhGMVpXNWpaU0JPZFcxaVpYSW5PMXh1WEhSY2RGeDBYSFJjZEdKeVpXRnJPMXh1WEhSY2RGeDBYSFJqWVhObElEQjRNREU2SUM4dklGUmxlSFFnUlhabGJuUmNibHgwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1Ym1GdFpTQTlJQ2RVWlhoMElFVjJaVzUwSnp0Y2JseDBYSFJjZEZ4MFhIUmxkbVZ1ZEVwemIyNHVjM1J5YVc1bklEMGdkR2hwY3k1blpYUlRkSEpwYm1kRVlYUmhLR1YyWlc1MFUzUmhjblJKYm1SbGVDazdYRzVjZEZ4MFhIUmNkRngwWW5KbFlXczdYRzVjZEZ4MFhIUmNkR05oYzJVZ01IZ3dNam9nTHk4Z1EyOXdlWEpwWjJoMElFNXZkR2xqWlZ4dVhIUmNkRngwWEhSY2RHVjJaVzUwU25OdmJpNXVZVzFsSUQwZ0owTnZjSGx5YVdkb2RDQk9iM1JwWTJVbk8xeHVYSFJjZEZ4MFhIUmNkR0p5WldGck8xeHVYSFJjZEZ4MFhIUmpZWE5sSURCNE1ETTZJQzh2SUZObGNYVmxibU5sTDFSeVlXTnJJRTVoYldWY2JseDBYSFJjZEZ4MFhIUmxkbVZ1ZEVwemIyNHVibUZ0WlNBOUlDZFRaWEYxWlc1alpTOVVjbUZqYXlCT1lXMWxKenRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dWMzUnlhVzVuSUQwZ2RHaHBjeTVuWlhSVGRISnBibWRFWVhSaEtHVjJaVzUwVTNSaGNuUkpibVJsZUNrN1hHNWNkRngwWEhSY2RGeDBZbkpsWVdzN1hHNWNkRngwWEhSY2RHTmhjMlVnTUhnd05Eb2dMeThnU1c1emRISjFiV1Z1ZENCT1lXMWxYRzVjZEZ4MFhIUmNkRngwWlhabGJuUktjMjl1TG01aGJXVWdQU0FuU1c1emRISjFiV1Z1ZENCT1lXMWxKenRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dWMzUnlhVzVuSUQwZ2RHaHBjeTVuWlhSVGRISnBibWRFWVhSaEtHVjJaVzUwVTNSaGNuUkpibVJsZUNrN1hHNWNkRngwWEhSY2RGeDBZbkpsWVdzN1hHNWNkRngwWEhSY2RHTmhjMlVnTUhnd05Ub2dMeThnVEhseWFXTmNibHgwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1Ym1GdFpTQTlJQ2RNZVhKcFl5YzdYRzVjZEZ4MFhIUmNkRngwWlhabGJuUktjMjl1TG5OMGNtbHVaeUE5SUhSb2FYTXVaMlYwVTNSeWFXNW5SR0YwWVNobGRtVnVkRk4wWVhKMFNXNWtaWGdwTzF4dVhIUmNkRngwWEhSY2RHSnlaV0ZyTzF4dVhIUmNkRngwWEhSallYTmxJREI0TURZNklDOHZJRTFoY210bGNseHVYSFJjZEZ4MFhIUmNkR1YyWlc1MFNuTnZiaTV1WVcxbElEMGdKMDFoY210bGNpYzdYRzVjZEZ4MFhIUmNkRngwWW5KbFlXczdYRzVjZEZ4MFhIUmNkR05oYzJVZ01IZ3dOem9nTHk4Z1EzVmxJRkJ2YVc1MFhHNWNkRngwWEhSY2RGeDBaWFpsYm5SS2MyOXVMbTVoYldVZ1BTQW5RM1ZsSUZCdmFXNTBKenRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dWMzUnlhVzVuSUQwZ2RHaHBjeTVuWlhSVGRISnBibWRFWVhSaEtHVjJaVzUwVTNSaGNuUkpibVJsZUNrN1hHNWNkRngwWEhSY2RGeDBZbkpsWVdzN1hHNWNkRngwWEhSY2RHTmhjMlVnTUhnd09Ub2dMeThnUkdWMmFXTmxJRTVoYldWY2JseDBYSFJjZEZ4MFhIUmxkbVZ1ZEVwemIyNHVibUZ0WlNBOUlDZEVaWFpwWTJVZ1RtRnRaU2M3WEc1Y2RGeDBYSFJjZEZ4MFpYWmxiblJLYzI5dUxuTjBjbWx1WnlBOUlIUm9hWE11WjJWMFUzUnlhVzVuUkdGMFlTaGxkbVZ1ZEZOMFlYSjBTVzVrWlhncE8xeHVYSFJjZEZ4MFhIUmNkR0p5WldGck8xeHVYSFJjZEZ4MFhIUmpZWE5sSURCNE1qQTZJQzh2SUUxSlJFa2dRMmhoYm01bGJDQlFjbVZtYVhoY2JseDBYSFJjZEZ4MFhIUmxkbVZ1ZEVwemIyNHVibUZ0WlNBOUlDZE5TVVJKSUVOb1lXNXVaV3dnVUhKbFptbDRKenRjYmx4MFhIUmNkRngwWEhSaWNtVmhhenRjYmx4MFhIUmNkRngwWTJGelpTQXdlREl4T2lBdkx5Qk5TVVJKSUZCdmNuUmNibHgwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1Ym1GdFpTQTlJQ2ROU1VSSklGQnZjblFuTzF4dVhIUmNkRngwWEhSY2RHVjJaVzUwU25OdmJpNWtZWFJoSUQwZ1ZYUnBiSE11WW5sMFpYTlViMDUxYldKbGNpaGJkR2hwY3k1a1lYUmhXMlYyWlc1MFUzUmhjblJKYm1SbGVDQXJJRE5kWFNrN1hHNWNkRngwWEhSY2RGeDBZbkpsWVdzN1hHNWNkRngwWEhSY2RHTmhjMlVnTUhneVJqb2dMeThnUlc1a0lHOW1JRlJ5WVdOclhHNWNkRngwWEhSY2RGeDBaWFpsYm5SS2MyOXVMbTVoYldVZ1BTQW5SVzVrSUc5bUlGUnlZV05ySnp0Y2JseDBYSFJjZEZ4MFhIUmljbVZoYXp0Y2JseDBYSFJjZEZ4MFkyRnpaU0F3ZURVeE9pQXZMeUJUWlhRZ1ZHVnRjRzljYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dWJtRnRaU0E5SUNkVFpYUWdWR1Z0Y0c4bk8xeHVYSFJjZEZ4MFhIUmNkR1YyWlc1MFNuTnZiaTVrWVhSaElEMGdUV0YwYUM1eWIzVnVaQ2cyTURBd01EQXdNQ0F2SUZWMGFXeHpMbUo1ZEdWelZHOU9kVzFpWlhJb2RHaHBjeTVrWVhSaExuTjFZbUZ5Y21GNUtHVjJaVzUwVTNSaGNuUkpibVJsZUNBcklETXNJR1YyWlc1MFUzUmhjblJKYm1SbGVDQXJJRFlwS1NrN1hHNWNkRngwWEhSY2RGeDBkR2hwY3k1MFpXMXdieUE5SUdWMlpXNTBTbk52Ymk1a1lYUmhPMXh1WEhSY2RGeDBYSFJjZEdKeVpXRnJPMXh1WEhSY2RGeDBYSFJqWVhObElEQjROVFE2SUM4dklGTk5WRkJGSUU5bVpuTmxkRnh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1dVlXMWxJRDBnSjFOTlZGQkZJRTltWm5ObGRDYzdYRzVjZEZ4MFhIUmNkRngwWW5KbFlXczdYRzVjZEZ4MFhIUmNkR05oYzJVZ01IZzFPRG9nTHk4Z1ZHbHRaU0JUYVdkdVlYUjFjbVZjYmx4MFhIUmNkRngwWEhRdkx5QkdSaUExT0NBd05DQnViaUJrWkNCall5QmlZbHh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1dVlXMWxJRDBnSjFScGJXVWdVMmxuYm1GMGRYSmxKenRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dVpHRjBZU0E5SUhSb2FYTXVaR0YwWVM1emRXSmhjbkpoZVNobGRtVnVkRk4wWVhKMFNXNWtaWGdnS3lBekxDQmxkbVZ1ZEZOMFlYSjBTVzVrWlhnZ0t5QTNLVHRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dWRHbHRaVk5wWjI1aGRIVnlaU0E5SUZ3aVhDSWdLeUJsZG1WdWRFcHpiMjR1WkdGMFlWc3dYU0FySUZ3aUwxd2lJQ3NnVFdGMGFDNXdiM2NvTWl3Z1pYWmxiblJLYzI5dUxtUmhkR0ZiTVYwcE8xeHVYSFJjZEZ4MFhIUmNkR0p5WldGck8xeHVYSFJjZEZ4MFhIUmpZWE5sSURCNE5UazZJQzh2SUV0bGVTQlRhV2R1WVhSMWNtVmNibHgwWEhSY2RGeDBYSFF2THlCR1JpQTFPU0F3TWlCelppQnRhVnh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1dVlXMWxJRDBnSjB0bGVTQlRhV2R1WVhSMWNtVW5PMXh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1a1lYUmhJRDBnZEdocGN5NWtZWFJoTG5OMVltRnljbUY1S0dWMlpXNTBVM1JoY25SSmJtUmxlQ0FySURNc0lHVjJaVzUwVTNSaGNuUkpibVJsZUNBcklEVXBPMXh1WEc1Y2RGeDBYSFJjZEZ4MGFXWWdLR1YyWlc1MFNuTnZiaTVrWVhSaFd6QmRJRDQ5SURBcElIdGNibHgwWEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1clpYbFRhV2R1WVhSMWNtVWdQU0JEYjI1emRHRnVkSE11UTBsU1EweEZYMDlHWDBaSlJsUklVMXRsZG1WdWRFcHpiMjR1WkdGMFlWc3dYVjA3WEc1Y2JseDBYSFJjZEZ4MFhIUjlJR1ZzYzJVZ2FXWWdLR1YyWlc1MFNuTnZiaTVrWVhSaFd6QmRJRHdnTUNrZ2UxeHVYSFJjZEZ4MFhIUmNkRngwWlhabGJuUktjMjl1TG10bGVWTnBaMjVoZEhWeVpTQTlJRU52Ym5OMFlXNTBjeTVEU1ZKRFRFVmZUMFpmUms5VlVsUklVMXROWVhSb0xtRmljeWhsZG1WdWRFcHpiMjR1WkdGMFlWc3dYU2xkTzF4dVhIUmNkRngwWEhSY2RIMWNibHh1WEhSY2RGeDBYSFJjZEdsbUlDaGxkbVZ1ZEVwemIyNHVaR0YwWVZzeFhTQTlQU0F3S1NCN1hHNWNkRngwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1YTJWNVUybG5ibUYwZFhKbElDczlJRndpSUUxaGFtOXlYQ0k3WEc1Y2JseDBYSFJjZEZ4MFhIUjlJR1ZzYzJVZ2FXWWdLR1YyWlc1MFNuTnZiaTVrWVhSaFd6RmRJRDA5SURFcElIdGNibHgwWEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1clpYbFRhV2R1WVhSMWNtVWdLejBnWENJZ1RXbHViM0pjSWp0Y2JseDBYSFJjZEZ4MFhIUjlYRzVjYmx4MFhIUmNkRngwWEhSaWNtVmhhenRjYmx4MFhIUmNkRngwWTJGelpTQXdlRGRHT2lBdkx5QlRaWEYxWlc1alpYSXRVM0JsWTJsbWFXTWdUV1YwWVMxbGRtVnVkRnh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1dVlXMWxJRDBnSjFObGNYVmxibU5sY2kxVGNHVmphV1pwWXlCTlpYUmhMV1YyWlc1MEp6dGNibHgwWEhSY2RGeDBYSFJpY21WaGF6dGNibHgwWEhSY2RGeDBaR1ZtWVhWc2REcGNibHgwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1Ym1GdFpTQTlJQ2RWYm10dWIzZHVPaUFuSUNzZ2RHaHBjeTVrWVhSaFcyVjJaVzUwVTNSaGNuUkpibVJsZUNBcklERmRMblJ2VTNSeWFXNW5LREUyS1R0Y2JseDBYSFJjZEZ4MFhIUmljbVZoYXp0Y2JseDBYSFJjZEgxY2JseHVYSFJjZEZ4MGRtRnlJR3hsYm1kMGFDQTlJSFJvYVhNdVpHRjBZVnQwYUdsekxuQnZhVzUwWlhJZ0t5QmtaV3gwWVVKNWRHVkRiM1Z1ZENBcklESmRPMXh1WEhSY2RGeDBMeThnVTI5dFpTQnRaWFJoSUdWMlpXNTBjeUIzYVd4c0lHaGhkbVVnZG14MklIUm9ZWFFnYm1WbFpITWdkRzhnWW1VZ2FHRnVaR3hsWkZ4dVhHNWNkRngwWEhSMGFHbHpMbkJ2YVc1MFpYSWdLejBnWkdWc2RHRkNlWFJsUTI5MWJuUWdLeUF6SUNzZ2JHVnVaM1JvTzF4dVhHNWNkRngwZlNCbGJITmxJR2xtS0hSb2FYTXVaR0YwWVZ0bGRtVnVkRk4wWVhKMFNXNWtaWGhkSUQwOUlEQjRaakFwSUh0Y2JseDBYSFJjZEM4dklGTjVjMlY0WEc1Y2RGeDBYSFJsZG1WdWRFcHpiMjR1Ym1GdFpTQTlJQ2RUZVhObGVDYzdYRzVjZEZ4MFhIUjJZWElnYkdWdVozUm9JRDBnZEdocGN5NWtZWFJoVzNSb2FYTXVjRzlwYm5SbGNpQXJJR1JsYkhSaFFubDBaVU52ZFc1MElDc2dNVjA3WEc1Y2RGeDBYSFIwYUdsekxuQnZhVzUwWlhJZ0t6MGdaR1ZzZEdGQ2VYUmxRMjkxYm5RZ0t5QXlJQ3NnYkdWdVozUm9PMXh1WEc1Y2RGeDBmU0JsYkhObElIdGNibHgwWEhSY2RDOHZJRlp2YVdObElHVjJaVzUwWEc1Y2RGeDBYSFJwWmlBb2RHaHBjeTVrWVhSaFcyVjJaVzUwVTNSaGNuUkpibVJsZUYwZ1BDQXdlRGd3S1NCN1hHNWNkRngwWEhSY2RDOHZJRkoxYm01cGJtY2djM1JoZEhWelhHNWNkRngwWEhSY2RHVjJaVzUwU25OdmJpNXlkVzV1YVc1bklEMGdkSEoxWlR0Y2JseDBYSFJjZEZ4MFpYWmxiblJLYzI5dUxtNXZkR1ZPZFcxaVpYSWdQU0IwYUdsekxtUmhkR0ZiWlhabGJuUlRkR0Z5ZEVsdVpHVjRYVHRjYmx4MFhIUmNkRngwWlhabGJuUktjMjl1TG01dmRHVk9ZVzFsSUQwZ1EyOXVjM1JoYm5SekxrNVBWRVZUVzNSb2FYTXVaR0YwWVZ0bGRtVnVkRk4wWVhKMFNXNWtaWGhkWFR0Y2JseDBYSFJjZEZ4MFpYWmxiblJLYzI5dUxuWmxiRzlqYVhSNUlEMGdkR2hwY3k1a1lYUmhXMlYyWlc1MFUzUmhjblJKYm1SbGVDQXJJREZkTzF4dVhHNWNkRngwWEhSY2RHbG1JQ2gwYUdsekxteGhjM1JUZEdGMGRYTWdQRDBnTUhnNFppa2dlMXh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1dVlXMWxJRDBnSjA1dmRHVWdiMlptSnp0Y2JseDBYSFJjZEZ4MFhIUmxkbVZ1ZEVwemIyNHVZMmhoYm01bGJDQTlJSFJvYVhNdWJHRnpkRk4wWVhSMWN5QXRJREI0T0RBZ0t5QXhPMXh1WEc1Y2RGeDBYSFJjZEgwZ1pXeHpaU0JwWmlBb2RHaHBjeTVzWVhOMFUzUmhkSFZ6SUR3OUlEQjRPV1lwSUh0Y2JseDBYSFJjZEZ4MFhIUmxkbVZ1ZEVwemIyNHVibUZ0WlNBOUlDZE9iM1JsSUc5dUp6dGNibHgwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1WTJoaGJtNWxiQ0E5SUhSb2FYTXViR0Z6ZEZOMFlYUjFjeUF0SURCNE9UQWdLeUF4TzF4dVhIUmNkRngwWEhSOVhHNWNibHgwWEhSY2RGeDBkR2hwY3k1d2IybHVkR1Z5SUNzOUlHUmxiSFJoUW5sMFpVTnZkVzUwSUNzZ01qdGNibHh1WEhSY2RGeDBmU0JsYkhObElIdGNibHgwWEhSY2RGeDBkR2hwY3k1c1lYTjBVM1JoZEhWeklEMGdkR2hwY3k1a1lYUmhXMlYyWlc1MFUzUmhjblJKYm1SbGVGMDdYRzVjYmx4MFhIUmNkRngwYVdZZ0tIUm9hWE11WkdGMFlWdGxkbVZ1ZEZOMFlYSjBTVzVrWlhoZElEdzlJREI0T0dZcElIdGNibHgwWEhSY2RGeDBYSFF2THlCT2IzUmxJRzltWmx4dVhIUmNkRngwWEhSY2RHVjJaVzUwU25OdmJpNXVZVzFsSUQwZ0owNXZkR1VnYjJabUp6dGNibHgwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1WTJoaGJtNWxiQ0E5SUhSb2FYTXViR0Z6ZEZOMFlYUjFjeUF0SURCNE9EQWdLeUF4TzF4dVhIUmNkRngwWEhSY2RHVjJaVzUwU25OdmJpNXViM1JsVG5WdFltVnlJRDBnZEdocGN5NWtZWFJoVzJWMlpXNTBVM1JoY25SSmJtUmxlQ0FySURGZE8xeHVYSFJjZEZ4MFhIUmNkR1YyWlc1MFNuTnZiaTV1YjNSbFRtRnRaU0E5SUVOdmJuTjBZVzUwY3k1T1QxUkZVMXQwYUdsekxtUmhkR0ZiWlhabGJuUlRkR0Z5ZEVsdVpHVjRJQ3NnTVYxZE8xeHVYSFJjZEZ4MFhIUmNkR1YyWlc1MFNuTnZiaTUyWld4dlkybDBlU0E5SUUxaGRHZ3VjbTkxYm1Rb2RHaHBjeTVrWVhSaFcyVjJaVzUwVTNSaGNuUkpibVJsZUNBcklESmRJQzhnTVRJM0lDb2dNVEF3S1R0Y2JseDBYSFJjZEZ4MFhIUjBhR2x6TG5CdmFXNTBaWElnS3owZ1pHVnNkR0ZDZVhSbFEyOTFiblFnS3lBek8xeHVYRzVjZEZ4MFhIUmNkSDBnWld4elpTQnBaaUFvZEdocGN5NWtZWFJoVzJWMlpXNTBVM1JoY25SSmJtUmxlRjBnUEQwZ01IZzVaaWtnZTF4dVhIUmNkRngwWEhSY2RDOHZJRTV2ZEdVZ2IyNWNibHgwWEhSY2RGeDBYSFJsZG1WdWRFcHpiMjR1Ym1GdFpTQTlJQ2RPYjNSbElHOXVKenRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dVkyaGhibTVsYkNBOUlIUm9hWE11YkdGemRGTjBZWFIxY3lBdElEQjRPVEFnS3lBeE8xeHVYSFJjZEZ4MFhIUmNkR1YyWlc1MFNuTnZiaTV1YjNSbFRuVnRZbVZ5SUQwZ2RHaHBjeTVrWVhSaFcyVjJaVzUwVTNSaGNuUkpibVJsZUNBcklERmRPMXh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1dWIzUmxUbUZ0WlNBOUlFTnZibk4wWVc1MGN5NU9UMVJGVTF0MGFHbHpMbVJoZEdGYlpYWmxiblJUZEdGeWRFbHVaR1Y0SUNzZ01WMWRPMXh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1MlpXeHZZMmwwZVNBOUlFMWhkR2d1Y205MWJtUW9kR2hwY3k1a1lYUmhXMlYyWlc1MFUzUmhjblJKYm1SbGVDQXJJREpkSUM4Z01USTNJQ29nTVRBd0tUdGNibHgwWEhSY2RGeDBYSFIwYUdsekxuQnZhVzUwWlhJZ0t6MGdaR1ZzZEdGQ2VYUmxRMjkxYm5RZ0t5QXpPMXh1WEc1Y2RGeDBYSFJjZEgwZ1pXeHpaU0JwWmlBb2RHaHBjeTVrWVhSaFcyVjJaVzUwVTNSaGNuUkpibVJsZUYwZ1BEMGdNSGhoWmlrZ2UxeHVYSFJjZEZ4MFhIUmNkQzh2SUZCdmJIbHdhRzl1YVdNZ1MyVjVJRkJ5WlhOemRYSmxYRzVjZEZ4MFhIUmNkRngwWlhabGJuUktjMjl1TG01aGJXVWdQU0FuVUc5c2VYQm9iMjVwWXlCTFpYa2dVSEpsYzNOMWNtVW5PMXh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1amFHRnVibVZzSUQwZ2RHaHBjeTVzWVhOMFUzUmhkSFZ6SUMwZ01IaGhNQ0FySURFN1hHNWNkRngwWEhSY2RGeDBaWFpsYm5SS2MyOXVMbTV2ZEdVZ1BTQkRiMjV6ZEdGdWRITXVUazlVUlZOYmRHaHBjeTVrWVhSaFcyVjJaVzUwVTNSaGNuUkpibVJsZUNBcklERmRYVHRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dWNISmxjM04xY21VZ1BTQmxkbVZ1ZEZzeVhUdGNibHgwWEhSY2RGeDBYSFIwYUdsekxuQnZhVzUwWlhJZ0t6MGdaR1ZzZEdGQ2VYUmxRMjkxYm5RZ0t5QXpPMXh1WEc1Y2RGeDBYSFJjZEgwZ1pXeHpaU0JwWmlBb2RHaHBjeTVrWVhSaFcyVjJaVzUwVTNSaGNuUkpibVJsZUYwZ1BEMGdNSGhpWmlrZ2UxeHVYSFJjZEZ4MFhIUmNkQzh2SUVOdmJuUnliMnhzWlhJZ1EyaGhibWRsWEc1Y2RGeDBYSFJjZEZ4MFpYWmxiblJLYzI5dUxtNWhiV1VnUFNBblEyOXVkSEp2Ykd4bGNpQkRhR0Z1WjJVbk8xeHVYSFJjZEZ4MFhIUmNkR1YyWlc1MFNuTnZiaTVqYUdGdWJtVnNJRDBnZEdocGN5NXNZWE4wVTNSaGRIVnpJQzBnTUhoaU1DQXJJREU3WEc1Y2RGeDBYSFJjZEZ4MFpYWmxiblJLYzI5dUxtNTFiV0psY2lBOUlIUm9hWE11WkdGMFlWdGxkbVZ1ZEZOMFlYSjBTVzVrWlhnZ0t5QXhYVHRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dWRtRnNkV1VnUFNCMGFHbHpMbVJoZEdGYlpYWmxiblJUZEdGeWRFbHVaR1Y0SUNzZ01sMDdYRzVjZEZ4MFhIUmNkRngwZEdocGN5NXdiMmx1ZEdWeUlDczlJR1JsYkhSaFFubDBaVU52ZFc1MElDc2dNenRjYmx4dVhIUmNkRngwWEhSOUlHVnNjMlVnYVdZZ0tIUm9hWE11WkdGMFlWdGxkbVZ1ZEZOMFlYSjBTVzVrWlhoZElEdzlJREI0WTJZcElIdGNibHgwWEhSY2RGeDBYSFF2THlCUWNtOW5jbUZ0SUVOb1lXNW5aVnh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1dVlXMWxJRDBnSjFCeWIyZHlZVzBnUTJoaGJtZGxKenRjYmx4MFhIUmNkRngwWEhSbGRtVnVkRXB6YjI0dVkyaGhibTVsYkNBOUlIUm9hWE11YkdGemRGTjBZWFIxY3lBdElEQjRZekFnS3lBeE8xeHVYSFJjZEZ4MFhIUmNkR1YyWlc1MFNuTnZiaTUyWVd4MVpTQTlJSFJvYVhNdVpHRjBZVnRsZG1WdWRGTjBZWEowU1c1a1pYZ2dLeUF4WFR0Y2JseDBYSFJjZEZ4MFhIUjBhR2x6TG5CdmFXNTBaWElnS3owZ1pHVnNkR0ZDZVhSbFEyOTFiblFnS3lBeU8xeHVYRzVjZEZ4MFhIUmNkSDBnWld4elpTQnBaaUFvZEdocGN5NWtZWFJoVzJWMlpXNTBVM1JoY25SSmJtUmxlRjBnUEQwZ01IaGtaaWtnZTF4dVhIUmNkRngwWEhSY2RDOHZJRU5vWVc1dVpXd2dTMlY1SUZCeVpYTnpkWEpsWEc1Y2RGeDBYSFJjZEZ4MFpYWmxiblJLYzI5dUxtNWhiV1VnUFNBblEyaGhibTVsYkNCTFpYa2dVSEpsYzNOMWNtVW5PMXh1WEhSY2RGeDBYSFJjZEdWMlpXNTBTbk52Ymk1amFHRnVibVZzSUQwZ2RHaHBjeTVzWVhOMFUzUmhkSFZ6SUMwZ01IaGtNQ0FySURFN1hHNWNkRngwWEhSY2RGeDBkR2hwY3k1d2IybHVkR1Z5SUNzOUlHUmxiSFJoUW5sMFpVTnZkVzUwSUNzZ01qdGNibHh1WEhSY2RGeDBYSFI5SUdWc2MyVWdhV1lnS0hSb2FYTXVaR0YwWVZ0bGRtVnVkRk4wWVhKMFNXNWtaWGhkSUR3OUlEQjRaV1lwSUh0Y2JseDBYSFJjZEZ4MFhIUXZMeUJRYVhSamFDQkNaVzVrWEc1Y2RGeDBYSFJjZEZ4MFpYWmxiblJLYzI5dUxtNWhiV1VnUFNBblVHbDBZMmdnUW1WdVpDYzdYRzVjZEZ4MFhIUmNkRngwWlhabGJuUktjMjl1TG1Ob1lXNXVaV3dnUFNCMGFHbHpMbXhoYzNSVGRHRjBkWE1nTFNBd2VHVXdJQ3NnTVR0Y2JseDBYSFJjZEZ4MFhIUjBhR2x6TG5CdmFXNTBaWElnS3owZ1pHVnNkR0ZDZVhSbFEyOTFiblFnS3lBek8xeHVYRzVjZEZ4MFhIUmNkSDBnWld4elpTQjdYRzVjZEZ4MFhIUmNkRngwWlhabGJuUktjMjl1TG01aGJXVWdQU0FuVlc1cmJtOTNiaTRnSUZCdmFXNTBaWEk2SUNjZ0t5QjBhR2x6TG5CdmFXNTBaWEl1ZEc5VGRISnBibWNvS1NBcklDY2dKeUFnS3lCbGRtVnVkRk4wWVhKMFNXNWtaWGd1ZEc5VGRISnBibWNvS1NBcklDY2dKeUFySUhSb2FYTXVaR0YwWVM1c1pXNW5kR2c3WEc1Y2RGeDBYSFJjZEgxY2JseDBYSFJjZEgxY2JseDBYSFI5WEc1Y2JseDBYSFIwYUdsekxtUmxiSFJoSUNzOUlHVjJaVzUwU25OdmJpNWtaV3gwWVR0Y2JseDBYSFIwYUdsekxtVjJaVzUwY3k1d2RYTm9LR1YyWlc1MFNuTnZiaWs3WEc1Y2JseDBYSFJ5WlhSMWNtNGdaWFpsYm5SS2MyOXVPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUZKbGRIVnlibk1nZEhKMVpTQnBaaUJ3YjJsdWRHVnlJR2hoY3lCeVpXRmphR1ZrSUhSb1pTQmxibVFnYjJZZ2RHaGxJSFJ5WVdOckxseHVYSFFnS2lCQWNHRnlZVzBnZTJKdmIyeGxZVzU5WEc1Y2RDQXFMMXh1WEhSbGJtUlBabFJ5WVdOcktDa2dlMXh1WEhSY2RHbG1JQ2gwYUdsekxtUmhkR0ZiZEdocGN5NXdiMmx1ZEdWeUlDc2dNVjBnUFQwZ01IaG1aaUFtSmlCMGFHbHpMbVJoZEdGYmRHaHBjeTV3YjJsdWRHVnlJQ3NnTWwwZ1BUMGdNSGd5WmlBbUppQjBhR2x6TG1SaGRHRmJkR2hwY3k1d2IybHVkR1Z5SUNzZ00xMGdQVDBnTUhnd01Da2dlMXh1WEhSY2RGeDBjbVYwZFhKdUlIUnlkV1U3WEc1Y2RGeDBmVnh1WEc1Y2RGeDBjbVYwZFhKdUlHWmhiSE5sTzF4dVhIUjlYRzU5WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6TGxSeVlXTnJJRDBnVkhKaFkyczdJaXdpTHlvcVhHNGdLaUJEYjI1MFlXbHVjeUJ0YVhOaklITjBZWFJwWXlCMWRHbHNhWFI1SUcxbGRHaHZaSE11WEc0Z0tpOWNibU5zWVhOeklGVjBhV3h6SUh0Y2JseHVYSFF2S2lwY2JseDBJQ29nUTI5dWRtVnlkSE1nWVNCemFXNW5iR1VnWW5sMFpTQjBieUJoSUdobGVDQnpkSEpwYm1jdVhHNWNkQ0FxSUVCd1lYSmhiU0I3Ym5WdFltVnlmU0JpZVhSbFhHNWNkQ0FxSUVCeVpYUjFjbTRnZTNOMGNtbHVaMzFjYmx4MElDb3ZYRzVjZEhOMFlYUnBZeUJpZVhSbFZHOUlaWGdvWW5sMFpTa2dlMXh1WEhSY2RDOHZJRVZ1YzNWeVpTQm9aWGdnYzNSeWFXNW5JR0ZzZDJGNWN5Qm9ZWE1nZEhkdklHTm9ZWEp6WEc1Y2RGeDBjbVYwZFhKdUlDZ25NQ2NnS3lCaWVYUmxMblJ2VTNSeWFXNW5LREUyS1NrdWMyeHBZMlVvTFRJcE8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRU52Ym5abGNuUnpJR0Z1SUdGeWNtRjVJRzltSUdKNWRHVnpJSFJ2SUdFZ2FHVjRJSE4wY21sdVp5NWNibHgwSUNvZ1FIQmhjbUZ0SUh0aGNuSmhlWDBnWW5sMFpVRnljbUY1WEc1Y2RDQXFJRUJ5WlhSMWNtNGdlM04wY21sdVozMWNibHgwSUNvdlhHNWNkSE4wWVhScFl5QmllWFJsYzFSdlNHVjRLR0o1ZEdWQmNuSmhlU2tnZTF4dVhIUmNkSFpoY2lCb1pYZ2dQU0JiWFR0Y2JseDBYSFJpZVhSbFFYSnlZWGt1Wm05eVJXRmphQ2hpZVhSbElEMCtJR2hsZUM1d2RYTm9LRlYwYVd4ekxtSjVkR1ZVYjBobGVDaGllWFJsS1NrcE8xeHVYSFJjZEhKbGRIVnliaUJvWlhndWFtOXBiaWduSnlrN1hHNWNkSDFjYmx4dVhIUXZLaXBjYmx4MElDb2dRMjl1ZG1WeWRITWdZU0JvWlhnZ2MzUnlhVzVuSUhSdklHRWdiblZ0WW1WeUxseHVYSFFnS2lCQWNHRnlZVzBnZTNOMGNtbHVaMzBnYUdWNFUzUnlhVzVuWEc1Y2RDQXFJRUJ5WlhSMWNtNGdlMjUxYldKbGNuMWNibHgwSUNvdlhHNWNkSE4wWVhScFl5Qm9aWGhVYjA1MWJXSmxjaWhvWlhoVGRISnBibWNwSUh0Y2JseDBYSFJ5WlhSMWNtNGdjR0Z5YzJWSmJuUW9hR1Y0VTNSeWFXNW5MQ0F4TmlrN1hHNWNkSDFjYmx4dVhIUXZLaXBjYmx4MElDb2dRMjl1ZG1WeWRITWdZVzRnWVhKeVlYa2diMllnWW5sMFpYTWdkRzhnWVNCdWRXMWlaWEl1WEc1Y2RDQXFJRUJ3WVhKaGJTQjdZWEp5WVhsOUlHSjVkR1ZCY25KaGVWeHVYSFFnS2lCQWNtVjBkWEp1SUh0dWRXMWlaWEo5WEc1Y2RDQXFMMXh1WEhSemRHRjBhV01nWW5sMFpYTlViMDUxYldKbGNpaGllWFJsUVhKeVlYa3BJSHRjYmx4MFhIUnlaWFIxY200Z1ZYUnBiSE11YUdWNFZHOU9kVzFpWlhJb1ZYUnBiSE11WW5sMFpYTlViMGhsZUNoaWVYUmxRWEp5WVhrcEtUdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJEYjI1MlpYSjBjeUJoYmlCaGNuSmhlU0J2WmlCaWVYUmxjeUIwYnlCc1pYUjBaWEp6TGx4dVhIUWdLaUJBY0dGeVlXMGdlMkZ5Y21GNWZTQmllWFJsUVhKeVlYbGNibHgwSUNvZ1FISmxkSFZ5YmlCN2MzUnlhVzVuZlZ4dVhIUWdLaTljYmx4MGMzUmhkR2xqSUdKNWRHVnpWRzlNWlhSMFpYSnpLR0o1ZEdWQmNuSmhlU2tnZTF4dVhIUmNkSFpoY2lCc1pYUjBaWEp6SUQwZ1cxMDdYRzVjZEZ4MFlubDBaVUZ5Y21GNUxtWnZja1ZoWTJnb1lubDBaU0E5UGlCc1pYUjBaWEp6TG5CMWMyZ29VM1J5YVc1bkxtWnliMjFEYUdGeVEyOWtaU2hpZVhSbEtTa3BPMXh1WEhSY2RISmxkSFZ5YmlCc1pYUjBaWEp6TG1wdmFXNG9KeWNwTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFTnZiblpsY25SeklHRWdaR1ZqYVcxaGJDQjBieUJwZENkeklHSnBibUZ5ZVNCeVpYQnlaWE5sYm5SaGRHbHZiaTVjYmx4MElDb2dRSEJoY21GdElIdHVkVzFpWlhKOUlHUmxZMXh1WEhRZ0tpQkFjbVYwZFhKdUlIdHpkSEpwYm1kOVhHNWNkQ0FxTDF4dVhIUnpkR0YwYVdNZ1pHVmpWRzlDYVc1aGNua29aR1ZqS1NCN1hHNGdJQ0FnWEhSeVpYUjFjbTRnS0dSbFl5QStQajRnTUNrdWRHOVRkSEpwYm1jb01pazdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nVW1WaFpITWdZU0IyWVhKcFlXSnNaU0JzWlc1bmRHZ2dkbUZzZFdVdVhHNWNkQ0FxSUVCd1lYSmhiU0I3WVhKeVlYbDlJR0o1ZEdWQmNuSmhlVnh1WEhRZ0tpQkFjbVYwZFhKdUlIdHVkVzFpWlhKOVhHNWNkQ0FxTDF4dVhIUnpkR0YwYVdNZ2NtVmhaRlpoY2tsdWRDaGllWFJsUVhKeVlYa3BJSHRjYmx4MFhIUjJZWElnY21WemRXeDBJRDBnTUR0Y2JseDBYSFJpZVhSbFFYSnlZWGt1Wm05eVJXRmphQ2h1ZFcxaVpYSWdQVDRnZTF4dVhIUmNkRngwZG1GeUlHSWdQU0J1ZFcxaVpYSTdYRzVjZEZ4MFhIUnBaaUFvWWlBbUlEQjRPREFwSUh0Y2JseDBYSFJjZEZ4MGNtVnpkV3gwSUNzOUlDaGlJQ1lnTUhnM1ppazdYRzVjZEZ4MFhIUmNkSEpsYzNWc2RDQThQRDBnTnp0Y2JseDBYSFJjZEgwZ1pXeHpaU0I3WEc1Y2RGeDBYSFJjZEM4cUlHSWdhWE1nZEdobElHeGhjM1FnWW5sMFpTQXFMMXh1WEhSY2RGeDBYSFJ5WlhOMWJIUWdLejBnWWp0Y2JseDBYSFJjZEgxY2JseDBYSFI5S1R0Y2JseHVYSFJjZEhKbGRIVnliaUJ5WlhOMWJIUTdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nUkdWamIyUmxjeUJpWVhObExUWTBJR1Z1WTI5a1pXUWdjM1J5YVc1blhHNWNkQ0FxSUVCd1lYSmhiU0I3YzNSeWFXNW5mU0J6ZEhKcGJtZGNibHgwSUNvZ1FISmxkSFZ5YmlCN2MzUnlhVzVuZlZ4dVhIUWdLaTljYmx4MGMzUmhkR2xqSUdGMGIySW9jM1J5YVc1bktTQjdYRzVjZEZ4MGFXWWdLSFI1Y0dWdlppQmhkRzlpSUQwOVBTQW5ablZ1WTNScGIyNG5LU0J5WlhSMWNtNGdZWFJ2WWloemRISnBibWNwTzF4dVhIUmNkSEpsZEhWeWJpQnVaWGNnUW5WbVptVnlLSE4wY21sdVp5d2dKMkpoYzJVMk5DY3BMblJ2VTNSeWFXNW5LQ2RpYVc1aGNua25LVHRjYmx4MGZWeHVmVnh1WEc1bGVIQnZjblJ6TGxWMGFXeHpJRDBnVlhScGJITTdJbDE5XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b25hbE1pZGkgPSByZXF1aXJlKCd0b25hbC1taWRpJyk7XG5cbi8qKlxuICogTUlESSBmaWxlIGZvcm1hdCBjb25zdGFudHMuXG4gKiBAcmV0dXJuIHtDb25zdGFudHN9XG4gKi9cbnZhciBDb25zdGFudHMgPSB7XG4gIFZFUlNJT046IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG4gIEhFQURFUl9DSFVOS19UWVBFOiBbMHg0ZCwgMHg1NCwgMHg2OCwgMHg2NF0sXG4gIC8vIE10aGRcbiAgSEVBREVSX0NIVU5LX0xFTkdUSDogWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDZdLFxuICAvLyBIZWFkZXIgc2l6ZSBmb3IgU01GXG4gIEhFQURFUl9DSFVOS19GT1JNQVQwOiBbMHgwMCwgMHgwMF0sXG4gIC8vIE1pZGkgVHlwZSAwIGlkXG4gIEhFQURFUl9DSFVOS19GT1JNQVQxOiBbMHgwMCwgMHgwMV0sXG4gIC8vIE1pZGkgVHlwZSAxIGlkXG4gIEhFQURFUl9DSFVOS19ESVZJU0lPTjogWzB4MDAsIDB4ODBdLFxuICAvLyBEZWZhdWx0cyB0byAxMjggdGlja3MgcGVyIGJlYXRcbiAgVFJBQ0tfQ0hVTktfVFlQRTogWzB4NGQsIDB4NTQsIDB4NzIsIDB4NmJdLFxuICAvLyBNVHJrLFxuICBNRVRBX0VWRU5UX0lEOiAweEZGLFxuICBNRVRBX1RFWFRfSUQ6IDB4MDEsXG4gIE1FVEFfQ09QWVJJR0hUX0lEOiAweDAyLFxuICBNRVRBX1RSQUNLX05BTUVfSUQ6IDB4MDMsXG4gIE1FVEFfSU5TVFJVTUVOVF9OQU1FX0lEOiAweDA0LFxuICBNRVRBX0xZUklDX0lEOiAweDA1LFxuICBNRVRBX01BUktFUl9JRDogMHgwNixcbiAgTUVUQV9DVUVfUE9JTlQ6IDB4MDcsXG4gIE1FVEFfVEVNUE9fSUQ6IDB4NTEsXG4gIE1FVEFfU01UUEVfT0ZGU0VUOiAweDU0LFxuICBNRVRBX1RJTUVfU0lHTkFUVVJFX0lEOiAweDU4LFxuICBNRVRBX0tFWV9TSUdOQVRVUkVfSUQ6IDB4NTksXG4gIE1FVEFfRU5EX09GX1RSQUNLX0lEOiBbMHgyRiwgMHgwMF0sXG4gIENPTlRST0xMRVJfQ0hBTkdFX1NUQVRVUzogMHhCMCxcbiAgLy8gaW5jbHVkZXMgY2hhbm5lbCBudW1iZXIgKDApXG4gIFBST0dSQU1fQ0hBTkdFX1NUQVRVUzogMHhDMCAvLyBpbmNsdWRlcyBjaGFubmVsIG51bWJlciAoMClcblxufTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbi8qKlxuICogSG9sZHMgYWxsIGRhdGEgZm9yIGEgXCJjb250cm9sbGVyIGNoYW5nZVwiIE1JREkgZXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZHMge2NvbnRyb2xsZXJOdW1iZXI6IGludGVnZXIsIGNvbnRyb2xsZXJWYWx1ZTogaW50ZWdlcn1cbiAqIEByZXR1cm4ge0NvbnRyb2xsZXJDaGFuZ2VFdmVudH1cbiAqL1xuXG52YXIgQ29udHJvbGxlckNoYW5nZUV2ZW50ID0gZnVuY3Rpb24gQ29udHJvbGxlckNoYW5nZUV2ZW50KGZpZWxkcykge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udHJvbGxlckNoYW5nZUV2ZW50KTtcblxuICB0aGlzLnR5cGUgPSAnY29udHJvbGxlcic7IC8vIGRlbHRhIHRpbWUgZGVmYXVsdHMgdG8gMC5cblxuICB0aGlzLmRhdGEgPSBVdGlscy5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKDB4MDApLmNvbmNhdChDb25zdGFudHMuQ09OVFJPTExFUl9DSEFOR0VfU1RBVFVTLCBmaWVsZHMuY29udHJvbGxlck51bWJlciwgZmllbGRzLmNvbnRyb2xsZXJWYWx1ZSk7XG59O1xuXG4vKipcbiAqIFN0YXRpYyB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIHRocm91Z2hvdXQgdGhlIGxpYnJhcnkuXG4gKi9cblxudmFyIFV0aWxzJDEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVdGlscygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXRpbHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFV0aWxzLCBudWxsLCBbe1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIE1pZGlXcml0ZXJKUyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gICAgICByZXR1cm4gQ29uc3RhbnRzLlZFUlNJT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgYnl0ZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdHJpbmdUb0J5dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXIuY2hhckNvZGVBdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhcmd1bWVudCBpcyBhIHZhbGlkIG51bWJlci5cbiAgICAgKiBAcGFyYW0geyp9IG4gLSBWYWx1ZSB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc051bWVyaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdGhlIGNvcnJlY3QgTUlESSBudW1iZXIgZm9yIHRoZSBzcGVjaWZpZWQgcGl0Y2guXG4gICAgICAgICogVXNlcyBUb25hbCBNaWRpIC0gaHR0cHM6Ly9naXRodWIuY29tL2RhbmlnYi90b25hbC90cmVlL21hc3Rlci9wYWNrYWdlcy9taWRpXG4gICAgICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IHBpdGNoIC0gJ0MjNCcgb3IgbWlkaSBub3RlIGNvZGVcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaXRjaChwaXRjaCkge1xuICAgICAgcmV0dXJuIHRvbmFsTWlkaS50b01pZGkocGl0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG51bWJlciBvZiB0aWNrcyB0byBNSURJIHRpbWVzdGFtcCBmb3JtYXQsIHJldHVybmluZyBhbiBhcnJheSBvZlxuICAgICAqIGhleCBzdHJpbmdzIHdpdGggdGhlIHRpbWUgdmFsdWVzLiBNaWRpIGhhcyBhIHZlcnkgcGFydGljdWxhciB0aW1lIHRvIGV4cHJlc3MgdGltZSxcbiAgICAgKiB0YWtlIGEgZ29vZCBsb29rIGF0IHRoZSBzcGVjIGJlZm9yZSBldmVyIHRvdWNoaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICogVGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXJnaS9qc21pZGlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrcyAtIE51bWJlciBvZiB0aWNrcyB0byBiZSB0cmFuc2xhdGVkXG4gICAgICogQHJldHVybiB7YXJyYXl9IC0gQnl0ZXMgdGhhdCBmb3JtIHRoZSBNSURJIHRpbWUgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm51bWJlclRvVmFyaWFibGVMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbnVtYmVyVG9WYXJpYWJsZUxlbmd0aCh0aWNrcykge1xuICAgICAgdmFyIGJ1ZmZlciA9IHRpY2tzICYgMHg3RjtcblxuICAgICAgd2hpbGUgKHRpY2tzID0gdGlja3MgPj4gNykge1xuICAgICAgICBidWZmZXIgPDw9IDg7XG4gICAgICAgIGJ1ZmZlciB8PSB0aWNrcyAmIDB4N0YgfCAweDgwO1xuICAgICAgfVxuXG4gICAgICB2YXIgYkxpc3QgPSBbXTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgYkxpc3QucHVzaChidWZmZXIgJiAweGZmKTtcbiAgICAgICAgaWYgKGJ1ZmZlciAmIDB4ODApIGJ1ZmZlciA+Pj0gODtlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYkxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50cyBudW1iZXIgb2YgYnl0ZXMgaW4gc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0cmluZ0J5dGVDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJpbmdCeXRlQ291bnQocykge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSShzKS5zcGxpdCgvJS4ufC4vKS5sZW5ndGggLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gaW50IGZyb20gYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAgICogQHBhcmFtIHthcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJudW1iZXJGcm9tQnl0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbnVtYmVyRnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICB2YXIgaGV4ID0gJyc7XG4gICAgICB2YXIgc3RyaW5nUmVzdWx0O1xuICAgICAgYnl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYnl0ZSkge1xuICAgICAgICBzdHJpbmdSZXN1bHQgPSBieXRlLnRvU3RyaW5nKDE2KTsgLy8gZW5zdXJlIHN0cmluZyBpcyAyIGNoYXJzXG5cbiAgICAgICAgaWYgKHN0cmluZ1Jlc3VsdC5sZW5ndGggPT0gMSkgc3RyaW5nUmVzdWx0ID0gXCIwXCIgKyBzdHJpbmdSZXN1bHQ7XG4gICAgICAgIGhleCArPSBzdHJpbmdSZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJzZUludChoZXgsIDE2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBudW1iZXIgYW5kIHNwbGl0cyBpdCB1cCBpbnRvIGFuIGFycmF5IG9mIGJ5dGVzLiAgQ2FuIGJlIHBhZGRlZCBieSBwYXNzaW5nIGEgbnVtYmVyIHRvIGJ5dGVzTmVlZGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc05lZWRlZFxuICAgICAqIEByZXR1cm4ge2FycmF5fSAtIEFycmF5IG9mIGJ5dGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJudW1iZXJUb0J5dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXMobnVtYmVyLCBieXRlc05lZWRlZCkge1xuICAgICAgYnl0ZXNOZWVkZWQgPSBieXRlc05lZWRlZCB8fCAxO1xuICAgICAgdmFyIGhleFN0cmluZyA9IG51bWJlci50b1N0cmluZygxNik7XG5cbiAgICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICYgMSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgaGV4IHN0cmluZyBpcyBldmVuIG51bWJlciBvZiBjaGFyc1xuICAgICAgICBoZXhTdHJpbmcgPSAnMCcgKyBoZXhTdHJpbmc7XG4gICAgICB9IC8vIFNwbGl0IGhleCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0d28gY2hhciBlbGVtZW50c1xuXG5cbiAgICAgIHZhciBoZXhBcnJheSA9IGhleFN0cmluZy5tYXRjaCgvLnsyfS9nKTsgLy8gTm93IHBhcnNlIHRoZW0gb3V0IGFzIGludGVnZXJzXG5cbiAgICAgIGhleEFycmF5ID0gaGV4QXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChpdGVtLCAxNik7XG4gICAgICB9KTsgLy8gUHJlcGVuZCBlbXB0eSBieXRlcyBpZiB3ZSBkb24ndCBoYXZlIGVub3VnaFxuXG4gICAgICBpZiAoaGV4QXJyYXkubGVuZ3RoIDwgYnl0ZXNOZWVkZWQpIHtcbiAgICAgICAgd2hpbGUgKGJ5dGVzTmVlZGVkIC0gaGV4QXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGhleEFycmF5LnVuc2hpZnQoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhleEFycmF5O1xuICAgIH1cbiAgICAvKipcdFxuICAgICAqIENvbnZlcnRzIHZhbHVlIHRvIGFycmF5IGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdmVsb2NpdHkgdG8gdmFsdWUgMC0xMjdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmVsb2NpdHkgLSBWZWxvY2l0eSB2YWx1ZSAxLTEwMFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnZlcnRWZWxvY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0VmVsb2NpdHkodmVsb2NpdHkpIHtcbiAgICAgIC8vIE1heCBwYXNzZWQgdmFsdWUgbGltaXRlZCB0byAxMDBcbiAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHkgPiAxMDAgPyAxMDAgOiB2ZWxvY2l0eTtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZlbG9jaXR5IC8gMTAwICogMTI3KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGlja0R1cmF0aW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgdGlja3Mgb2YgYSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gICAgICogTm90ZTogdHlwZT09J25vdGUnIGRlZmF1bHRzIHRvIHF1YXJ0ZXIgbm90ZSwgdHlwZT09PSdyZXN0JyBkZWZhdWx0cyB0byAwXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGFycmF5KX0gZHVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpY2tEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZHVyYXRpb24pKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGV4ZWN1dGUgdGhpcyBtZXRob2QgZm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkgYW5kIHJldHVybiB0aGUgc3VtIG9mIHRpY2sgZHVyYXRpb25zLlxuICAgICAgICByZXR1cm4gZHVyYXRpb24ubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBVdGlscy5nZXRUaWNrRHVyYXRpb24odmFsdWUpO1xuICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuXG4gICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmIChkdXJhdGlvbi50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3QnKSB7XG4gICAgICAgIC8vIElmIGR1cmF0aW9uIHN0YXJ0cyB3aXRoICd0JyB0aGVuIHRoZSBudW1iZXIgdGhhdCBmb2xsb3dzIGlzIGFuIGV4cGxpY2l0IHRpY2sgY291bnRcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGR1cmF0aW9uLnN1YnN0cmluZygxKSk7XG4gICAgICB9IC8vIE5lZWQgdG8gYXBwbHkgZHVyYXRpb24gaGVyZS4gIFF1YXJ0ZXIgbm90ZSA9PSBDb25zdGFudHMuSEVBREVSX0NIVU5LX0RJVklTSU9OXG4gICAgICAvLyBSb3VuZGluZyBvbmx5IGFwcGxpZXMgdG8gdHJpcGxldHMsIHdoaWNoIHRoZSByZW1haW5kZXIgaXMgaGFuZGxlZCBiZWxvd1xuXG5cbiAgICAgIHZhciBxdWFydGVyVGlja3MgPSBVdGlscy5udW1iZXJGcm9tQnl0ZXMoQ29uc3RhbnRzLkhFQURFUl9DSFVOS19ESVZJU0lPTik7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChxdWFydGVyVGlja3MgKiBVdGlscy5nZXREdXJhdGlvbk11bHRpcGxpZXIoZHVyYXRpb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGF0IHRvIG11bHRpcGxlIHRpY2tzL3F1YXJ0ZXIgbm90ZSBieSB0byBnZXQgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAgICAgKiBOb3RlOiB0eXBlPT0nbm90ZScgZGVmYXVsdHMgdG8gcXVhcnRlciBub3RlLCB0eXBlPT09J3Jlc3QnIGRlZmF1bHRzIHRvIDBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZHVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREdXJhdGlvbk11bHRpcGxpZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHVyYXRpb25NdWx0aXBsaWVyKGR1cmF0aW9uKSB7XG4gICAgICAvLyBOZWVkIHRvIGFwcGx5IGR1cmF0aW9uIGhlcmUuICBRdWFydGVyIG5vdGUgPT0gQ29uc3RhbnRzLkhFQURFUl9DSFVOS19ESVZJU0lPTlxuICAgICAgc3dpdGNoIChkdXJhdGlvbikge1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICByZXR1cm4gNDtcblxuICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICByZXR1cm4gMjtcblxuICAgICAgICBjYXNlICdkMic6XG4gICAgICAgICAgcmV0dXJuIDM7XG5cbiAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgcmV0dXJuIDE7XG5cbiAgICAgICAgY2FzZSAnNHQnOlxuICAgICAgICAgIHJldHVybiAwLjY2NjtcblxuICAgICAgICBjYXNlICdkNCc6XG4gICAgICAgICAgcmV0dXJuIDEuNTtcblxuICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICByZXR1cm4gMC41O1xuXG4gICAgICAgIGNhc2UgJzh0JzpcbiAgICAgICAgICAvLyBGb3IgOHRoIHRyaXBsZXRzLCBsZXQncyBkaXZpZGUgYSBxdWFydGVyIGJ5IDMsIHJvdW5kIHRvIHRoZSBuZWFyZXN0IGludCwgYW5kIHN1YnN0cmFjdCB0aGUgcmVtYWluZGVyIHRvIHRoZSBsYXN0IG9uZS5cbiAgICAgICAgICByZXR1cm4gMC4zMztcblxuICAgICAgICBjYXNlICdkOCc6XG4gICAgICAgICAgcmV0dXJuIDAuNzU7XG5cbiAgICAgICAgY2FzZSAnMTYnOlxuICAgICAgICAgIHJldHVybiAwLjI1O1xuXG4gICAgICAgIGNhc2UgJzE2dCc6XG4gICAgICAgICAgcmV0dXJuIDAuMTY2O1xuXG4gICAgICAgIGNhc2UgJzMyJzpcbiAgICAgICAgICByZXR1cm4gMC4xMjU7XG5cbiAgICAgICAgY2FzZSAnNjQnOlxuICAgICAgICAgIHJldHVybiAwLjA2MjU7XG5cbiAgICAgICAgZGVmYXVsdDogLy8gTm90ZXMgZGVmYXVsdCB0byBhIHF1YXJ0ZXIsIHJlc3RzIGRlZmF1bHQgdG8gMFxuICAgICAgICAvL3JldHVybiB0eXBlID09PSAnbm90ZScgPyAxIDogMDtcblxuICAgICAgfVxuXG4gICAgICB0aHJvdyBkdXJhdGlvbiArICcgaXMgbm90IGEgdmFsaWQgZHVyYXRpb24uJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVXRpbHM7XG59KCk7XG5cbi8qKlxuICogSG9sZHMgYWxsIGRhdGEgZm9yIGEgXCJub3RlIG9uXCIgTUlESSBldmVudFxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkcyB7ZGF0YTogW119XG4gKiBAcmV0dXJuIHtOb3RlT25FdmVudH1cbiAqL1xuXG52YXIgTm90ZU9uRXZlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb3RlT25FdmVudChmaWVsZHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm90ZU9uRXZlbnQpO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgZmllbGRzXG4gICAgZmllbGRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjaGFubmVsOiAxLFxuICAgICAgc3RhcnRUaWNrOiBudWxsLFxuICAgICAgdmVsb2NpdHk6IDUwLFxuICAgICAgd2FpdDogMFxuICAgIH0sIGZpZWxkcyk7XG4gICAgdGhpcy50eXBlID0gJ25vdGUtb24nO1xuICAgIHRoaXMuY2hhbm5lbCA9IGZpZWxkcy5jaGFubmVsO1xuICAgIHRoaXMucGl0Y2ggPSBmaWVsZHMucGl0Y2g7XG4gICAgdGhpcy53YWl0ID0gZmllbGRzLndhaXQ7XG4gICAgdGhpcy52ZWxvY2l0eSA9IGZpZWxkcy52ZWxvY2l0eTtcbiAgICB0aGlzLnN0YXJ0VGljayA9IGZpZWxkcy5zdGFydFRpY2s7XG4gICAgdGhpcy5taWRpTnVtYmVyID0gVXRpbHMkMS5nZXRQaXRjaCh0aGlzLnBpdGNoKTtcbiAgICB0aGlzLnRpY2sgPSBudWxsO1xuICAgIHRoaXMuZGVsdGEgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IGZpZWxkcy5kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBCdWlsZHMgaW50IGFycmF5IGZvciB0aGlzIGV2ZW50LlxuICAgKiBAcGFyYW0ge1RyYWNrfSB0cmFjayAtIHBhcmVudCB0cmFja1xuICAgKiBAcmV0dXJuIHtOb3RlT25FdmVudH1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTm90ZU9uRXZlbnQsIFt7XG4gICAga2V5OiBcImJ1aWxkRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZERhdGEodHJhY2spIHtcbiAgICAgIHRoaXMuZGF0YSA9IFtdOyAvLyBFeHBsaWNpdGx5IGRlZmluZWQgc3RhcnRUaWNrIGV2ZW50XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0VGljaykge1xuICAgICAgICB0aGlzLnRpY2sgPSB0aGlzLnN0YXJ0VGljazsgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgZXZlbnQgaW4gdGhlIHRyYWNrIHRoZW4gdXNlIGV2ZW50J3Mgc3RhcnRpbmcgdGljayBhcyBkZWx0YS5cblxuICAgICAgICBpZiAodHJhY2sudGlja1BvaW50ZXIgPT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVsdGEgPSB0aGlzLnRpY2s7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVsdGEgPSBVdGlscyQxLmdldFRpY2tEdXJhdGlvbih0aGlzLndhaXQpO1xuICAgICAgICB0aGlzLnRpY2sgPSB0cmFjay50aWNrUG9pbnRlciArIHRoaXMuZGVsdGE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YSA9IFV0aWxzJDEubnVtYmVyVG9WYXJpYWJsZUxlbmd0aCh0aGlzLmRlbHRhKS5jb25jYXQodGhpcy5nZXRTdGF0dXNCeXRlKCksIHRoaXMubWlkaU51bWJlciwgVXRpbHMkMS5jb252ZXJ0VmVsb2NpdHkodGhpcy52ZWxvY2l0eSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5vdGUgb24gc3RhdHVzIGNvZGUgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGNoYW5uZWwuIDB4OXswLUZ9XG4gICAgICogTm90ZSBvbiBhdCBjaGFubmVsIDAgaXMgMHg5MCAoMTQ0KVxuICAgICAqIDAgPSBDaCAxXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RhdHVzQnl0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0dXNCeXRlKCkge1xuICAgICAgcmV0dXJuIDE0NCArIHRoaXMuY2hhbm5lbCAtIDE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vdGVPbkV2ZW50O1xufSgpO1xuXG4vKipcbiAqIEhvbGRzIGFsbCBkYXRhIGZvciBhIFwibm90ZSBvZmZcIiBNSURJIGV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGRzIHtkYXRhOiBbXX1cbiAqIEByZXR1cm4ge05vdGVPZmZFdmVudH1cbiAqL1xuXG52YXIgTm90ZU9mZkV2ZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm90ZU9mZkV2ZW50KGZpZWxkcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb3RlT2ZmRXZlbnQpO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgZmllbGRzXG4gICAgZmllbGRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjaGFubmVsOiAxLFxuICAgICAgbm90ZU9uVGljazogbnVsbCxcbiAgICAgIHZlbG9jaXR5OiA1MFxuICAgIH0sIGZpZWxkcyk7XG4gICAgdGhpcy50eXBlID0gJ25vdGUtb2ZmJztcbiAgICB0aGlzLmNoYW5uZWwgPSBmaWVsZHMuY2hhbm5lbDtcbiAgICB0aGlzLnBpdGNoID0gZmllbGRzLnBpdGNoO1xuICAgIHRoaXMuZHVyYXRpb24gPSBmaWVsZHMuZHVyYXRpb247XG4gICAgdGhpcy52ZWxvY2l0eSA9IGZpZWxkcy52ZWxvY2l0eTtcbiAgICB0aGlzLm5vdGVPblRpY2sgPSBmaWVsZHMubm90ZU9uVGljaztcbiAgICB0aGlzLm1pZGlOdW1iZXIgPSBVdGlscyQxLmdldFBpdGNoKHRoaXMucGl0Y2gpO1xuICAgIHRoaXMudGljayA9IG51bGw7XG4gICAgdGhpcy5kZWx0YSA9IFV0aWxzJDEuZ2V0VGlja0R1cmF0aW9uKHRoaXMuZHVyYXRpb24pO1xuICAgIHRoaXMuZGF0YSA9IGZpZWxkcy5kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBCdWlsZHMgaW50IGFycmF5IGZvciB0aGlzIGV2ZW50LlxuICAgKiBAcGFyYW0ge1RyYWNrfSB0cmFjayAtIHBhcmVudCB0cmFja1xuICAgKiBAcmV0dXJuIHtOb3RlT2ZmRXZlbnR9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5vdGVPZmZFdmVudCwgW3tcbiAgICBrZXk6IFwiYnVpbGREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkRGF0YSh0cmFjaykge1xuICAgICAgaWYgKHRoaXMubm90ZU9uVGljaykge1xuICAgICAgICB0aGlzLnRpY2sgPSB0aGlzLm5vdGVPblRpY2sgKyBVdGlscyQxLmdldFRpY2tEdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGljayA9IHRoaXMuZGVsdGEgKyB0cmFjay50aWNrUG9pbnRlcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhID0gVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHRoaXMuZGVsdGEpLmNvbmNhdCh0aGlzLmdldFN0YXR1c0J5dGUoKSwgdGhpcy5taWRpTnVtYmVyLCBVdGlscyQxLmNvbnZlcnRWZWxvY2l0eSh0aGlzLnZlbG9jaXR5KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbm90ZSBvZmYgc3RhdHVzIGNvZGUgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGNoYW5uZWwuIDB4OHswLUZ9XG4gICAgICogTm90ZSBvZmYgYXQgY2hhbm5lbCAwIGlzIDB4ODAgKDEyOClcbiAgICAgKiAwID0gQ2ggMVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXR1c0J5dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdHVzQnl0ZSgpIHtcbiAgICAgIHJldHVybiAxMjggKyB0aGlzLmNoYW5uZWwgLSAxO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb3RlT2ZmRXZlbnQ7XG59KCk7XG5cbi8qKlxuICogV3JhcHBlciBmb3Igbm90ZU9uRXZlbnQvbm90ZU9mZkV2ZW50IG9iamVjdHMgdGhhdCBidWlsZHMgYm90aCBldmVudHMuXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGRzIC0ge3BpdGNoOiAnW0M0XScsIGR1cmF0aW9uOiAnNCcsIHdhaXQ6ICc0JywgdmVsb2NpdHk6IDEtMTAwfVxuICogQHJldHVybiB7Tm90ZUV2ZW50fVxuICovXG5cbnZhciBOb3RlRXZlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb3RlRXZlbnQoZmllbGRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vdGVFdmVudCk7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCBmaWVsZHNcbiAgICBmaWVsZHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNoYW5uZWw6IDEsXG4gICAgICByZXBlYXQ6IDEsXG4gICAgICBzZXF1ZW50aWFsOiBmYWxzZSxcbiAgICAgIHN0YXJ0VGljazogbnVsbCxcbiAgICAgIHZlbG9jaXR5OiA1MCxcbiAgICAgIHdhaXQ6IDBcbiAgICB9LCBmaWVsZHMpO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMudHlwZSA9ICdub3RlJztcbiAgICB0aGlzLnBpdGNoID0gVXRpbHMkMS50b0FycmF5KGZpZWxkcy5waXRjaCk7XG4gICAgdGhpcy5jaGFubmVsID0gZmllbGRzLmNoYW5uZWw7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGZpZWxkcy5kdXJhdGlvbjtcbiAgICB0aGlzLmdyYWNlID0gZmllbGRzLmdyYWNlO1xuICAgIHRoaXMucmVwZWF0ID0gZmllbGRzLnJlcGVhdDtcbiAgICB0aGlzLnNlcXVlbnRpYWwgPSBmaWVsZHMuc2VxdWVudGlhbDtcbiAgICB0aGlzLnN0YXJ0VGljayA9IGZpZWxkcy5zdGFydFRpY2s7XG4gICAgdGhpcy52ZWxvY2l0eSA9IGZpZWxkcy52ZWxvY2l0eTtcbiAgICB0aGlzLndhaXQgPSBmaWVsZHMud2FpdDtcbiAgICB0aGlzLnRpY2tEdXJhdGlvbiA9IFV0aWxzJDEuZ2V0VGlja0R1cmF0aW9uKHRoaXMuZHVyYXRpb24pO1xuICAgIHRoaXMucmVzdER1cmF0aW9uID0gVXRpbHMkMS5nZXRUaWNrRHVyYXRpb24odGhpcy53YWl0KTtcbiAgICB0aGlzLmV2ZW50cyA9IFtdOyAvLyBIb2xkIGFjdHVhbCBOb3RlT24vTm90ZU9mZiBldmVudHNcbiAgfVxuICAvKipcbiAgICogQnVpbGRzIGludCBhcnJheSBmb3IgdGhpcyBldmVudC5cbiAgICogQHJldHVybiB7Tm90ZUV2ZW50fVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhOb3RlRXZlbnQsIFt7XG4gICAga2V5OiBcImJ1aWxkRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZERhdGEoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBSZXNldCBkYXRhIGFycmF5XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIHZhciB0aWNrRHVyYXRpb24gPSB0aGlzLnRpY2tEdXJhdGlvbjtcbiAgICAgIHZhciByZXN0RHVyYXRpb24gPSB0aGlzLnJlc3REdXJhdGlvbjsgLy8gQXBwbHkgZ3JhY2Ugbm90ZShzKSBhbmQgc3VidHJhY3QgdGlja3MgKGN1cnJlbnRseSAxIHRpY2sgcGVyIGdyYWNlIG5vdGUpIGZyb20gdGlja0R1cmF0aW9uIHNvIG5ldCB2YWx1ZSBpcyB0aGUgc2FtZVxuXG4gICAgICBpZiAodGhpcy5ncmFjZSkge1xuICAgICAgICB2YXIgZ3JhY2VEdXJhdGlvbiA9IDE7XG4gICAgICAgIHRoaXMuZ3JhY2UgPSBVdGlscyQxLnRvQXJyYXkodGhpcy5ncmFjZSk7XG4gICAgICAgIHRoaXMuZ3JhY2UuZm9yRWFjaChmdW5jdGlvbiAocGl0Y2gpIHtcbiAgICAgICAgICB2YXIgbm90ZUV2ZW50ID0gbmV3IE5vdGVFdmVudCh7XG4gICAgICAgICAgICBwaXRjaDogX3RoaXMuZ3JhY2UsXG4gICAgICAgICAgICBkdXJhdGlvbjogJ1QnICsgZ3JhY2VEdXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzLmRhdGEgPSBfdGhpcy5kYXRhLmNvbmNhdChub3RlRXZlbnQuZGF0YSk7XG4gICAgICAgICAgdGlja0R1cmF0aW9uIC09IGdyYWNlRHVyYXRpb247XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBmaWVsZHMucGl0Y2ggY291bGQgYmUgYW4gYXJyYXkgb2YgcGl0Y2hlcy5cbiAgICAgIC8vIElmIHRoaXMuc2VxdWVudGlhbCA9PT0gdHJ1ZSB0aGVuIGl0J3MgYSBzZXF1ZW50aWFsIHN0cmluZyBvZiBub3RlcyB0aGF0IHJlcXVpcmVzIHNlcGFyYXRlIE5vdGVPbkV2ZW50cy5cblxuICAgICAgaWYgKCF0aGlzLnNlcXVlbnRpYWwpIHtcbiAgICAgICAgLy8gSGFuZGxlIHJlcGVhdFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMucmVwZWF0OyBqKyspIHtcbiAgICAgICAgICAvLyBOb3RlIG9uXG4gICAgICAgICAgdGhpcy5waXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBub3RlT25OZXcgPSBuZXcgTm90ZU9uRXZlbnQoe1xuICAgICAgICAgICAgICAgIGNoYW5uZWw6IF90aGlzLmNoYW5uZWwsXG4gICAgICAgICAgICAgICAgd2FpdDogX3RoaXMud2FpdCxcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eTogX3RoaXMudmVsb2NpdHksXG4gICAgICAgICAgICAgICAgcGl0Y2g6IHAsXG4gICAgICAgICAgICAgICAgc3RhcnRUaWNrOiBfdGhpcy5zdGFydFRpY2tcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSdW5uaW5nIHN0YXR1cyAoY2FuIG9tbWl0IHRoZSBub3RlIG9uIHN0YXR1cylcbiAgICAgICAgICAgICAgLy9ub3RlT24gPSBuZXcgTm90ZU9uRXZlbnQoe2RhdGE6IFswLCBVdGlscy5nZXRQaXRjaChwKSwgVXRpbHMuY29udmVydFZlbG9jaXR5KHRoaXMudmVsb2NpdHkpXX0pO1xuICAgICAgICAgICAgICB2YXIgbm90ZU9uTmV3ID0gbmV3IE5vdGVPbkV2ZW50KHtcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBfdGhpcy5jaGFubmVsLFxuICAgICAgICAgICAgICAgIHdhaXQ6IDAsXG4gICAgICAgICAgICAgICAgdmVsb2NpdHk6IF90aGlzLnZlbG9jaXR5LFxuICAgICAgICAgICAgICAgIHBpdGNoOiBwLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGljazogX3RoaXMuc3RhcnRUaWNrXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5ldmVudHMucHVzaChub3RlT25OZXcpO1xuICAgICAgICAgIH0pOyAvLyBOb3RlIG9mZlxuXG4gICAgICAgICAgdGhpcy5waXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgIC8vbm90ZU9mZiA9IG5ldyBOb3RlT2ZmRXZlbnQoe2RhdGE6IFV0aWxzLm51bWJlclRvVmFyaWFibGVMZW5ndGgodGlja0R1cmF0aW9uKS5jb25jYXQodGhpcy5nZXROb3RlT2ZmU3RhdHVzKCksIFV0aWxzLmdldFBpdGNoKHApLCBVdGlscy5jb252ZXJ0VmVsb2NpdHkodGhpcy52ZWxvY2l0eSkpfSk7XG4gICAgICAgICAgICAgIHZhciBub3RlT2ZmTmV3ID0gbmV3IE5vdGVPZmZFdmVudCh7XG4gICAgICAgICAgICAgICAgY2hhbm5lbDogX3RoaXMuY2hhbm5lbCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogX3RoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdmVsb2NpdHk6IF90aGlzLnZlbG9jaXR5LFxuICAgICAgICAgICAgICAgIHBpdGNoOiBwLFxuICAgICAgICAgICAgICAgIG5vdGVPblRpY2s6IF90aGlzLnN0YXJ0VGlja1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJ1bm5pbmcgc3RhdHVzIChjYW4gb21taXQgdGhlIG5vdGUgb2ZmIHN0YXR1cylcbiAgICAgICAgICAgICAgLy9ub3RlT2ZmID0gbmV3IE5vdGVPZmZFdmVudCh7ZGF0YTogWzAsIFV0aWxzLmdldFBpdGNoKHApLCBVdGlscy5jb252ZXJ0VmVsb2NpdHkodGhpcy52ZWxvY2l0eSldfSk7XG4gICAgICAgICAgICAgIHZhciBub3RlT2ZmTmV3ID0gbmV3IE5vdGVPZmZFdmVudCh7XG4gICAgICAgICAgICAgICAgY2hhbm5lbDogX3RoaXMuY2hhbm5lbCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eTogX3RoaXMudmVsb2NpdHksXG4gICAgICAgICAgICAgICAgcGl0Y2g6IHAsXG4gICAgICAgICAgICAgICAgbm90ZU9uVGljazogX3RoaXMuc3RhcnRUaWNrXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5ldmVudHMucHVzaChub3RlT2ZmTmV3KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIHJlcGVhdFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMucmVwZWF0OyBqKyspIHtcbiAgICAgICAgICB0aGlzLnBpdGNoLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgIC8vIHJlc3REdXJhdGlvbiBvbmx5IGFwcGxpZXMgdG8gZmlyc3Qgbm90ZVxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9IC8vIElmIGR1cmF0aW9uIGlzIDh0aCB0cmlwbGV0cyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB0b3RhbCB0aWNrcyA9PSBxdWFydGVyIG5vdGUuXG4gICAgICAgICAgICAvLyBTbywgdGhlIGxhc3Qgb25lIHdpbGwgbmVlZCB0byBiZSB0aGUgcmVtYWluZGVyXG5cblxuICAgICAgICAgICAgaWYgKF90aGlzLmR1cmF0aW9uID09PSAnOHQnICYmIGkgPT0gX3RoaXMucGl0Y2gubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICB2YXIgcXVhcnRlclRpY2tzID0gVXRpbHMkMS5udW1iZXJGcm9tQnl0ZXMoQ29uc3RhbnRzLkhFQURFUl9DSFVOS19ESVZJU0lPTik7XG4gICAgICAgICAgICAgIHRpY2tEdXJhdGlvbiA9IHF1YXJ0ZXJUaWNrcyAtIHRpY2tEdXJhdGlvbiAqIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBub3RlT25OZXcgPSBuZXcgTm90ZU9uRXZlbnQoe1xuICAgICAgICAgICAgICBjaGFubmVsOiBfdGhpcy5jaGFubmVsLFxuICAgICAgICAgICAgICB3YWl0OiBpID4gMCA/IDAgOiBfdGhpcy53YWl0LFxuICAgICAgICAgICAgICAvLyB3YWl0IG9ubHkgYXBwbGllcyB0byBmaXJzdCBub3RlIGluIHJlcGV0aXRpb25cbiAgICAgICAgICAgICAgdmVsb2NpdHk6IF90aGlzLnZlbG9jaXR5LFxuICAgICAgICAgICAgICBwaXRjaDogcCxcbiAgICAgICAgICAgICAgc3RhcnRUaWNrOiBfdGhpcy5zdGFydFRpY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5vdGVPZmZOZXcgPSBuZXcgTm90ZU9mZkV2ZW50KHtcbiAgICAgICAgICAgICAgY2hhbm5lbDogX3RoaXMuY2hhbm5lbCxcbiAgICAgICAgICAgICAgZHVyYXRpb246IF90aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB2ZWxvY2l0eTogX3RoaXMudmVsb2NpdHksXG4gICAgICAgICAgICAgIHBpdGNoOiBwLFxuICAgICAgICAgICAgICBub3RlT25UaWNrOiBfdGhpcy5zdGFydFRpY2tcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfdGhpcy5ldmVudHMucHVzaChub3RlT25OZXcsIG5vdGVPZmZOZXcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb3RlRXZlbnQ7XG59KCk7XG5cbi8qKlxuICogSG9sZHMgYWxsIGRhdGEgZm9yIGEgXCJwcm9ncmFtIGNoYW5nZVwiIE1JREkgZXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZHMge2luc3RydW1lbnQ6IGludGVnZXJ9XG4gKiBAcmV0dXJuIHtQcm9ncmFtQ2hhbmdlRXZlbnR9XG4gKi9cblxudmFyIFByb2dyYW1DaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIFByb2dyYW1DaGFuZ2VFdmVudChmaWVsZHMpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb2dyYW1DaGFuZ2VFdmVudCk7XG5cbiAgdGhpcy50eXBlID0gJ3Byb2dyYW0nOyAvLyBkZWx0YSB0aW1lIGRlZmF1bHRzIHRvIDAuXG5cbiAgdGhpcy5kYXRhID0gVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKDB4MDApLmNvbmNhdChDb25zdGFudHMuUFJPR1JBTV9DSEFOR0VfU1RBVFVTLCBmaWVsZHMuaW5zdHJ1bWVudCk7XG59O1xuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHRlbXBvIG1ldGEgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIENvcHlyaWdodCB0ZXh0XG4gKiBAcmV0dXJuIHtDb3B5cmlnaHRFdmVudH1cbiAqL1xuXG52YXIgQ29weXJpZ2h0RXZlbnQgPSBmdW5jdGlvbiBDb3B5cmlnaHRFdmVudCh0ZXh0KSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3B5cmlnaHRFdmVudCk7XG5cbiAgdGhpcy50eXBlID0gJ2NvcHlyaWdodCc7XG4gIHZhciB0ZXh0Qnl0ZXMgPSBVdGlscyQxLnN0cmluZ1RvQnl0ZXModGV4dCk7IC8vIFN0YXJ0IHdpdGggemVybyB0aW1lIGRlbHRhXG5cbiAgdGhpcy5kYXRhID0gVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKDB4MDApLmNvbmNhdChDb25zdGFudHMuTUVUQV9FVkVOVF9JRCwgQ29uc3RhbnRzLk1FVEFfQ09QWVJJR0hUX0lELCBVdGlscyQxLm51bWJlclRvVmFyaWFibGVMZW5ndGgodGV4dEJ5dGVzLmxlbmd0aCksIC8vIFNpemVcbiAgdGV4dEJ5dGVzIC8vIFRleHRcbiAgKTtcbn07XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgY3VlIHBvaW50IG1ldGEgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIEN1ZSBwb2ludCB0ZXh0XG4gKiBAcmV0dXJuIHtDdWVQb2ludEV2ZW50fVxuICovXG5cbnZhciBDdWVQb2ludEV2ZW50ID0gZnVuY3Rpb24gQ3VlUG9pbnRFdmVudCh0ZXh0KSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdWVQb2ludEV2ZW50KTtcblxuICB0aGlzLnR5cGUgPSAnbWFya2VyJztcbiAgdmFyIHRleHRCeXRlcyA9IFV0aWxzJDEuc3RyaW5nVG9CeXRlcyh0ZXh0KTsgLy8gU3RhcnQgd2l0aCB6ZXJvIHRpbWUgZGVsdGFcblxuICB0aGlzLmRhdGEgPSBVdGlscyQxLm51bWJlclRvVmFyaWFibGVMZW5ndGgoMHgwMCkuY29uY2F0KENvbnN0YW50cy5NRVRBX0VWRU5UX0lELCBDb25zdGFudHMuTUVUQV9DVUVfUE9JTlQsIFV0aWxzJDEubnVtYmVyVG9WYXJpYWJsZUxlbmd0aCh0ZXh0Qnl0ZXMubGVuZ3RoKSwgLy8gU2l6ZVxuICB0ZXh0Qnl0ZXMgLy8gVGV4dFxuICApO1xufTtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBlbmQgdHJhY2sgbWV0YSBldmVudC5cbiAqIEByZXR1cm4ge0VuZFRyYWNrRXZlbnR9XG4gKi9cblxudmFyIEVuZFRyYWNrRXZlbnQgPSBmdW5jdGlvbiBFbmRUcmFja0V2ZW50KCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5kVHJhY2tFdmVudCk7XG5cbiAgdGhpcy50eXBlID0gJ2VuZC10cmFjayc7IC8vIFN0YXJ0IHdpdGggemVybyB0aW1lIGRlbHRhXG5cbiAgdGhpcy5kYXRhID0gVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKDB4MDApLmNvbmNhdChDb25zdGFudHMuTUVUQV9FVkVOVF9JRCwgQ29uc3RhbnRzLk1FVEFfRU5EX09GX1RSQUNLX0lEKTtcbn07XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RydW1lbnQgbmFtZSBtZXRhIGV2ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGJwbSAtIEJlYXRzIHBlciBtaW51dGVcbiAqIEByZXR1cm4ge0luc3RydW1lbnROYW1lRXZlbnR9XG4gKi9cblxudmFyIEluc3RydW1lbnROYW1lRXZlbnQgPSBmdW5jdGlvbiBJbnN0cnVtZW50TmFtZUV2ZW50KHRleHQpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluc3RydW1lbnROYW1lRXZlbnQpO1xuXG4gIHRoaXMudHlwZSA9ICdpbnN0cnVtZW50LW5hbWUnO1xuICB2YXIgdGV4dEJ5dGVzID0gVXRpbHMkMS5zdHJpbmdUb0J5dGVzKHRleHQpOyAvLyBTdGFydCB3aXRoIHplcm8gdGltZSBkZWx0YVxuXG4gIHRoaXMuZGF0YSA9IFV0aWxzJDEubnVtYmVyVG9WYXJpYWJsZUxlbmd0aCgweDAwKS5jb25jYXQoQ29uc3RhbnRzLk1FVEFfRVZFTlRfSUQsIENvbnN0YW50cy5NRVRBX0lOU1RSVU1FTlRfTkFNRV9JRCwgVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHRleHRCeXRlcy5sZW5ndGgpLCAvLyBTaXplXG4gIHRleHRCeXRlcyAvLyBJbnN0cnVtZW50IG5hbWVcbiAgKTtcbn07XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEga2V5IHNpZ25hdHVyZSBtZXRhIGV2ZW50LlxuICogQHJldHVybiB7S2V5U2lnbmF0dXJlRXZlbnR9XG4gKi9cblxudmFyIEtleVNpZ25hdHVyZUV2ZW50ID0gZnVuY3Rpb24gS2V5U2lnbmF0dXJlRXZlbnQoc2YsIG1pKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlTaWduYXR1cmVFdmVudCk7XG5cbiAgdGhpcy50eXBlID0gJ2tleS1zaWduYXR1cmUnO1xuICB2YXIgbW9kZSA9IG1pIHx8IDA7XG4gIHNmID0gc2YgfHwgMDsgLy9cdEZ1bmN0aW9uIGNhbGxlZCB3aXRoIHN0cmluZyBub3RhdGlvblxuXG4gIGlmICh0eXBlb2YgbWkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGZpZnRocyA9IFtbJ0NiJywgJ0diJywgJ0RiJywgJ0FiJywgJ0ViJywgJ0JiJywgJ0YnLCAnQycsICdHJywgJ0QnLCAnQScsICdFJywgJ0InLCAnRiMnLCAnQyMnXSwgWydhYicsICdlYicsICdiYicsICdmJywgJ2MnLCAnZycsICdkJywgJ2EnLCAnZScsICdiJywgJ2YjJywgJ2MjJywgJ2cjJywgJ2QjJywgJ2EjJ11dO1xuICAgIHZhciBfc2ZsZW4gPSBzZi5sZW5ndGg7XG4gICAgdmFyIG5vdGUgPSBzZiB8fCAnQyc7XG4gICAgaWYgKHNmWzBdID09PSBzZlswXS50b0xvd2VyQ2FzZSgpKSBtb2RlID0gMTtcblxuICAgIGlmIChfc2ZsZW4gPiAxKSB7XG4gICAgICBzd2l0Y2ggKHNmLmNoYXJBdChfc2ZsZW4gLSAxKSkge1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICBtb2RlID0gMTtcbiAgICAgICAgICBub3RlID0gc2YuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbm90ZSA9IG5vdGUuY29uY2F0KHNmLnN1YnN0cmluZygxLCBfc2ZsZW4gLSAxKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgbW9kZSA9IDE7XG4gICAgICAgICAgbm90ZSA9IHNmLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIG5vdGUgPSBub3RlLmNvbmNhdChzZi5zdWJzdHJpbmcoMSwgX3NmbGVuIC0gMSkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIG1vZGUgPSAwO1xuICAgICAgICAgIG5vdGUgPSBzZi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBub3RlID0gbm90ZS5jb25jYXQoc2Yuc3Vic3RyaW5nKDEsIF9zZmxlbiAtIDEpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICBtb2RlID0gMDtcbiAgICAgICAgICBub3RlID0gc2YuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgbm90ZSA9IG5vdGUuY29uY2F0KHNmLnN1YnN0cmluZygxLCBfc2ZsZW4gLSAxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpZnRoaW5kZXggPSBmaWZ0aHNbbW9kZV0uaW5kZXhPZihub3RlKTtcbiAgICBzZiA9IGZpZnRoaW5kZXggPT09IC0xID8gMCA6IGZpZnRoaW5kZXggLSA3O1xuICB9IC8vIFN0YXJ0IHdpdGggemVybyB0aW1lIGRlbHRhXG5cblxuICB0aGlzLmRhdGEgPSBVdGlscyQxLm51bWJlclRvVmFyaWFibGVMZW5ndGgoMHgwMCkuY29uY2F0KENvbnN0YW50cy5NRVRBX0VWRU5UX0lELCBDb25zdGFudHMuTUVUQV9LRVlfU0lHTkFUVVJFX0lELCBbMHgwMl0sIC8vIFNpemVcbiAgVXRpbHMkMS5udW1iZXJUb0J5dGVzKHNmLCAxKSwgLy8gTnVtYmVyIG9mIHNoYXJwIG9yIGZsYXRzICggPCAwIGZsYXQ7ID4gMCBzaGFycClcbiAgVXRpbHMkMS5udW1iZXJUb0J5dGVzKG1vZGUsIDEpIC8vIE1vZGU6IDAgbWFqb3IsIDEgbWlub3JcbiAgKTtcbn07XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgbHlyaWMgbWV0YSBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gTHlyaWMgdGV4dFxuICogQHJldHVybiB7THlyaWNFdmVudH1cbiAqL1xuXG52YXIgTHlyaWNFdmVudCA9IGZ1bmN0aW9uIEx5cmljRXZlbnQodGV4dCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTHlyaWNFdmVudCk7XG5cbiAgdGhpcy50eXBlID0gJ21hcmtlcic7XG4gIHZhciB0ZXh0Qnl0ZXMgPSBVdGlscyQxLnN0cmluZ1RvQnl0ZXModGV4dCk7IC8vIFN0YXJ0IHdpdGggemVybyB0aW1lIGRlbHRhXG5cbiAgdGhpcy5kYXRhID0gVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKDB4MDApLmNvbmNhdChDb25zdGFudHMuTUVUQV9FVkVOVF9JRCwgQ29uc3RhbnRzLk1FVEFfTFlSSUNfSUQsIFV0aWxzJDEubnVtYmVyVG9WYXJpYWJsZUxlbmd0aCh0ZXh0Qnl0ZXMubGVuZ3RoKSwgLy8gU2l6ZVxuICB0ZXh0Qnl0ZXMgLy8gVGV4dFxuICApO1xufTtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBtYXJrZXIgbWV0YSBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gTWFya2VyIHRleHRcbiAqIEByZXR1cm4ge01hcmtlckV2ZW50fVxuICovXG5cbnZhciBNYXJrZXJFdmVudCA9IGZ1bmN0aW9uIE1hcmtlckV2ZW50KHRleHQpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmtlckV2ZW50KTtcblxuICB0aGlzLnR5cGUgPSAnbWFya2VyJztcbiAgdmFyIHRleHRCeXRlcyA9IFV0aWxzJDEuc3RyaW5nVG9CeXRlcyh0ZXh0KTsgLy8gU3RhcnQgd2l0aCB6ZXJvIHRpbWUgZGVsdGFcblxuICB0aGlzLmRhdGEgPSBVdGlscyQxLm51bWJlclRvVmFyaWFibGVMZW5ndGgoMHgwMCkuY29uY2F0KENvbnN0YW50cy5NRVRBX0VWRU5UX0lELCBDb25zdGFudHMuTUVUQV9NQVJLRVJfSUQsIFV0aWxzJDEubnVtYmVyVG9WYXJpYWJsZUxlbmd0aCh0ZXh0Qnl0ZXMubGVuZ3RoKSwgLy8gU2l6ZVxuICB0ZXh0Qnl0ZXMgLy8gVGV4dFxuICApO1xufTtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSB0ZW1wbyBtZXRhIGV2ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGJwbSAtIEJlYXRzIHBlciBtaW51dGVcbiAqIEByZXR1cm4ge1RlbXBvRXZlbnR9XG4gKi9cblxudmFyIFRlbXBvRXZlbnQgPSBmdW5jdGlvbiBUZW1wb0V2ZW50KGJwbSkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVtcG9FdmVudCk7XG5cbiAgdGhpcy50eXBlID0gJ3RlbXBvJztcbiAgdmFyIHRlbXBvID0gTWF0aC5yb3VuZCg2MDAwMDAwMCAvIGJwbSk7IC8vIFN0YXJ0IHdpdGggemVybyB0aW1lIGRlbHRhXG5cbiAgdGhpcy5kYXRhID0gVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKDB4MDApLmNvbmNhdChDb25zdGFudHMuTUVUQV9FVkVOVF9JRCwgQ29uc3RhbnRzLk1FVEFfVEVNUE9fSUQsIFsweDAzXSwgLy8gU2l6ZVxuICBVdGlscyQxLm51bWJlclRvQnl0ZXModGVtcG8sIDMpIC8vIFRlbXBvLCAzIGJ5dGVzXG4gICk7XG59O1xuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHRlbXBvIG1ldGEgZXZlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gYnBtIC0gQmVhdHMgcGVyIG1pbnV0ZVxuICogQHJldHVybiB7VGV4dEV2ZW50fVxuICovXG5cbnZhciBUZXh0RXZlbnQgPSBmdW5jdGlvbiBUZXh0RXZlbnQodGV4dCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dEV2ZW50KTtcblxuICB0aGlzLnR5cGUgPSAndGV4dCc7XG4gIHZhciB0ZXh0Qnl0ZXMgPSBVdGlscyQxLnN0cmluZ1RvQnl0ZXModGV4dCk7IC8vIFN0YXJ0IHdpdGggemVybyB0aW1lIGRlbHRhXG5cbiAgdGhpcy5kYXRhID0gVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKDB4MDApLmNvbmNhdChDb25zdGFudHMuTUVUQV9FVkVOVF9JRCwgQ29uc3RhbnRzLk1FVEFfVEVYVF9JRCwgVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHRleHRCeXRlcy5sZW5ndGgpLCAvLyBTaXplXG4gIHRleHRCeXRlcyAvLyBUZXh0XG4gICk7XG59O1xuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHRpbWUgc2lnbmF0dXJlIG1ldGEgZXZlbnQuXG4gKiBAcmV0dXJuIHtUaW1lU2lnbmF0dXJlRXZlbnR9XG4gKi9cblxudmFyIFRpbWVTaWduYXR1cmVFdmVudCA9IGZ1bmN0aW9uIFRpbWVTaWduYXR1cmVFdmVudChudW1lcmF0b3IsIGRlbm9taW5hdG9yLCBtaWRpY2xvY2tzcGVydGljaywgbm90ZXNwZXJtaWRpY2xvY2spIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVTaWduYXR1cmVFdmVudCk7XG5cbiAgdGhpcy50eXBlID0gJ3RpbWUtc2lnbmF0dXJlJzsgLy8gU3RhcnQgd2l0aCB6ZXJvIHRpbWUgZGVsdGFcblxuICB0aGlzLmRhdGEgPSBVdGlscyQxLm51bWJlclRvVmFyaWFibGVMZW5ndGgoMHgwMCkuY29uY2F0KENvbnN0YW50cy5NRVRBX0VWRU5UX0lELCBDb25zdGFudHMuTUVUQV9USU1FX1NJR05BVFVSRV9JRCwgWzB4MDRdLCAvLyBTaXplXG4gIFV0aWxzJDEubnVtYmVyVG9CeXRlcyhudW1lcmF0b3IsIDEpLCAvLyBOdW1lcmF0b3IsIDEgYnl0ZXNcbiAgVXRpbHMkMS5udW1iZXJUb0J5dGVzKE1hdGgubG9nMihkZW5vbWluYXRvciksIDEpLCAvLyBEZW5vbWluYXRvciBpcyBleHByZXNzZWQgYXMgcG93IG9mIDIsIDEgYnl0ZXNcbiAgVXRpbHMkMS5udW1iZXJUb0J5dGVzKG1pZGljbG9ja3NwZXJ0aWNrIHx8IDI0LCAxKSwgLy8gTUlESSBDbG9ja3MgcGVyIHRpY2ssIDEgYnl0ZXNcbiAgVXRpbHMkMS5udW1iZXJUb0J5dGVzKG5vdGVzcGVybWlkaWNsb2NrIHx8IDgsIDEpIC8vIE51bWJlciBvZiAxLzMyIG5vdGVzIHBlciBNSURJIGNsb2NrcywgMSBieXRlc1xuICApO1xufTtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSB0ZW1wbyBtZXRhIGV2ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGJwbSAtIEJlYXRzIHBlciBtaW51dGVcbiAqIEByZXR1cm4ge1RyYWNrTmFtZUV2ZW50fVxuICovXG5cbnZhciBUcmFja05hbWVFdmVudCA9IGZ1bmN0aW9uIFRyYWNrTmFtZUV2ZW50KHRleHQpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrTmFtZUV2ZW50KTtcblxuICB0aGlzLnR5cGUgPSAndHJhY2stbmFtZSc7XG4gIHZhciB0ZXh0Qnl0ZXMgPSBVdGlscyQxLnN0cmluZ1RvQnl0ZXModGV4dCk7IC8vIFN0YXJ0IHdpdGggemVybyB0aW1lIGRlbHRhXG5cbiAgdGhpcy5kYXRhID0gVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKDB4MDApLmNvbmNhdChDb25zdGFudHMuTUVUQV9FVkVOVF9JRCwgQ29uc3RhbnRzLk1FVEFfVFJBQ0tfTkFNRV9JRCwgVXRpbHMkMS5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHRleHRCeXRlcy5sZW5ndGgpLCAvLyBTaXplXG4gIHRleHRCeXRlcyAvLyBUZXh0XG4gICk7XG59O1xuXG4vKipcbiAqIEhvbGRzIGFsbCBkYXRhIGZvciBhIHRyYWNrLlxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkcyB7dHlwZTogbnVtYmVyLCBkYXRhOiBhcnJheSwgc2l6ZTogYXJyYXksIGV2ZW50czogYXJyYXl9XG4gKiBAcmV0dXJuIHtUcmFja31cbiAqL1xuXG52YXIgVHJhY2sgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xuXG4gICAgdGhpcy50eXBlID0gQ29uc3RhbnRzLlRSQUNLX0NIVU5LX1RZUEU7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5zaXplID0gW107XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLmV4cGxpY2l0VGlja0V2ZW50cyA9IFtdOyAvLyBJZiB0aGVyZSBhcmUgYW55IGV2ZW50cyB3aXRoIGFuIGV4cGxpY2l0IHRpY2sgZGVmaW5lZCB0aGVuIHdlIHdpbGwgY3JlYXRlIGEgXCJzdWJcIiB0cmFjayBmb3IgdGhvc2VcbiAgICAvLyBhbmQgbWVyZ2UgdGhlbSBpbiBhbmQgdGhlIGVuZC5cblxuICAgIHRoaXMudGlja1BvaW50ZXIgPSAwOyAvLyBFYWNoIHRpbWUgYW4gZXZlbnQgaXMgYWRkZWQgdGhpcyB3aWxsIGluY3JlYXNlXG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW55IGV2ZW50IHR5cGUgdG8gdGhlIHRyYWNrLlxuICAgKiBFdmVudHMgd2l0aG91dCBhIHNwZWNpZmljIHN0YXJ0VGljayBwcm9wZXJ0eSBhcmUgYXNzdW1lZCB0byBiZSBhZGRlZCBpbiBvcmRlciBvZiBob3cgdGhleSBzaG91bGQgb3V0cHV0LlxuICAgKiBFdmVudHMgd2l0aCBhIHNwZWNpZmljIHN0YXJ0VGljayBwcm9wZXJ0eSBhcmUgc2V0IGFzaWRlIGZvciBub3cgd2lsbCBiZSBtZXJnZWQgaW4gZHVyaW5nIGJ1aWxkIHByb2Nlc3MuXG4gICAqIEBwYXJhbSB7KE5vdGVFdmVudHxQcm9ncmFtQ2hhbmdlRXZlbnQpfSBldmVudHMgLSBFdmVudCBvYmplY3Qgb3IgYXJyYXkgb2YgRXZlbnQgb2JqZWN0cy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRnVuY3Rpb24gLSBDYWxsYmFjayB3aGljaCBjYW4gYmUgdXNlZCB0byBhcHBseSBzcGVjaWZpYyBwcm9wZXJ0aWVzIHRvIGFsbCBldmVudHMuIFxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVHJhY2ssIFt7XG4gICAga2V5OiBcImFkZEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50KGV2ZW50cywgbWFwRnVuY3Rpb24pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIFV0aWxzJDEudG9BcnJheShldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50LCBpKSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbm90ZScpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgbWFwIGZ1bmN0aW9uIGlmIHByb3ZpZGVkXG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXBGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBtYXBGdW5jdGlvbihpLCBldmVudCk7XG5cbiAgICAgICAgICAgIGlmIChfdHlwZW9mKHByb3BlcnRpZXMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGopIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2R1cmF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZHVyYXRpb24gPSBwcm9wZXJ0aWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAnc2VxdWVudGlhbCc6XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNlcXVlbnRpYWwgPSBwcm9wZXJ0aWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAndmVsb2NpdHknOlxuICAgICAgICAgICAgICAgICAgICBldmVudC52ZWxvY2l0eSA9IFV0aWxzJDEuY29udmVydFZlbG9jaXR5KHByb3BlcnRpZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIElmIHRoaXMgbm90ZSBldmVudCBoYXMgYW4gZXhwbGljaXQgc3RhcnRUaWNrIHRoZW4gd2UgbmVlZCB0byBzZXQgYXNpZGUgZm9yIG5vd1xuXG5cbiAgICAgICAgICBpZiAoZXZlbnQuc3RhcnRUaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5leHBsaWNpdFRpY2tFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFB1c2ggZWFjaCBvbi9vZmYgZXZlbnQgdG8gdHJhY2sncyBldmVudCBzdGFja1xuICAgICAgICAgICAgZXZlbnQuYnVpbGREYXRhKCkuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV2ZW50cy5wdXNoKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLmV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGludCBhcnJheSBvZiBhbGwgZXZlbnRzLlxuICAgICAqIEByZXR1cm4ge1RyYWNrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkRGF0YSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgZW5kIHRyYWNrIGV2ZW50IGFuZCBhZGQgb25lLlxuICAgICAgLy8gVGhpcyBtYWtlcyBzdXJlIGl0J3MgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBldmVudCBsaXN0LlxuICAgICAgdGhpcy5yZW1vdmVFdmVudHNCeVR5cGUoJ2VuZC10cmFjaycpLmFkZEV2ZW50KG5ldyBFbmRUcmFja0V2ZW50KCkpOyAvLyBSZXNldFxuXG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIHRoaXMuc2l6ZSA9IFtdO1xuICAgICAgdGhpcy50aWNrUG9pbnRlciA9IDA7XG4gICAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCwgZXZlbnRJbmRleCkge1xuICAgICAgICAvLyBCdWlsZCBldmVudCAmIGFkZCB0byB0b3RhbCB0aWNrIGR1cmF0aW9uXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbm90ZS1vbicgfHwgZXZlbnQudHlwZSA9PT0gJ25vdGUtb2ZmJykge1xuICAgICAgICAgIF90aGlzMi5kYXRhID0gX3RoaXMyLmRhdGEuY29uY2F0KGV2ZW50LmJ1aWxkRGF0YShfdGhpczIpLmRhdGEpO1xuICAgICAgICAgIF90aGlzMi50aWNrUG9pbnRlciA9IGV2ZW50LnRpY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMyLmRhdGEgPSBfdGhpczIuZGF0YS5jb25jYXQoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5tZXJnZUV4cGxpY2l0VGlja0V2ZW50cygpO1xuICAgICAgdGhpcy5zaXplID0gVXRpbHMkMS5udW1iZXJUb0J5dGVzKHRoaXMuZGF0YS5sZW5ndGgsIDQpOyAvLyA0IGJ5dGVzIGxvbmdcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlRXhwbGljaXRUaWNrRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlRXhwbGljaXRUaWNrRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5leHBsaWNpdFRpY2tFdmVudHMubGVuZ3RoKSByZXR1cm47IC8vIEZpcnN0IHNvcnQgYXNjIGxpc3Qgb2YgZXZlbnRzIGJ5IHN0YXJ0VGlja1xuXG4gICAgICB0aGlzLmV4cGxpY2l0VGlja0V2ZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnN0YXJ0VGljayAtIGIuc3RhcnRUaWNrO1xuICAgICAgfSk7IC8vIE5vdyB0aGlzLmV4cGxpY2l0VGlja0V2ZW50cyBpcyBpbiBjb3JyZWN0IG9yZGVyLCBhbmQgc28gaXMgdGhpcy5ldmVudHMgbmF0dXJhbGx5LlxuICAgICAgLy8gRm9yIGVhY2ggZXhwbGljaXQgdGljayBldmVudCwgc3BsaWNlIGl0IGludG8gdGhlIG1haW4gbGlzdCBvZiBldmVudHMgYW5kIFxuICAgICAgLy8gYWRqdXN0IHRoZSBkZWx0YSBvbiB0aGUgZm9sbG93aW5nIGV2ZW50cyBzbyB0aGV5IHN0aWxsIHBsYXkgbm9ybWFsbHkuXG5cbiAgICAgIHRoaXMuZXhwbGljaXRUaWNrRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vdGVFdmVudCkge1xuICAgICAgICAvLyBDb252ZXJ0IE5vdGVFdmVudCB0byBpdCdzIHJlc3BlY3RpdmUgTm90ZU9uL05vdGVPZmYgZXZlbnRzXG4gICAgICAgIC8vIE5vdGUgdGhhdCBhcyB3ZSBzcGxpY2UgaW4gZXZlbnRzIHRoZSBkZWx0YSBmb3IgdGhlIE5vdGVPZmYgb25lcyB3aWxsXG4gICAgICAgIC8vIE5lZWQgdG8gY2hhbmdlIGJhc2VkIG9uIHdoYXQgY29tZXMgYmVmb3JlIHRoZW0gYWZ0ZXIgdGhlIHNwbGljZS5cbiAgICAgICAgbm90ZUV2ZW50LmJ1aWxkRGF0YSgpLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuYnVpbGREYXRhKF90aGlzMyk7XG4gICAgICAgIH0pOyAvLyBNZXJnZSBlYWNoIGV2ZW50IGluZGl2dWFsbHkgaW50byB0aGlzIHRyYWNrJ3MgZXZlbnQgbGlzdC5cblxuICAgICAgICBub3RlRXZlbnQuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5tZXJnZVNpbmdsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gSGFja3kgd2F5IHRvIHJlYnVpbGQgdHJhY2sgd2l0aCBuZXdseSBzcGxpY2VkIGV2ZW50cy4gIE5lZWQgYmV0dGVyIHNvbHV0aW9uLlxuXG4gICAgICB0aGlzLmV4cGxpY2l0VGlja0V2ZW50cyA9IFtdO1xuICAgICAgdGhpcy5idWlsZERhdGEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFub3RoZXIgdHJhY2sncyBldmVudHMgd2l0aCB0aGlzIHRyYWNrLlxuICAgICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrXG4gICAgICogQHJldHVybiB7VHJhY2t9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVRyYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlVHJhY2sodHJhY2spIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAvLyBGaXJzdCBidWlsZCB0aGlzIHRyYWNrIHRvIHBvcHVsYXRlIGVhY2ggZXZlbnQncyB0aWNrIHByb3BlcnR5XG4gICAgICB0aGlzLmJ1aWxkRGF0YSgpOyAvLyBUaGVuIGJ1aWxkIHRyYWNrIHRvIGJlIG1lcmdlZCBzbyB0aGF0IHRpY2sgcHJvcGVydHkgaXMgcG9wdWxhdGVkIG9uIGFsbCBldmVudHMgJiBtZXJnZSBlYWNoIGV2ZW50LlxuXG4gICAgICB0cmFjay5idWlsZERhdGEoKS5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5tZXJnZVNpbmdsZUV2ZW50KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBzaW5nbGUgZXZlbnQgaW50byB0aGlzIHRyYWNrJ3MgbGlzdCBvZiBldmVudHMgYmFzZWQgb24gZXZlbnQudGljayBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge05vdGVPbkV2ZW50fE5vdGVPZmZFdmVudH0gLSBldmVudFxuICAgICAqIEByZXR1cm4ge1RyYWNrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VTaW5nbGVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZVNpbmdsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAvLyBGaW5kIGluZGV4IG9mIGV4aXN0aW5nIGV2ZW50IHdlIG5lZWQgdG8gZm9sbG93IHdpdGggXG4gICAgICB2YXIgbGFzdEV2ZW50SW5kZXggPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50c1tpXS50aWNrID4gZXZlbnQudGljaykgYnJlYWs7XG4gICAgICAgIGxhc3RFdmVudEluZGV4ID0gaTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNwbGljZWRFdmVudEluZGV4ID0gbGFzdEV2ZW50SW5kZXggKyAxOyAvLyBOZWVkIHRvIGFkanVzdCB0aGUgZGVsdGEgb2YgdGhpcyBldmVudCB0byBlbnN1cmUgaXQgZmFsbHMgb24gdGhlIGNvcnJlY3QgdGljay5cblxuICAgICAgZXZlbnQuZGVsdGEgPSBldmVudC50aWNrIC0gdGhpcy5ldmVudHNbbGFzdEV2ZW50SW5kZXhdLnRpY2s7IC8vIFNwbGljZSB0aGlzIGV2ZW50IGF0IGxhc3RFdmVudEluZGV4ICsgMVxuXG4gICAgICB0aGlzLmV2ZW50cy5zcGxpY2Uoc3BsaWNlZEV2ZW50SW5kZXgsIDAsIGV2ZW50KTsgLy8gTm93IGFkanVzdCBkZWx0YSBvZiBhbGwgZm9sbG93aW5nIGV2ZW50c1xuXG4gICAgICBmb3IgKHZhciBpID0gc3BsaWNlZEV2ZW50SW5kZXggKyAxOyBpIDwgdGhpcy5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gU2luY2UgZWFjaCBleGlzdGluZyBldmVudCBzaG91bGQgaGF2ZSBhIHRpY2sgdmFsdWUgYXQgdGhpcyBwb2ludCB3ZSBqdXN0IG5lZWQgdG9cbiAgICAgICAgLy8gYWRqdXN0IGRlbHRhIHRvIHRoYXQgdGhlIGV2ZW50IHN0aWxsIGZhbGxzIG9uIHRoZSBjb3JyZWN0IHRpY2suXG4gICAgICAgIHRoaXMuZXZlbnRzW2ldLmRlbHRhID0gdGhpcy5ldmVudHNbaV0udGljayAtIHRoaXMuZXZlbnRzW2kgLSAxXS50aWNrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBldmVudHMgbWF0Y2hpbmcgc3BlY2lmaWVkIHR5cGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIEV2ZW50IHR5cGVcbiAgICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUV2ZW50c0J5VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudHNCeVR5cGUoZXZlbnRUeXBlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQsIGluZGV4KSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICBfdGhpczUuZXZlbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGVtcG8gb2YgdGhlIE1JREkgZmlsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnBtIC0gVGVtcG8gaW4gYmVhdHMgcGVyIG1pbnV0ZS5cbiAgICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFRlbXBvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRlbXBvKGJwbSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnQobmV3IFRlbXBvRXZlbnQoYnBtKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGltZSBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWVyYXRvciAtIFRvcCBudW1iZXIgb2YgdGhlIHRpbWUgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZW5vbWluYXRvciAtIEJvdHRvbSBudW1iZXIgb2YgdGhlIHRpbWUgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaWRpY2xvY2tzcGVydGljayAtIERlZmF1bHRzIHRvIDI0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3Rlc3Blcm1pZGljbG9jayAtIERlZmF1bHRzIHRvIDguXG4gICAgICogQHJldHVybiB7VHJhY2t9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUaW1lU2lnbmF0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRpbWVTaWduYXR1cmUobnVtZXJhdG9yLCBkZW5vbWluYXRvciwgbWlkaWNsb2Nrc3BlcnRpY2ssIG5vdGVzcGVybWlkaWNsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRFdmVudChuZXcgVGltZVNpZ25hdHVyZUV2ZW50KG51bWVyYXRvciwgZGVub21pbmF0b3IsIG1pZGljbG9ja3NwZXJ0aWNrLCBub3Rlc3Blcm1pZGljbG9jaykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGtleSBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHsqfSBzZiAtIFxuICAgICAqIEBwYXJhbSB7Kn0gbWkgLVxuICAgICAqIEByZXR1cm4ge1RyYWNrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0S2V5U2lnbmF0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEtleVNpZ25hdHVyZShzZiwgbWkpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50KG5ldyBLZXlTaWduYXR1cmVFdmVudChzZiwgbWkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0ZXh0IHRvIE1JREkgZmlsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgdG8gYWRkLlxuICAgICAqIEByZXR1cm4ge1RyYWNrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUZXh0KHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50KG5ldyBUZXh0RXZlbnQodGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGNvcHlyaWdodCB0byBNSURJIGZpbGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IG9mIGNvcHlyaWdodCBsaW5lLlxuICAgICAqIEByZXR1cm4ge1RyYWNrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ29weXJpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvcHlyaWdodCh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRFdmVudChuZXcgQ29weXJpZ2h0RXZlbnQodGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIFNlcXVlbmNlL1RyYWNrIE5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRyYWNrIG5hbWUuXG4gICAgICogQHJldHVybiB7VHJhY2t9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRUcmFja05hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVHJhY2tOYW1lKHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50KG5ldyBUcmFja05hbWVFdmVudCh0ZXh0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgaW5zdHJ1bWVudCBuYW1lIG9mIHRyYWNrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gTmFtZSBvZiBpbnN0cnVtZW50LlxuICAgICAqIEByZXR1cm4ge1RyYWNrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkSW5zdHJ1bWVudE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5zdHJ1bWVudE5hbWUodGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnQobmV3IEluc3RydW1lbnROYW1lRXZlbnQodGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG1hcmtlciB0byBNSURJIGZpbGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBNYXJrZXIgdGV4dC5cbiAgICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZE1hcmtlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXJrZXIodGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnQobmV3IE1hcmtlckV2ZW50KHRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBjdWUgcG9pbnQgdG8gTUlESSBmaWxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCBvZiBjdWUgcG9pbnQuXG4gICAgICogQHJldHVybiB7VHJhY2t9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRDdWVQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDdWVQb2ludCh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRFdmVudChuZXcgQ3VlUG9pbnRFdmVudCh0ZXh0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbHlyaWMgdG8gTUlESSBmaWxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gTHlyaWMgdGV4dCB0byBhZGQuXG4gICAgICogQHJldHVybiB7VHJhY2t9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRMeXJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRMeXJpYyh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRFdmVudChuZXcgTHlyaWNFdmVudCh0ZXh0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5uZWwgbW9kZSBtZXNzYWdlc1xuICAgICAqIEByZXR1cm4ge1RyYWNrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicG9seU1vZGVPblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb2x5TW9kZU9uKCkge1xuICAgICAgdmFyIGV2ZW50ID0gbmV3IE5vdGVPbkV2ZW50KHtcbiAgICAgICAgZGF0YTogWzB4MDAsIDB4QjAsIDB4N0UsIDB4MDBdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhY2s7XG59KCk7XG5cbnZhciBWZXhGbG93ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmV4RmxvdygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmV4Rmxvdyk7XG4gIH0gLy8gY29kZS4uLlxuXG4gIC8qKlxuICAgKiBTdXBwb3J0IGZvciBjb252ZXJ0aW5nIFZleEZsb3cgdm9pY2UgaW50byBNaWRpV3JpdGVySlMgdHJhY2tcbiAgICogQHJldHVybiBNaWRpV3JpdGllci5UcmFjayBvYmplY3RcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVmV4RmxvdywgW3tcbiAgICBrZXk6IFwidHJhY2tGcm9tVm9pY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhY2tGcm9tVm9pY2Uodm9pY2UpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB0cmFjayA9IG5ldyBUcmFjaygpO1xuICAgICAgdmFyIHdhaXQ7XG4gICAgICB2YXIgcGl0Y2hlcyA9IFtdO1xuICAgICAgdm9pY2UudGlja2FibGVzLmZvckVhY2goZnVuY3Rpb24gKHRpY2thYmxlKSB7XG4gICAgICAgIHBpdGNoZXMgPSBbXTtcblxuICAgICAgICBpZiAodGlja2FibGUubm90ZVR5cGUgPT09ICduJykge1xuICAgICAgICAgIHRpY2thYmxlLmtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAvLyBidWlsZCBhcnJheSBvZiBwaXRjaGVzXG4gICAgICAgICAgICBwaXRjaGVzLnB1c2goX3RoaXMuY29udmVydFBpdGNoKGtleSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRpY2thYmxlLm5vdGVUeXBlID09PSAncicpIHtcbiAgICAgICAgICAvLyBtb3ZlIG9uIHRvIHRoZSBuZXh0IHRpY2thYmxlIGFuZCB1c2UgdGhpcyByZXN0IGFzIGEgYHdhaXRgIHByb3BlcnR5IGZvciB0aGUgbmV4dCBldmVudFxuICAgICAgICAgIHdhaXQgPSBfdGhpcy5jb252ZXJ0RHVyYXRpb24odGlja2FibGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrLmFkZEV2ZW50KG5ldyBOb3RlRXZlbnQoe1xuICAgICAgICAgIHBpdGNoOiBwaXRjaGVzLFxuICAgICAgICAgIGR1cmF0aW9uOiBfdGhpcy5jb252ZXJ0RHVyYXRpb24odGlja2FibGUpLFxuICAgICAgICAgIHdhaXQ6IHdhaXRcbiAgICAgICAgfSkpOyAvLyByZXNldCB3YWl0XG5cbiAgICAgICAgd2FpdCA9IDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgVmV4RmxvdyBwaXRjaCBzeW50YXggdG8gTWlkaVdyaXRlckpTIHN5bnRheFxuICAgICAqIEBwYXJhbSBwaXRjaCBzdHJpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnZlcnRQaXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0UGl0Y2gocGl0Y2gpIHtcbiAgICAgIHJldHVybiBwaXRjaC5yZXBsYWNlKCcvJywgJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBWZXhGbG93IGR1cmF0aW9uIHN5bnRheCB0byBNaWRpV3JpdGVySlMgc3ludGF4XG4gICAgICogQHBhcmFtIG5vdGUgc3RydWN0IGZyb20gVmV4Rmxvd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnREdXJhdGlvbihub3RlKSB7XG4gICAgICBzd2l0Y2ggKG5vdGUuZHVyYXRpb24pIHtcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgcmV0dXJuICcxJztcblxuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICByZXR1cm4gbm90ZS5pc0RvdHRlZCgpID8gJ2QyJyA6ICcyJztcblxuICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICByZXR1cm4gbm90ZS5pc0RvdHRlZCgpID8gJ2Q0JyA6ICc0JztcblxuICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICByZXR1cm4gbm90ZS5pc0RvdHRlZCgpID8gJ2Q4JyA6ICc4JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vdGUuZHVyYXRpb247XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZleEZsb3c7XG59KCk7XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgaGVhZGVyIGNodW5rIHNlY3Rpb24gb2YgYSBNSURJIGZpbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZUcmFja3MgLSBOdW1iZXIgb2YgdHJhY2tzXG4gKiBAcmV0dXJuIHtIZWFkZXJDaHVua31cbiAqL1xuXG52YXIgSGVhZGVyQ2h1bmsgPSBmdW5jdGlvbiBIZWFkZXJDaHVuayhudW1iZXJPZlRyYWNrcykge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVhZGVyQ2h1bmspO1xuXG4gIHRoaXMudHlwZSA9IENvbnN0YW50cy5IRUFERVJfQ0hVTktfVFlQRTtcbiAgdmFyIHRyYWNrVHlwZSA9IG51bWJlck9mVHJhY2tzID4gMSA/IENvbnN0YW50cy5IRUFERVJfQ0hVTktfRk9STUFUMSA6IENvbnN0YW50cy5IRUFERVJfQ0hVTktfRk9STUFUMDtcbiAgdGhpcy5kYXRhID0gdHJhY2tUeXBlLmNvbmNhdChVdGlscyQxLm51bWJlclRvQnl0ZXMobnVtYmVyT2ZUcmFja3MsIDIpLCAvLyB0d28gYnl0ZXMgbG9uZyxcbiAgQ29uc3RhbnRzLkhFQURFUl9DSFVOS19ESVZJU0lPTik7XG4gIHRoaXMuc2l6ZSA9IFswLCAwLCAwLCB0aGlzLmRhdGEubGVuZ3RoXTtcbn07XG5cbi8qKlxuICogT2JqZWN0IHRoYXQgcHV0cyB0b2dldGhlciB0cmFja3MgYW5kIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGZpbGUgb3V0cHV0LlxuICogQHBhcmFtIHthcnJheXxUcmFja30gdHJhY2tzIC0gQSBzaW5nbGUge1RyYWNrfSBvYmplY3Qgb3IgYW4gYXJyYXkgb2Yge1RyYWNrfSBvYmplY3RzLlxuICogQHJldHVybiB7V3JpdGVyfVxuICovXG5cbnZhciBXcml0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXcml0ZXIodHJhY2tzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXcml0ZXIpO1xuXG4gICAgLy8gRW5zdXJlIHRyYWNrIGlzIGFuIGFycmF5XG4gICAgdHJhY2tzID0gVXRpbHMkMS50b0FycmF5KHRyYWNrcyk7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5kYXRhLnB1c2gobmV3IEhlYWRlckNodW5rKHRyYWNrcy5sZW5ndGgpKTsgLy8gRm9yIGVhY2ggdHJhY2sgYWRkIGZpbmFsIGVuZCBvZiB0cmFjayBldmVudCBhbmQgYnVpbGQgZGF0YVxuXG4gICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrLCBpKSB7XG4gICAgICBfdGhpcy5kYXRhLnB1c2godHJhY2suYnVpbGREYXRhKCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGZpbGUgaW50byBhIFVpbnQ4QXJyYXlcbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoV3JpdGVyLCBbe1xuICAgIGtleTogXCJidWlsZEZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRGaWxlKCkge1xuICAgICAgdmFyIGJ1aWxkID0gW107IC8vIERhdGEgY29uc2lzdHMgb2YgY2h1bmtzIHdoaWNoIGNvbnNpc3RzIG9mIGRhdGFcblxuICAgICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkID0gYnVpbGQuY29uY2F0KGQudHlwZSwgZC5zaXplLCBkLmRhdGEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVpbGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGZpbGUgYnVmZmVyIHRvIGEgYmFzZTY0IHN0cmluZy4gIERpZmZlcmVudCBtZXRob2RzIGRlcGVuZGluZyBvbiBpZiBicm93c2VyIG9yIG5vZGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmFzZTY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhc2U2NCgpIHtcbiAgICAgIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB0aGlzLmJ1aWxkRmlsZSgpKSk7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5idWlsZEZpbGUoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRhdGEgVVJJLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRhdGFVcmlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YVVyaSgpIHtcbiAgICAgIHJldHVybiAnZGF0YTphdWRpby9taWRpO2Jhc2U2NCwnICsgdGhpcy5iYXNlNjQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3V0cHV0IHRvIHN0ZG91dFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0ZG91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGRvdXQoKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5zdGRvdXQud3JpdGUobmV3IEJ1ZmZlcih0aGlzLmJ1aWxkRmlsZSgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmUgdG8gTUlESSBmaWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzYXZlTUlESVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlTUlESShmaWxlbmFtZSkge1xuICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcblxuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5idWlsZEZpbGUoKSk7XG4gICAgICBmcy53cml0ZUZpbGUoZmlsZW5hbWUgKyAnLm1pZCcsIGJ1ZmZlciwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV3JpdGVyO1xufSgpO1xuXG52YXIgbWFpbiA9IHtcbiAgQ29uc3RhbnRzOiBDb25zdGFudHMsXG4gIENvbnRyb2xsZXJDaGFuZ2VFdmVudDogQ29udHJvbGxlckNoYW5nZUV2ZW50LFxuICBOb3RlRXZlbnQ6IE5vdGVFdmVudCxcbiAgUHJvZ3JhbUNoYW5nZUV2ZW50OiBQcm9ncmFtQ2hhbmdlRXZlbnQsXG4gIFRyYWNrOiBUcmFjayxcbiAgVXRpbHM6IFV0aWxzJDEsXG4gIFZleEZsb3c6IFZleEZsb3csXG4gIFdyaXRlcjogV3JpdGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1haW47XG4iLCIoZnVuY3Rpb24oZSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZSgpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGUpfWVsc2V7dmFyIHQ7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe3Q9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe3Q9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXt0PXNlbGZ9ZWxzZXt0PXRoaXN9dC5taWRpbWVzc2FnZT1lKCl9fSkoZnVuY3Rpb24oKXt2YXIgZSx0LHM7cmV0dXJuIGZ1bmN0aW9uIG8oZSx0LHMpe2Z1bmN0aW9uIGEobixpKXtpZighdFtuXSl7aWYoIWVbbl0pe3ZhciBsPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIWkmJmwpcmV0dXJuIGwobiwhMCk7aWYocilyZXR1cm4gcihuLCEwKTt2YXIgaD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK24rXCInXCIpO3Rocm93IGguY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixofXZhciBjPXRbbl09e2V4cG9ydHM6e319O2Vbbl1bMF0uY2FsbChjLmV4cG9ydHMsZnVuY3Rpb24odCl7dmFyIHM9ZVtuXVsxXVt0XTtyZXR1cm4gYShzP3M6dCl9LGMsYy5leHBvcnRzLG8sZSx0LHMpfXJldHVybiB0W25dLmV4cG9ydHN9dmFyIHI9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG49MDtuPHMubGVuZ3RoO24rKylhKHNbbl0pO3JldHVybiBhfSh7MTpbZnVuY3Rpb24oZSx0LHMpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7c1tcImRlZmF1bHRcIl09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXt0aGlzLl9ldmVudD1lO3RoaXMuX2RhdGE9ZS5kYXRhO3RoaXMucmVjZWl2ZWRUaW1lPWUucmVjZWl2ZWRUaW1lO2lmKHRoaXMuX2RhdGEmJnRoaXMuX2RhdGEubGVuZ3RoPDIpe2NvbnNvbGUud2FybihcIklsbGVnYWwgTUlESSBtZXNzYWdlIG9mIGxlbmd0aFwiLHRoaXMuX2RhdGEubGVuZ3RoKTtyZXR1cm59dGhpcy5fbWVzc2FnZUNvZGU9ZS5kYXRhWzBdJjI0MDt0aGlzLmNoYW5uZWw9ZS5kYXRhWzBdJjE1O3N3aXRjaCh0aGlzLl9tZXNzYWdlQ29kZSl7Y2FzZSAxMjg6dGhpcy5tZXNzYWdlVHlwZT1cIm5vdGVvZmZcIjt0aGlzLmtleT1lLmRhdGFbMV0mMTI3O3RoaXMudmVsb2NpdHk9ZS5kYXRhWzJdJjEyNzticmVhaztjYXNlIDE0NDp0aGlzLm1lc3NhZ2VUeXBlPVwibm90ZW9uXCI7dGhpcy5rZXk9ZS5kYXRhWzFdJjEyNzt0aGlzLnZlbG9jaXR5PWUuZGF0YVsyXSYxMjc7YnJlYWs7Y2FzZSAxNjA6dGhpcy5tZXNzYWdlVHlwZT1cImtleXByZXNzdXJlXCI7dGhpcy5rZXk9ZS5kYXRhWzFdJjEyNzt0aGlzLnByZXNzdXJlPWUuZGF0YVsyXSYxMjc7YnJlYWs7Y2FzZSAxNzY6dGhpcy5tZXNzYWdlVHlwZT1cImNvbnRyb2xjaGFuZ2VcIjt0aGlzLmNvbnRyb2xsZXJOdW1iZXI9ZS5kYXRhWzFdJjEyNzt0aGlzLmNvbnRyb2xsZXJWYWx1ZT1lLmRhdGFbMl0mMTI3O2lmKHRoaXMuY29udHJvbGxlck51bWJlcj09PTEyMCYmdGhpcy5jb250cm9sbGVyVmFsdWU9PT0wKXt0aGlzLmNoYW5uZWxNb2RlTWVzc2FnZT1cImFsbHNvdW5kb2ZmXCJ9ZWxzZSBpZih0aGlzLmNvbnRyb2xsZXJOdW1iZXI9PT0xMjEpe3RoaXMuY2hhbm5lbE1vZGVNZXNzYWdlPVwicmVzZXRhbGxjb250cm9sbGVyc1wifWVsc2UgaWYodGhpcy5jb250cm9sbGVyTnVtYmVyPT09MTIyKXtpZih0aGlzLmNvbnRyb2xsZXJWYWx1ZT09PTApe3RoaXMuY2hhbm5lbE1vZGVNZXNzYWdlPVwibG9jYWxjb250cm9sb2ZmXCJ9ZWxzZXt0aGlzLmNoYW5uZWxNb2RlTWVzc2FnZT1cImxvY2FsY29udHJvbG9uXCJ9fWVsc2UgaWYodGhpcy5jb250cm9sbGVyTnVtYmVyPT09MTIzJiZ0aGlzLmNvbnRyb2xsZXJWYWx1ZT09PTApe3RoaXMuY2hhbm5lbE1vZGVNZXNzYWdlPVwiYWxsbm90ZXNvZmZcIn1lbHNlIGlmKHRoaXMuY29udHJvbGxlck51bWJlcj09PTEyNCYmdGhpcy5jb250cm9sbGVyVmFsdWU9PT0wKXt0aGlzLmNoYW5uZWxNb2RlTWVzc2FnZT1cIm9tbmltb2Rlb2ZmXCJ9ZWxzZSBpZih0aGlzLmNvbnRyb2xsZXJOdW1iZXI9PT0xMjUmJnRoaXMuY29udHJvbGxlclZhbHVlPT09MCl7dGhpcy5jaGFubmVsTW9kZU1lc3NhZ2U9XCJvbW5pbW9kZW9uXCJ9ZWxzZSBpZih0aGlzLmNvbnRyb2xsZXJOdW1iZXI9PT0xMjYpe3RoaXMuY2hhbm5lbE1vZGVNZXNzYWdlPVwibW9ub21vZGVvblwifWVsc2UgaWYodGhpcy5jb250cm9sbGVyTnVtYmVyPT09MTI3KXt0aGlzLmNoYW5uZWxNb2RlTWVzc2FnZT1cInBvbHltb2Rlb25cIn1icmVhaztjYXNlIDE5Mjp0aGlzLm1lc3NhZ2VUeXBlPVwicHJvZ3JhbWNoYW5nZVwiO3RoaXMucHJvZ3JhbT1lLmRhdGFbMV07YnJlYWs7Y2FzZSAyMDg6dGhpcy5tZXNzYWdlVHlwZT1cImNoYW5uZWxwcmVzc3VyZVwiO3RoaXMucHJlc3N1cmU9ZS5kYXRhWzFdJjEyNzticmVhaztjYXNlIDIyNDp0aGlzLm1lc3NhZ2VUeXBlPVwicGl0Y2hiZW5kY2hhbmdlXCI7dmFyIHQ9ZS5kYXRhWzJdJjEyNzt2YXIgcz1lLmRhdGFbMV0mMTI3O3RoaXMucGl0Y2hCZW5kPSh0PDw4KStzO2JyZWFrfX1yZXR1cm4gbmV3IHQoZSl9O3QuZXhwb3J0cz1zW1wiZGVmYXVsdFwiXX0se31dfSx7fSxbMV0pKDEpfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0L2luZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0J1xuXG4vLyB1dGlsXG5mdW5jdGlvbiBmaWxsU3RyIChzLCBudW0pIHsgcmV0dXJuIEFycmF5KG51bSArIDEpLmpvaW4ocykgfVxuZnVuY3Rpb24gaXNOdW0gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJyB9XG5mdW5jdGlvbiBpc1N0ciAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnIH1cbmZ1bmN0aW9uIGlzRGVmICh4KSB7IHJldHVybiB0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcgfVxuZnVuY3Rpb24gbWlkaVRvRnJlcSAobWlkaSwgdHVuaW5nKSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCAobWlkaSAtIDY5KSAvIDEyKSAqICh0dW5pbmcgfHwgNDQwKVxufVxuXG52YXIgUkVHRVggPSAvXihbYS1nQS1HXSkoI3sxLH18YnsxLH18eHsxLH18KSgtP1xcZCopXFxzKiguKilcXHMqJC9cbi8qKlxuICogQSByZWdleCBmb3IgbWF0Y2hpbmcgbm90ZSBzdHJpbmdzIGluIHNjaWVudGlmaWMgbm90YXRpb24uXG4gKlxuICogQG5hbWUgcmVnZXhcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7UmVnRXhwfSB0aGUgcmVnZXhwIHVzZWQgdG8gcGFyc2UgdGhlIG5vdGUgbmFtZVxuICpcbiAqIFRoZSBub3RlIHN0cmluZyBzaG91bGQgaGF2ZSB0aGUgZm9ybSBgbGV0dGVyW2FjY2lkZW50YWxzXVtvY3RhdmVdW2VsZW1lbnRdYFxuICogd2hlcmU6XG4gKlxuICogLSBsZXR0ZXI6IChSZXF1aXJlZCkgaXMgYSBsZXR0ZXIgZnJvbSBBIHRvIEcgZWl0aGVyIHVwcGVyIG9yIGxvd2VyIGNhc2VcbiAqIC0gYWNjaWRlbnRhbHM6IChPcHRpb25hbCkgY2FuIGJlIG9uZSBvciBtb3JlIGBiYCAoZmxhdHMpLCBgI2AgKHNoYXJwcykgb3IgYHhgIChkb3VibGUgc2hhcnBzKS5cbiAqIFRoZXkgY2FuIE5PVCBiZSBtaXhlZC5cbiAqIC0gb2N0YXZlOiAoT3B0aW9uYWwpIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlclxuICogLSBlbGVtZW50OiAoT3B0aW9uYWwpIGFkZGl0aW9uYWxseSBhbnl0aGluZyBhZnRlciB0aGUgZHVyYXRpb24gaXMgY29uc2lkZXJlZCB0b1xuICogYmUgdGhlIGVsZW1lbnQgbmFtZSAoZm9yIGV4YW1wbGU6ICdDMiBkb3JpYW4nKVxuICpcbiAqIFRoZSBleGVjdXRlZCByZWdleCBjb250YWlucyAoYnkgYXJyYXkgaW5kZXgpOlxuICpcbiAqIC0gMDogdGhlIGNvbXBsZXRlIHN0cmluZ1xuICogLSAxOiB0aGUgbm90ZSBsZXR0ZXJcbiAqIC0gMjogdGhlIG9wdGlvbmFsIGFjY2lkZW50YWxzXG4gKiAtIDM6IHRoZSBvcHRpb25hbCBvY3RhdmVcbiAqIC0gNDogdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyAodHJpbW1lZClcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHBhcnNlciA9IHJlcXVpcmUoJ25vdGUtcGFyc2VyJylcbiAqIHBhcnNlci5yZWdleC5leGVjKCdjIzQnKVxuICogLy8gPT4gWydjIzQnLCAnYycsICcjJywgJzQnLCAnJ11cbiAqIHBhcnNlci5yZWdleC5leGVjKCdjIzQgbWFqb3InKVxuICogLy8gPT4gWydjIzRtYWpvcicsICdjJywgJyMnLCAnNCcsICdtYWpvciddXG4gKiBwYXJzZXIucmVnZXgoKS5leGVjKCdDTWFqNycpXG4gKiAvLyA9PiBbJ0NNYWo3JywgJ0MnLCAnJywgJycsICdNYWo3J11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2V4ICgpIHsgcmV0dXJuIFJFR0VYIH1cblxudmFyIFNFTUlUT05FUyA9IFswLCAyLCA0LCA1LCA3LCA5LCAxMV1cbi8qKlxuICogUGFyc2UgYSBub3RlIG5hbWUgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBhbiByZXR1cm4gaXQncyBjb21wb25lbnRzLFxuICogYW5kIHNvbWUgbnVtZXJpYyBwcm9wZXJ0aWVzIGluY2x1ZGluZyBtaWRpIG51bWJlciBhbmQgZnJlcXVlbmN5LlxuICpcbiAqIEBuYW1lIHBhcnNlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBub3RlIC0gdGhlIG5vdGUgc3RyaW5nIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtCb29sZWFufSBpc1RvbmljIC0gdHJ1ZSB0aGUgc3RyaW5ncyBpdCdzIHN1cHBvc2VkIHRvIGNvbnRhaW4gYSBub3RlIG51bWJlclxuICogYW5kIHNvbWUgY2F0ZWdvcnkgKGZvciBleGFtcGxlIGFuIHNjYWxlOiAnQyMgbWFqb3InKS4gSXQncyBmYWxzZSBieSBkZWZhdWx0LFxuICogYnV0IHdoZW4gdHJ1ZSwgZW4gZXh0cmEgdG9uaWNPZiBwcm9wZXJ0eSBpcyByZXR1cm5lZCB3aXRoIHRoZSBjYXRlZ29yeSAoJ21ham9yJylcbiAqIEBwYXJhbSB7RmxvYXR9IHR1bm5pbmcgLSBUaGUgZnJlcXVlbmN5IG9mIEE0IG5vdGUgdG8gY2FsY3VsYXRlIGZyZXF1ZW5jaWVzLlxuICogQnkgZGVmYXVsdCBpdCA0NDAuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYXJzZWQgbm90ZSBuYW1lIG9yIG51bGwgaWYgbm90IGEgdmFsaWQgbm90ZVxuICpcbiAqIFRoZSBwYXJzZWQgbm90ZSBuYW1lIG9iamVjdCB3aWxsIEFMV0FZUyBjb250YWluczpcbiAqIC0gbGV0dGVyOiB0aGUgdXBwZXJjYXNlIGxldHRlciBvZiB0aGUgbm90ZVxuICogLSBhY2M6IHRoZSBhY2NpZGVudGFscyBvZiB0aGUgbm90ZSAob25seSBzaGFycHMgb3IgZmxhdHMpXG4gKiAtIHBjOiB0aGUgcGl0Y2ggY2xhc3MgKGxldHRlciArIGFjYylcbiAqIC0gc3RlcDogcyBhIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxldHRlci4gSXQncyBhbiBpbnRlZ2VyIGZyb20gMCB0byA2XG4gKiB3aGVyZSAwID0gQywgMSA9IEQgLi4uIDYgPSBCXG4gKiAtIGFsdDogYSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhY2NpZGVudGFscy4gMCBtZWFucyBubyBhbHRlcmF0aW9uLFxuICogcG9zaXRpdmUgbnVtYmVycyBhcmUgZm9yIHNoYXJwcyBhbmQgbmVnYXRpdmUgZm9yIGZsYXRzXG4gKiAtIGNocm9tYTogYSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwaXRjaCBjbGFzcy4gSXQncyBsaWtlIG1pZGkgZm9yXG4gKiBwaXRjaCBjbGFzc2VzLiAwID0gQywgMSA9IEMjLCAyID0gRCAuLi4gMTEgPSBCLiBDYW4gYmUgdXNlZCB0byBmaW5kIGVuaGFybW9uaWNzXG4gKiBzaW5jZSwgZm9yIGV4YW1wbGUsIGNocm9tYSBvZiAnQ2InIGFuZCAnQicgYXJlIGJvdGggMTFcbiAqXG4gKiBJZiB0aGUgbm90ZSBoYXMgb2N0YXZlLCB0aGUgcGFyc2VyIG9iamVjdCB3aWxsIGNvbnRhaW46XG4gKiAtIG9jdDogdGhlIG9jdGF2ZSBudW1iZXIgKGFzIGludGVnZXIpXG4gKiAtIG1pZGk6IHRoZSBtaWRpIG51bWJlclxuICogLSBmcmVxOiB0aGUgZnJlcXVlbmN5ICh1c2luZyB0dW5pbmcgcGFyYW1ldGVyIGFzIGJhc2UpXG4gKlxuICogSWYgdGhlIHBhcmFtZXRlciBgaXNUb25pY2AgaXMgc2V0IHRvIHRydWUsIHRoZSBwYXJzZWQgb2JqZWN0IHdpbGwgY29udGFpbjpcbiAqIC0gdG9uaWNPZjogdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB0aGF0IGZvbGxvd3Mgbm90ZSBuYW1lIChsZWZ0IGFuZCByaWdodCB0cmltbWVkKVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcGFyc2UgPSByZXF1aXJlKCdub3RlLXBhcnNlcicpLnBhcnNlXG4gKiBwYXJzZSgnQ2I0JylcbiAqIC8vID0+IHsgbGV0dGVyOiAnQycsIGFjYzogJ2InLCBwYzogJ0NiJywgc3RlcDogMCwgYWx0OiAtMSwgY2hyb21hOiAtMSxcbiAqICAgICAgICAgb2N0OiA0LCBtaWRpOiA1OSwgZnJlcTogMjQ2Ljk0MTY1MDYyODA2MjA2IH1cbiAqIC8vIGlmIG5vIG9jdGF2ZSwgbm8gbWlkaSwgbm8gZnJlcVxuICogcGFyc2UoJ2Z4JylcbiAqIC8vID0+IHsgbGV0dGVyOiAnRicsIGFjYzogJyMjJywgcGM6ICdGIyMnLCBzdGVwOiAzLCBhbHQ6IDIsIGNocm9tYTogNyB9KVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UgKHN0ciwgaXNUb25pYywgdHVuaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgcmV0dXJuIG51bGxcbiAgdmFyIG0gPSBSRUdFWC5leGVjKHN0cilcbiAgaWYgKCFtIHx8ICghaXNUb25pYyAmJiBtWzRdKSkgcmV0dXJuIG51bGxcblxuICB2YXIgcCA9IHsgbGV0dGVyOiBtWzFdLnRvVXBwZXJDYXNlKCksIGFjYzogbVsyXS5yZXBsYWNlKC94L2csICcjIycpIH1cbiAgcC5wYyA9IHAubGV0dGVyICsgcC5hY2NcbiAgcC5zdGVwID0gKHAubGV0dGVyLmNoYXJDb2RlQXQoMCkgKyAzKSAlIDdcbiAgcC5hbHQgPSBwLmFjY1swXSA9PT0gJ2InID8gLXAuYWNjLmxlbmd0aCA6IHAuYWNjLmxlbmd0aFxuICB2YXIgcG9zID0gU0VNSVRPTkVTW3Auc3RlcF0gKyBwLmFsdFxuICBwLmNocm9tYSA9IHBvcyA8IDAgPyAxMiArIHBvcyA6IHBvcyAlIDEyXG4gIGlmIChtWzNdKSB7IC8vIGhhcyBvY3RhdmVcbiAgICBwLm9jdCA9ICttWzNdXG4gICAgcC5taWRpID0gcG9zICsgMTIgKiAocC5vY3QgKyAxKVxuICAgIHAuZnJlcSA9IG1pZGlUb0ZyZXEocC5taWRpLCB0dW5pbmcpXG4gIH1cbiAgaWYgKGlzVG9uaWMpIHAudG9uaWNPZiA9IG1bNF1cbiAgcmV0dXJuIHBcbn1cblxudmFyIExFVFRFUlMgPSAnQ0RFRkdBQidcbmZ1bmN0aW9uIGFjY1N0ciAobikgeyByZXR1cm4gIWlzTnVtKG4pID8gJycgOiBuIDwgMCA/IGZpbGxTdHIoJ2InLCAtbikgOiBmaWxsU3RyKCcjJywgbikgfVxuZnVuY3Rpb24gb2N0U3RyIChuKSB7IHJldHVybiAhaXNOdW0obikgPyAnJyA6ICcnICsgbiB9XG5cbi8qKlxuICogQ3JlYXRlIGEgc3RyaW5nIGZyb20gYSBwYXJzZWQgb2JqZWN0IG9yIGBzdGVwLCBhbHRlcmF0aW9uLCBvY3RhdmVgIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgcGFyc2VkIGRhdGEgb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGEgbm90ZSBzdHJpbmcgb3IgbnVsbCBpZiBub3QgdmFsaWQgcGFyYW1ldGVyc1xuICogQHNpbmNlIDEuMlxuICogQGV4YW1wbGVcbiAqIHBhcnNlci5idWlsZChwYXJzZXIucGFyc2UoJ2NiMicpKSAvLyA9PiAnQ2IyJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBpdCBhY2NlcHRzIChzdGVwLCBhbHRlcmF0aW9uLCBvY3RhdmUpIHBhcmFtZXRlcnM6XG4gKiBwYXJzZXIuYnVpbGQoMykgLy8gPT4gJ0YnXG4gKiBwYXJzZXIuYnVpbGQoMywgLTEpIC8vID0+ICdGYidcbiAqIHBhcnNlci5idWlsZCgzLCAtMSwgNCkgLy8gPT4gJ0ZiNCdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkIChzLCBhLCBvKSB7XG4gIGlmIChzID09PSBudWxsIHx8IHR5cGVvZiBzID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGxcbiAgaWYgKHMuc3RlcCkgcmV0dXJuIGJ1aWxkKHMuc3RlcCwgcy5hbHQsIHMub2N0KVxuICBpZiAocyA8IDAgfHwgcyA+IDYpIHJldHVybiBudWxsXG4gIHJldHVybiBMRVRURVJTLmNoYXJBdChzKSArIGFjY1N0cihhKSArIG9jdFN0cihvKVxufVxuXG4vKipcbiAqIEdldCBtaWRpIG9mIGEgbm90ZVxuICpcbiAqIEBuYW1lIG1pZGlcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd8SW50ZWdlcn0gbm90ZSAtIHRoZSBub3RlIG5hbWUgb3IgbWlkaSBudW1iZXJcbiAqIEByZXR1cm4ge0ludGVnZXJ9IHRoZSBtaWRpIG51bWJlciBvZiB0aGUgbm90ZSBvciBudWxsIGlmIG5vdCBhIHZhbGlkIG5vdGVcbiAqIG9yIHRoZSBub3RlIGRvZXMgTk9UIGNvbnRhaW5zIG9jdGF2ZVxuICogQGV4YW1wbGVcbiAqIHZhciBwYXJzZXIgPSByZXF1aXJlKCdub3RlLXBhcnNlcicpXG4gKiBwYXJzZXIubWlkaSgnQTQnKSAvLyA9PiA2OVxuICogcGFyc2VyLm1pZGkoJ0EnKSAvLyA9PiBudWxsXG4gKiBAZXhhbXBsZVxuICogLy8gbWlkaSBudW1iZXJzIGFyZSBieXBhc3NlZCAoZXZlbiBhcyBzdHJpbmdzKVxuICogcGFyc2VyLm1pZGkoNjApIC8vID0+IDYwXG4gKiBwYXJzZXIubWlkaSgnNjAnKSAvLyA9PiA2MFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWlkaSAobm90ZSkge1xuICBpZiAoKGlzTnVtKG5vdGUpIHx8IGlzU3RyKG5vdGUpKSAmJiBub3RlID49IDAgJiYgbm90ZSA8IDEyOCkgcmV0dXJuICtub3RlXG4gIHZhciBwID0gcGFyc2Uobm90ZSlcbiAgcmV0dXJuIHAgJiYgaXNEZWYocC5taWRpKSA/IHAubWlkaSA6IG51bGxcbn1cblxuLyoqXG4gKiBHZXQgZnJlcSBvZiBhIG5vdGUgaW4gaGVydHpzIChpbiBhIHdlbGwgdGVtcGVyZWQgNDQwSHogQTQpXG4gKlxuICogQG5hbWUgZnJlcVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbm90ZSAtIHRoZSBub3RlIG5hbWUgb3Igbm90ZSBtaWRpIG51bWJlclxuICogQHBhcmFtIHtTdHJpbmd9IHR1bmluZyAtIChPcHRpb25hbCkgdGhlIEE0IGZyZXF1ZW5jeSAoNDQwIGJ5IGRlZmF1bHQpXG4gKiBAcmV0dXJuIHtGbG9hdH0gdGhlIGZyZXEgb2YgdGhlIG51bWJlciBpZiBoZXJ0enMgb3IgbnVsbCBpZiBub3QgdmFsaWQgbm90ZVxuICogQGV4YW1wbGVcbiAqIHZhciBwYXJzZXIgPSByZXF1aXJlKCdub3RlLXBhcnNlcicpXG4gKiBwYXJzZXIuZnJlcSgnQTQnKSAvLyA9PiA0NDBcbiAqIHBhcnNlci5mcmVxKCdBJykgLy8gPT4gbnVsbFxuICogQGV4YW1wbGVcbiAqIC8vIGNhbiBjaGFuZ2UgdHVuaW5nICg0NDAgYnkgZGVmYXVsdClcbiAqIHBhcnNlci5mcmVxKCdBNCcsIDQ0NCkgLy8gPT4gNDQ0XG4gKiBwYXJzZXIuZnJlcSgnQTMnLCA0NDQpIC8vID0+IDIyMlxuICogQGV4YW1wbGVcbiAqIC8vIGl0IGFjY2VwdHMgbWlkaSBudW1iZXJzIChhcyBudW1iZXJzIGFuZCBhcyBzdHJpbmdzKVxuICogcGFyc2VyLmZyZXEoNjkpIC8vID0+IDQ0MFxuICogcGFyc2VyLmZyZXEoJzY5JywgNDQyKSAvLyA9PiA0NDJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyZXEgKG5vdGUsIHR1bmluZykge1xuICB2YXIgbSA9IG1pZGkobm90ZSlcbiAgcmV0dXJuIG0gPT09IG51bGwgPyBudWxsIDogbWlkaVRvRnJlcShtLCB0dW5pbmcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXR0ZXIgKHNyYykgeyByZXR1cm4gKHBhcnNlKHNyYykgfHwge30pLmxldHRlciB9XG5leHBvcnQgZnVuY3Rpb24gYWNjIChzcmMpIHsgcmV0dXJuIChwYXJzZShzcmMpIHx8IHt9KS5hY2MgfVxuZXhwb3J0IGZ1bmN0aW9uIHBjIChzcmMpIHsgcmV0dXJuIChwYXJzZShzcmMpIHx8IHt9KS5wYyB9XG5leHBvcnQgZnVuY3Rpb24gc3RlcCAoc3JjKSB7IHJldHVybiAocGFyc2Uoc3JjKSB8fCB7fSkuc3RlcCB9XG5leHBvcnQgZnVuY3Rpb24gYWx0IChzcmMpIHsgcmV0dXJuIChwYXJzZShzcmMpIHx8IHt9KS5hbHQgfVxuZXhwb3J0IGZ1bmN0aW9uIGNocm9tYSAoc3JjKSB7IHJldHVybiAocGFyc2Uoc3JjKSB8fCB7fSkuY2hyb21hIH1cbmV4cG9ydCBmdW5jdGlvbiBvY3QgKHNyYykgeyByZXR1cm4gKHBhcnNlKHNyYykgfHwge30pLm9jdCB9XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBsaXN0ZW5lciBvZiBhbiBldmVudFxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gdGhlIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybiB7U2FtcGxlUGxheWVyfSB0aGUgcGxheWVyXG4gICAqIEBleGFtcGxlXG4gICAqIHBsYXllci5vbignc3RhcnQnLCBmdW5jdGlvbih0aW1lLCBub3RlKSB7XG4gICAqICAgY29uc29sZS5sb2codGltZSwgbm90ZSlcbiAgICogfSlcbiAgICovXG4gIHBsYXllci5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZXZlbnQgPT09ICdmdW5jdGlvbicpIHJldHVybiBwbGF5ZXIub24oJ2V2ZW50JywgZXZlbnQpXG4gICAgdmFyIHByb3AgPSAnb24nICsgZXZlbnRcbiAgICB2YXIgb2xkID0gcGxheWVyW3Byb3BdXG4gICAgcGxheWVyW3Byb3BdID0gb2xkID8gY2hhaW4ob2xkLCBjYikgOiBjYlxuICAgIHJldHVybiBwbGF5ZXJcbiAgfVxuICByZXR1cm4gcGxheWVyXG59XG5cbmZ1bmN0aW9uIGNoYWluIChmbjEsIGZuMikge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgZm4xKGEsIGIsIGMsIGQpOyBmbjIoYSwgYiwgYywgZCkgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBwbGF5ZXIgPSByZXF1aXJlKCcuL3BsYXllcicpXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKVxudmFyIG5vdGVzID0gcmVxdWlyZSgnLi9ub3RlcycpXG52YXIgc2NoZWR1bGVyID0gcmVxdWlyZSgnLi9zY2hlZHVsZXInKVxudmFyIG1pZGkgPSByZXF1aXJlKCcuL21pZGknKVxuXG5mdW5jdGlvbiBTYW1wbGVQbGF5ZXIgKGFjLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG1pZGkoc2NoZWR1bGVyKG5vdGVzKGV2ZW50cyhwbGF5ZXIoYWMsIHNvdXJjZSwgb3B0aW9ucykpKSkpXG59XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBTYW1wbGVQbGF5ZXJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgd2luZG93LlNhbXBsZVBsYXllciA9IFNhbXBsZVBsYXllclxuIiwidmFyIG1pZGltZXNzYWdlID0gcmVxdWlyZSgnbWlkaW1lc3NhZ2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgLyoqXG4gICogQ29ubmVjdCBhIHBsYXllciB0byBhIG1pZGkgaW5wdXRcbiAgKlxuICAqIFRoZSBvcHRpb25zIGFjY2VwdHM6XG4gICpcbiAgKiAtIGNoYW5uZWw6IHRoZSBjaGFubmVsIHRvIGxpc3RlbiB0by4gTGlzdGVuIHRvIGFsbCBjaGFubmVscyBieSBkZWZhdWx0LlxuICAqXG4gICogQHBhcmFtIHtNSURJSW5wdXR9IGlucHV0XG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSAoT3B0aW9uYWwpXG4gICogQHJldHVybiB7U2FtcGxlUGxheWVyfSB0aGUgcGxheWVyXG4gICogQGV4YW1wbGVcbiAgKiB2YXIgcGlhbm8gPSBwbGF5ZXIoLi4uKVxuICAqIHdpbmRvdy5uYXZpZ2F0b3IucmVxdWVzdE1JRElBY2Nlc3MoKS50aGVuKGZ1bmN0aW9uIChtaWRpQWNjZXNzKSB7XG4gICogICBtaWRpQWNjZXNzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChtaWRpSW5wdXQpIHtcbiAgKiAgICAgcGlhbm8ubGlzdGVuVG9NaWRpKG1pZGlJbnB1dClcbiAgKiAgIH0pXG4gICogfSlcbiAgKi9cbiAgcGxheWVyLmxpc3RlblRvTWlkaSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHZhciBzdGFydGVkID0ge31cbiAgICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgZ2FpbiA9IG9wdHMuZ2FpbiB8fCBmdW5jdGlvbiAodmVsKSB7IHJldHVybiB2ZWwgLyAxMjcgfVxuXG4gICAgaW5wdXQub25taWRpbWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIHZhciBtbSA9IG1zZy5tZXNzYWdlVHlwZSA/IG1zZyA6IG1pZGltZXNzYWdlKG1zZylcbiAgICAgIGlmIChtbS5tZXNzYWdlVHlwZSA9PT0gJ25vdGVvbicgJiYgbW0udmVsb2NpdHkgPT09IDApIHtcbiAgICAgICAgbW0ubWVzc2FnZVR5cGUgPSAnbm90ZW9mZidcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLmNoYW5uZWwgJiYgbW0uY2hhbm5lbCAhPT0gb3B0cy5jaGFubmVsKSByZXR1cm5cblxuICAgICAgc3dpdGNoIChtbS5tZXNzYWdlVHlwZSkge1xuICAgICAgICBjYXNlICdub3Rlb24nOlxuICAgICAgICAgIHN0YXJ0ZWRbbW0ua2V5XSA9IHBsYXllci5wbGF5KG1tLmtleSwgMCwgeyBnYWluOiBnYWluKG1tLnZlbG9jaXR5KSB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ25vdGVvZmYnOlxuICAgICAgICAgIGlmIChzdGFydGVkW21tLmtleV0pIHtcbiAgICAgICAgICAgIHN0YXJ0ZWRbbW0ua2V5XS5zdG9wKClcbiAgICAgICAgICAgIGRlbGV0ZSBzdGFydGVkW21tLmtleV1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBsYXllclxuICB9XG4gIHJldHVybiBwbGF5ZXJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbm90ZSA9IHJlcXVpcmUoJ25vdGUtcGFyc2VyJylcbnZhciBpc01pZGkgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbiAhPT0gbnVsbCAmJiBuICE9PSBbXSAmJiBuID49IDAgJiYgbiA8IDEyOSB9XG52YXIgdG9NaWRpID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGlzTWlkaShuKSA/ICtuIDogbm90ZS5taWRpKG4pIH1cblxuLy8gQWRkcyBub3RlIG5hbWUgdG8gbWlkaSBjb252ZXJzaW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgaWYgKHBsYXllci5idWZmZXJzKSB7XG4gICAgdmFyIG1hcCA9IHBsYXllci5vcHRzLm1hcFxuICAgIHZhciB0b0tleSA9IHR5cGVvZiBtYXAgPT09ICdmdW5jdGlvbicgPyBtYXAgOiB0b01pZGlcbiAgICB2YXIgbWFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lID8gdG9LZXkobmFtZSkgfHwgbmFtZSA6IG51bGxcbiAgICB9XG5cbiAgICBwbGF5ZXIuYnVmZmVycyA9IG1hcEJ1ZmZlcnMocGxheWVyLmJ1ZmZlcnMsIG1hcHBlcilcbiAgICB2YXIgc3RhcnQgPSBwbGF5ZXIuc3RhcnRcbiAgICBwbGF5ZXIuc3RhcnQgPSBmdW5jdGlvbiAobmFtZSwgd2hlbiwgb3B0aW9ucykge1xuICAgICAgdmFyIGtleSA9IG1hcHBlcihuYW1lKVxuICAgICAgdmFyIGRlYyA9IGtleSAlIDFcbiAgICAgIGlmIChkZWMpIHtcbiAgICAgICAga2V5ID0gTWF0aC5mbG9vcihrZXkpXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMgfHwge30sIHsgY2VudHM6IE1hdGguZmxvb3IoZGVjICogMTAwKSB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0KGtleSwgd2hlbiwgb3B0aW9ucylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBsYXllclxufVxuXG5mdW5jdGlvbiBtYXBCdWZmZXJzIChidWZmZXJzLCB0b0tleSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoYnVmZmVycykucmVkdWNlKGZ1bmN0aW9uIChtYXBwZWQsIG5hbWUpIHtcbiAgICBtYXBwZWRbdG9LZXkobmFtZSldID0gYnVmZmVyc1tuYW1lXVxuICAgIHJldHVybiBtYXBwZWRcbiAgfSwge30pXG59XG4iLCIvKiBnbG9iYWwgQXVkaW9CdWZmZXIgKi9cbid1c2Ugc3RyaWN0J1xuXG52YXIgQURTUiA9IHJlcXVpcmUoJ2Fkc3InKVxuXG52YXIgRU1QVFkgPSB7fVxudmFyIERFRkFVTFRTID0ge1xuICBnYWluOiAxLFxuICBhdHRhY2s6IDAuMDEsXG4gIGRlY2F5OiAwLjEsXG4gIHN1c3RhaW46IDAuOSxcbiAgcmVsZWFzZTogMC4zLFxuICBsb29wOiBmYWxzZSxcbiAgY2VudHM6IDAsXG4gIGxvb3BTdGFydDogMCxcbiAgbG9vcEVuZDogMFxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNhbXBsZSBwbGF5ZXIuXG4gKlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGFjIC0gdGhlIGF1ZGlvIGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8T2JqZWN0PFN0cmluZyxBcnJheUJ1ZmZlcj59IHNvdXJjZVxuICogQHBhcmFtIHtPbmplY3R9IG9wdGlvbnMgLSAoT3B0aW9uYWwpIGFuIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJuIHtwbGF5ZXJ9IHRoZSBwbGF5ZXJcbiAqIEBleGFtcGxlXG4gKiB2YXIgU2FtcGxlUGxheWVyID0gcmVxdWlyZSgnc2FtcGxlLXBsYXllcicpXG4gKiB2YXIgYWMgPSBuZXcgQXVkaW9Db250ZXh0KClcbiAqIHZhciBzbmFyZSA9IFNhbXBsZVBsYXllcihhYywgPEF1ZGlvQnVmZmVyPilcbiAqIHNuYXJlLnBsYXkoKVxuICovXG5mdW5jdGlvbiBTYW1wbGVQbGF5ZXIgKGFjLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbm5lY3RlZCA9IGZhbHNlXG4gIHZhciBuZXh0SWQgPSAwXG4gIHZhciB0cmFja2VkID0ge31cbiAgdmFyIG91dCA9IGFjLmNyZWF0ZUdhaW4oKVxuICBvdXQuZ2Fpbi52YWx1ZSA9IDFcblxuICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRTLCBvcHRpb25zKVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuICB2YXIgcGxheWVyID0geyBjb250ZXh0OiBhYywgb3V0OiBvdXQsIG9wdHM6IG9wdHMgfVxuICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXVkaW9CdWZmZXIpIHBsYXllci5idWZmZXIgPSBzb3VyY2VcbiAgZWxzZSBwbGF5ZXIuYnVmZmVycyA9IHNvdXJjZVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIHNhbXBsZSBidWZmZXIuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBvYmplY3QgaGFzIGEgZnVuY3Rpb24gYHN0b3Aod2hlbilgIHRvIHN0b3AgdGhlIHNvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBidWZmZXIuIElmIHRoZSBzb3VyY2Ugb2YgdGhlXG4gICAqIFNhbXBsZVBsYXllciBpcyBvbmUgc2FtcGxlIGJ1ZmZlciwgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHJlcXVpcmVkXG4gICAqIEBwYXJhbSB7RmxvYXR9IHdoZW4gLSAoT3B0aW9uYWwpIHdoZW4gdG8gc3RhcnQgKGN1cnJlbnQgdGltZSBpZiBieSBkZWZhdWx0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgc2FtcGxlIHBsYXlpbmcgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtBdWRpb05vZGV9IGFuIGF1ZGlvIG5vZGUgd2l0aCBhIGBzdG9wYCBmdW5jdGlvblxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgc2FtcGxlID0gcGxheWVyKGFjLCA8QXVkaW9CdWZmZXI+KS5jb25uZWN0KGFjLmRlc3RpbmF0aW9uKVxuICAgKiBzYW1wbGUuc3RhcnQoKVxuICAgKiBzYW1wbGUuc3RhcnQoNSwgeyBnYWluOiAwLjcgfSkgLy8gbmFtZSBub3QgcmVxdWlyZWQgc2luY2UgaXMgb25seSBvbmUgQXVkaW9CdWZmZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGRydW1zID0gcGxheWVyKGFjLCB7IHNuYXJlOiA8QXVkaW9CdWZmZXI+LCBraWNrOiA8QXVkaW9CdWZmZXI+LCAuLi4gfSkuY29ubmVjdChhYy5kZXN0aW5hdGlvbilcbiAgICogZHJ1bXMuc3RhcnQoJ3NuYXJlJylcbiAgICogZHJ1bXMuc3RhcnQoJ3NuYXJlJywgMCwgeyBnYWluOiAwLjMgfSlcbiAgICovXG4gIHBsYXllci5zdGFydCA9IGZ1bmN0aW9uIChuYW1lLCB3aGVuLCBvcHRpb25zKSB7XG4gICAgLy8gaWYgb25seSBvbmUgYnVmZmVyLCByZW9yZGVyIGFyZ3VtZW50c1xuICAgIGlmIChwbGF5ZXIuYnVmZmVyICYmIG5hbWUgIT09IG51bGwpIHJldHVybiBwbGF5ZXIuc3RhcnQobnVsbCwgbmFtZSwgd2hlbilcblxuICAgIHZhciBidWZmZXIgPSBuYW1lID8gcGxheWVyLmJ1ZmZlcnNbbmFtZV0gOiBwbGF5ZXIuYnVmZmVyXG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIGNvbnNvbGUud2FybignQnVmZmVyICcgKyBuYW1lICsgJyBub3QgZm91bmQuJylcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgY29uc29sZS53YXJuKCdTYW1wbGVQbGF5ZXIgbm90IGNvbm5lY3RlZCB0byBhbnkgbm9kZS4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IEVNUFRZXG4gICAgd2hlbiA9IE1hdGgubWF4KGFjLmN1cnJlbnRUaW1lLCB3aGVuIHx8IDApXG4gICAgcGxheWVyLmVtaXQoJ3N0YXJ0Jywgd2hlbiwgbmFtZSwgb3B0cylcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUobmFtZSwgYnVmZmVyLCBvcHRzKVxuICAgIG5vZGUuaWQgPSB0cmFjayhuYW1lLCBub2RlKVxuICAgIG5vZGUuZW52LnN0YXJ0KHdoZW4pXG4gICAgbm9kZS5zb3VyY2Uuc3RhcnQod2hlbilcbiAgICBwbGF5ZXIuZW1pdCgnc3RhcnRlZCcsIHdoZW4sIG5vZGUuaWQsIG5vZGUpXG4gICAgaWYgKG9wdHMuZHVyYXRpb24pIG5vZGUuc3RvcCh3aGVuICsgb3B0cy5kdXJhdGlvbilcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgLy8gTk9URTogc3RhcnQgd2lsbCBiZSBvdmVycmlkZSBzbyB3ZSBjYW4ndCBjb3B5IHRoZSBmdW5jdGlvbiByZWZlcmVuY2VcbiAgLy8gdGhpcyBpcyBvYnZpb3VzbHkgbm90IGEgZ29vZCBkZXNpZ24sIHNvIHRoaXMgY29kZSB3aWxsIGJlIGdvbmUgc29vbi5cbiAgLyoqXG4gICAqIEFuIGFsaWFzIGZvciBgcGxheWVyLnN0YXJ0YFxuICAgKiBAc2VlIHBsYXllci5zdGFydFxuICAgKiBAc2luY2UgMC4zLjBcbiAgICovXG4gIHBsYXllci5wbGF5ID0gZnVuY3Rpb24gKG5hbWUsIHdoZW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGxheWVyLnN0YXJ0KG5hbWUsIHdoZW4sIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU3RvcCBzb21lIG9yIGFsbCBzYW1wbGVzXG4gICAqXG4gICAqIEBwYXJhbSB7RmxvYXR9IHdoZW4gLSAoT3B0aW9uYWwpIGFuIGFic29sdXRlIHRpbWUgaW4gc2Vjb25kcyAob3IgY3VycmVudFRpbWVcbiAgICogaWYgbm90IHNwZWNpZmllZClcbiAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgLSAoT3B0aW9uYWwpIGFuIGFycmF5IG9mIG5vZGVzIG9yIG5vZGVzIGlkcyB0byBzdG9wXG4gICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBpZHMgb2YgdGhlIHN0b3BlZCBzYW1wbGVzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBsb25nU291bmQgPSBwbGF5ZXIoYWMsIDxBdWRpb0J1ZmZlcj4pLmNvbm5lY3QoYWMuZGVzdGluYXRpb24pXG4gICAqIGxvbmdTb3VuZC5zdGFydChhYy5jdXJyZW50VGltZSlcbiAgICogbG9uZ1NvdW5kLnN0YXJ0KGFjLmN1cnJlbnRUaW1lICsgMSlcbiAgICogbG9uZ1NvdW5kLnN0YXJ0KGFjLmN1cnJlbnRUaW1lICsgMilcbiAgICogbG9uZ1NvdW5kLnN0b3AoYWMuY3VycmVudFRpbWUgKyAzKSAvLyBzdG9wIHRoZSB0aHJlZSBzb3VuZHNcbiAgICovXG4gIHBsYXllci5zdG9wID0gZnVuY3Rpb24gKHdoZW4sIGlkcykge1xuICAgIHZhciBub2RlXG4gICAgaWRzID0gaWRzIHx8IE9iamVjdC5rZXlzKHRyYWNrZWQpXG4gICAgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICBub2RlID0gdHJhY2tlZFtpZF1cbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGxcbiAgICAgIG5vZGUuc3RvcCh3aGVuKVxuICAgICAgcmV0dXJuIG5vZGUuaWRcbiAgICB9KVxuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0IHRoZSBwbGF5ZXIgdG8gYSBkZXN0aW5hdGlvbiBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9Ob2RlfSBkZXN0aW5hdGlvbiAtIHRoZSBkZXN0aW5hdGlvbiBub2RlXG4gICAqIEByZXR1cm4ge0F1ZGlvUGxheWVyfSB0aGUgcGxheWVyXG4gICAqIEBjaGFpbmFibGVcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHNhbXBsZSA9IHBsYXllcihhYywgPEF1ZGlvQnVmZmVyPikuY29ubmVjdChhYy5kZXN0aW5hdGlvbilcbiAgICovXG4gIHBsYXllci5jb25uZWN0ID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICBjb25uZWN0ZWQgPSB0cnVlXG4gICAgb3V0LmNvbm5lY3QoZGVzdClcbiAgICByZXR1cm4gcGxheWVyXG4gIH1cblxuICBwbGF5ZXIuZW1pdCA9IGZ1bmN0aW9uIChldmVudCwgd2hlbiwgb2JqLCBvcHRzKSB7XG4gICAgaWYgKHBsYXllci5vbmV2ZW50KSBwbGF5ZXIub25ldmVudChldmVudCwgd2hlbiwgb2JqLCBvcHRzKVxuICAgIHZhciBmbiA9IHBsYXllclsnb24nICsgZXZlbnRdXG4gICAgaWYgKGZuKSBmbih3aGVuLCBvYmosIG9wdHMpXG4gIH1cblxuICByZXR1cm4gcGxheWVyXG5cbiAgLy8gPT09PT09PT09PT09PT09IFBSSVZBVEUgRlVOQ1RJT05TID09PT09PT09PT09PT09IC8vXG5cbiAgZnVuY3Rpb24gdHJhY2sgKG5hbWUsIG5vZGUpIHtcbiAgICBub2RlLmlkID0gbmV4dElkKytcbiAgICB0cmFja2VkW25vZGUuaWRdID0gbm9kZVxuICAgIG5vZGUuc291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbm93ID0gYWMuY3VycmVudFRpbWVcbiAgICAgIG5vZGUuc291cmNlLmRpc2Nvbm5lY3QoKVxuICAgICAgbm9kZS5lbnYuZGlzY29ubmVjdCgpXG4gICAgICBub2RlLmRpc2Nvbm5lY3QoKVxuICAgICAgcGxheWVyLmVtaXQoJ2VuZGVkJywgbm93LCBub2RlLmlkLCBub2RlKVxuICAgIH1cbiAgICByZXR1cm4gbm9kZS5pZFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZSAobmFtZSwgYnVmZmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBhYy5jcmVhdGVHYWluKClcbiAgICBub2RlLmdhaW4udmFsdWUgPSAwIC8vIHRoZSBlbnZlbG9wZSB3aWxsIGNvbnRyb2wgdGhlIGdhaW5cbiAgICBub2RlLmNvbm5lY3Qob3V0KVxuXG4gICAgbm9kZS5lbnYgPSBlbnZlbG9wZShhYywgb3B0aW9ucywgb3B0cylcbiAgICBub2RlLmVudi5jb25uZWN0KG5vZGUuZ2FpbilcblxuICAgIG5vZGUuc291cmNlID0gYWMuY3JlYXRlQnVmZmVyU291cmNlKClcbiAgICBub2RlLnNvdXJjZS5idWZmZXIgPSBidWZmZXJcbiAgICBub2RlLnNvdXJjZS5jb25uZWN0KG5vZGUpXG4gICAgbm9kZS5zb3VyY2UubG9vcCA9IG9wdGlvbnMubG9vcCB8fCBvcHRzLmxvb3BcbiAgICBub2RlLnNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBjZW50c1RvUmF0ZShvcHRpb25zLmNlbnRzIHx8IG9wdHMuY2VudHMpXG4gICAgbm9kZS5zb3VyY2UubG9vcFN0YXJ0ID0gb3B0aW9ucy5sb29wU3RhcnQgfHwgb3B0cy5sb29wU3RhcnRcbiAgICBub2RlLnNvdXJjZS5sb29wRW5kID0gb3B0aW9ucy5sb29wRW5kIHx8IG9wdHMubG9vcEVuZFxuICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICh3aGVuKSB7XG4gICAgICB2YXIgdGltZSA9IHdoZW4gfHwgYWMuY3VycmVudFRpbWVcbiAgICAgIHBsYXllci5lbWl0KCdzdG9wJywgdGltZSwgbmFtZSlcbiAgICAgIHZhciBzdG9wQXQgPSBub2RlLmVudi5zdG9wKHRpbWUpXG4gICAgICBub2RlLnNvdXJjZS5zdG9wKHN0b3BBdClcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBpc051bSAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInIH1cbnZhciBQQVJBTVMgPSBbJ2F0dGFjaycsICdkZWNheScsICdzdXN0YWluJywgJ3JlbGVhc2UnXVxuZnVuY3Rpb24gZW52ZWxvcGUgKGFjLCBvcHRpb25zLCBvcHRzKSB7XG4gIHZhciBlbnYgPSBBRFNSKGFjKVxuICB2YXIgYWRzciA9IG9wdGlvbnMuYWRzciB8fCBvcHRzLmFkc3JcbiAgUEFSQU1TLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgICBpZiAoYWRzcikgZW52W25hbWVdID0gYWRzcltpXVxuICAgIGVsc2UgZW52W25hbWVdID0gb3B0aW9uc1tuYW1lXSB8fCBvcHRzW25hbWVdXG4gIH0pXG4gIGVudi52YWx1ZS52YWx1ZSA9IGlzTnVtKG9wdGlvbnMuZ2FpbikgPyBvcHRpb25zLmdhaW5cbiAgICA6IGlzTnVtKG9wdHMuZ2FpbikgPyBvcHRzLmdhaW4gOiAxXG4gIHJldHVybiBlbnZcbn1cblxuLypcbiAqIEdldCBwbGF5YmFjayByYXRlIGZvciBhIGdpdmVuIHBpdGNoIGNoYW5nZSAoaW4gY2VudHMpXG4gKiBCYXNpYyBbbWF0aF0oaHR0cDovL3d3dy5iaXJkc29mdC5kZW1vbi5jby51ay9tdXNpYy9zYW1wbGVydC5odG0pOlxuICogZjIgPSBmMSAqIDJeKCBDIC8gMTIwMCApXG4gKi9cbmZ1bmN0aW9uIGNlbnRzVG9SYXRlIChjZW50cykgeyByZXR1cm4gY2VudHMgPyBNYXRoLnBvdygyLCBjZW50cyAvIDEyMDApIDogMSB9XG5cbm1vZHVsZS5leHBvcnRzID0gU2FtcGxlUGxheWVyXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGlzQXJyID0gQXJyYXkuaXNBcnJheVxudmFyIGlzT2JqID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnIH1cbnZhciBPUFRTID0ge31cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGxheWVyKSB7XG4gIC8qKlxuICAgKiBTY2hlZHVsZSBhIGxpc3Qgb2YgZXZlbnRzIHRvIGJlIHBsYXllZCBhdCBzcGVjaWZpYyB0aW1lLlxuICAgKlxuICAgKiBJdCBzdXBwb3J0cyB0aHJlZSBmb3JtYXRzIG9mIGV2ZW50cyBmb3IgdGhlIGV2ZW50cyBsaXN0OlxuICAgKlxuICAgKiAtIEFuIGFycmF5IHdpdGggW3RpbWUsIG5vdGVdXG4gICAqIC0gQW4gYXJyYXkgd2l0aCBbdGltZSwgb2JqZWN0XVxuICAgKiAtIEFuIG9iamVjdCB3aXRoIHsgdGltZTogPywgW25hbWV8bm90ZXxtaWRpfGtleV06ID8gfVxuICAgKlxuICAgKiBAcGFyYW0ge0Zsb2F0fSB0aW1lIC0gYW4gYWJzb2x1dGUgdGltZSB0byBzdGFydCAob3IgQXVkaW9Db250ZXh0J3NcbiAgICogY3VycmVudFRpbWUgaWYgcHJvdmlkZWQgbnVtYmVyIGlzIDApXG4gICAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50cyAtIHRoZSBldmVudHMgbGlzdC5cbiAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIGlkc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBFdmVudCBmb3JtYXQ6IFt0aW1lLCBub3RlXVxuICAgKiB2YXIgcGlhbm8gPSBwbGF5ZXIoYWMsIC4uLikuY29ubmVjdChhYy5kZXN0aW5hdGlvbilcbiAgICogcGlhbm8uc2NoZWR1bGUoMCwgWyBbMCwgJ0MyJ10sIFswLjUsICdDMyddLCBbMSwgJ0M0J10gXSlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRXZlbnQgZm9ybWF0OiBhbiBvYmplY3QgeyB0aW1lOiA/LCBuYW1lOiA/IH1cbiAgICogdmFyIGRydW1zID0gcGxheWVyKGFjLCAuLi4pLmNvbm5lY3QoYWMuZGVzdGluYXRpb24pXG4gICAqIGRydW1zLnNjaGVkdWxlKDAsIFtcbiAgICogICB7IG5hbWU6ICdraWNrJywgdGltZTogMCB9LFxuICAgKiAgIHsgbmFtZTogJ3NuYXJlJywgdGltZTogMC41IH0sXG4gICAqICAgeyBuYW1lOiAna2ljaycsIHRpbWU6IDEgfSxcbiAgICogICB7IG5hbWU6ICdzbmFyZScsIHRpbWU6IDEuNSB9XG4gICAqIF0pXG4gICAqL1xuICBwbGF5ZXIuc2NoZWR1bGUgPSBmdW5jdGlvbiAodGltZSwgZXZlbnRzKSB7XG4gICAgdmFyIG5vdyA9IHBsYXllci5jb250ZXh0LmN1cnJlbnRUaW1lXG4gICAgdmFyIHdoZW4gPSB0aW1lIDwgbm93ID8gbm93IDogdGltZVxuICAgIHBsYXllci5lbWl0KCdzY2hlZHVsZScsIHdoZW4sIGV2ZW50cylcbiAgICB2YXIgdCwgbywgbm90ZSwgb3B0c1xuICAgIHJldHVybiBldmVudHMubWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFldmVudCkgcmV0dXJuIG51bGxcbiAgICAgIGVsc2UgaWYgKGlzQXJyKGV2ZW50KSkge1xuICAgICAgICB0ID0gZXZlbnRbMF07IG8gPSBldmVudFsxXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGV2ZW50LnRpbWU7IG8gPSBldmVudFxuICAgICAgfVxuXG4gICAgICBpZiAoaXNPYmoobykpIHtcbiAgICAgICAgbm90ZSA9IG8ubmFtZSB8fCBvLmtleSB8fCBvLm5vdGUgfHwgby5taWRpIHx8IG51bGxcbiAgICAgICAgb3B0cyA9IG9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vdGUgPSBvXG4gICAgICAgIG9wdHMgPSBPUFRTXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwbGF5ZXIuc3RhcnQobm90ZSwgd2hlbiArICh0IHx8IDApLCBvcHRzKVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHBsYXllclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBSRUdFWCA9IC9eKFthLWdBLUddKSgjezEsfXxiezEsfXx4ezEsfXwpKC0/XFxkKilcXHMqKC4qKVxccyokL1xuLyoqXG4gKiBBIHJlZ2V4IGZvciBtYXRjaGluZyBub3RlIHN0cmluZ3MgaW4gc2NpZW50aWZpYyBub3RhdGlvbi5cbiAqXG4gKiBAbmFtZSByZWdleFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtSZWdFeHB9IHRoZSByZWdleHAgdXNlZCB0byBwYXJzZSB0aGUgbm90ZSBuYW1lXG4gKlxuICogVGhlIG5vdGUgc3RyaW5nIHNob3VsZCBoYXZlIHRoZSBmb3JtIGBsZXR0ZXJbYWNjaWRlbnRhbHNdW29jdGF2ZV1bZWxlbWVudF1gXG4gKiB3aGVyZTpcbiAqXG4gKiAtIGxldHRlcjogKFJlcXVpcmVkKSBpcyBhIGxldHRlciBmcm9tIEEgdG8gRyBlaXRoZXIgdXBwZXIgb3IgbG93ZXIgY2FzZVxuICogLSBhY2NpZGVudGFsczogKE9wdGlvbmFsKSBjYW4gYmUgb25lIG9yIG1vcmUgYGJgIChmbGF0cyksIGAjYCAoc2hhcnBzKSBvciBgeGAgKGRvdWJsZSBzaGFycHMpLlxuICogVGhleSBjYW4gTk9UIGJlIG1peGVkLlxuICogLSBvY3RhdmU6IChPcHRpb25hbCkgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyXG4gKiAtIGVsZW1lbnQ6IChPcHRpb25hbCkgYWRkaXRpb25hbGx5IGFueXRoaW5nIGFmdGVyIHRoZSBkdXJhdGlvbiBpcyBjb25zaWRlcmVkIHRvXG4gKiBiZSB0aGUgZWxlbWVudCBuYW1lIChmb3IgZXhhbXBsZTogJ0MyIGRvcmlhbicpXG4gKlxuICogVGhlIGV4ZWN1dGVkIHJlZ2V4IGNvbnRhaW5zIChieSBhcnJheSBpbmRleCk6XG4gKlxuICogLSAwOiB0aGUgY29tcGxldGUgc3RyaW5nXG4gKiAtIDE6IHRoZSBub3RlIGxldHRlclxuICogLSAyOiB0aGUgb3B0aW9uYWwgYWNjaWRlbnRhbHNcbiAqIC0gMzogdGhlIG9wdGlvbmFsIG9jdGF2ZVxuICogLSA0OiB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nICh0cmltbWVkKVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcGFyc2VyID0gcmVxdWlyZSgnbm90ZS1wYXJzZXInKVxuICogcGFyc2VyLnJlZ2V4LmV4ZWMoJ2MjNCcpXG4gKiAvLyA9PiBbJ2MjNCcsICdjJywgJyMnLCAnNCcsICcnXVxuICogcGFyc2VyLnJlZ2V4LmV4ZWMoJ2MjNCBtYWpvcicpXG4gKiAvLyA9PiBbJ2MjNG1ham9yJywgJ2MnLCAnIycsICc0JywgJ21ham9yJ11cbiAqIHBhcnNlci5yZWdleCgpLmV4ZWMoJ0NNYWo3JylcbiAqIC8vID0+IFsnQ01hajcnLCAnQycsICcnLCAnJywgJ01hajcnXVxuICovXG5mdW5jdGlvbiByZWdleCAoKSB7IHJldHVybiBSRUdFWCB9XG5cbnZhciBTRU1JVE9ORVMgPSBbMCwgMiwgNCwgNSwgNywgOSwgMTFdXG4vKipcbiAqIFBhcnNlIGEgbm90ZSBuYW1lIGluIHNjaWVudGlmaWMgbm90YXRpb24gYW4gcmV0dXJuIGl0J3MgY29tcG9uZW50cyxcbiAqIGFuZCBzb21lIG51bWVyaWMgcHJvcGVydGllcyBpbmNsdWRpbmcgbWlkaSBudW1iZXIgYW5kIGZyZXF1ZW5jeS5cbiAqXG4gKiBAbmFtZSBwYXJzZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbm90ZSAtIHRoZSBub3RlIHN0cmluZyB0byBiZSBwYXJzZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNUb25pYyAtIHRydWUgaWYgdGhlIG5vdGUgaXMgdGhlIHRvbmljIG9mIHNvbWV0aGluZy5cbiAqIElmIHRydWUsIGVuIGV4dHJhIHRvbmljT2YgcHJvcGVydHkgaXMgcmV0dXJuZWQuIEl0J3MgZmFsc2UgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB7RmxvYXR9IHR1bm5pbmcgLSBUaGUgZnJlcXVlbmN5IG9mIEE0IG5vdGUgdG8gY2FsY3VsYXRlIGZyZXF1ZW5jaWVzLlxuICogQnkgZGVmYXVsdCBpdCA0NDAuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYXJzZWQgbm90ZSBuYW1lIG9yIG51bGwgaWYgbm90IGEgdmFsaWQgbm90ZVxuICpcbiAqIFRoZSBwYXJzZWQgbm90ZSBuYW1lIG9iamVjdCB3aWxsIEFMV0FZUyBjb250YWluczpcbiAqIC0gbGV0dGVyOiB0aGUgdXBwZXJjYXNlIGxldHRlciBvZiB0aGUgbm90ZVxuICogLSBhY2M6IHRoZSBhY2NpZGVudGFscyBvZiB0aGUgbm90ZSAob25seSBzaGFycHMgb3IgZmxhdHMpXG4gKiAtIHBjOiB0aGUgcGl0Y2ggY2xhc3MgKGxldHRlciArIGFjYylcbiAqIC0gc3RlcDogcyBhIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxldHRlci4gSXQncyBhbiBpbnRlZ2VyIGZyb20gMCB0byA2XG4gKiB3aGVyZSAwID0gQywgMSA9IEQgLi4uIDYgPSBCXG4gKiAtIGFsdDogYSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhY2NpZGVudGFscy4gMCBtZWFucyBubyBhbHRlcmF0aW9uLFxuICogcG9zaXRpdmUgbnVtYmVycyBhcmUgZm9yIHNoYXJwcyBhbmQgbmVnYXRpdmUgZm9yIGZsYXRzXG4gKiAtIGNocm9tYTogYSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwaXRjaCBjbGFzcy4gSXQncyBsaWtlIG1pZGkgZm9yXG4gKiBwaXRjaCBjbGFzc2VzLiAwID0gQywgMSA9IEMjLCAyID0gRCAuLi4gSXQgY2FuIGhhdmUgbmVnYXRpdmUgdmFsdWVzOiAtMSA9IENiLlxuICogQ2FuIGRldGVjdCBwaXRjaCBjbGFzcyBlbmhyYW1vbmljcy5cbiAqXG4gKiBJZiB0aGUgbm90ZSBoYXMgb2N0YXZlLCB0aGUgcGFyc2VyIG9iamVjdCB3aWxsIGNvbnRhaW46XG4gKiAtIG9jdDogdGhlIG9jdGF2ZSBudW1iZXIgKGFzIGludGVnZXIpXG4gKiAtIG1pZGk6IHRoZSBtaWRpIG51bWJlclxuICogLSBmcmVxOiB0aGUgZnJlcXVlbmN5ICh1c2luZyB0dW5pbmcgcGFyYW1ldGVyIGFzIGJhc2UpXG4gKlxuICogSWYgdGhlIHBhcmFtZXRlciBgaXNUb25pY2AgaXMgc2V0IHRvIHRydWUsIHRoZSBwYXJzZWQgb2JqZWN0IHdpbGwgY29udGFpbjpcbiAqIC0gdG9uaWNPZjogdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB0aGF0IGZvbGxvd3Mgbm90ZSBuYW1lIChsZWZ0IGFuZCByaWdodCB0cmltbWVkKVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcGFyc2UgPSByZXF1aXJlKCdub3RlLXBhcnNlcicpLnBhcnNlXG4gKiBwYXJzZSgnQ2I0JylcbiAqIC8vID0+IHsgbGV0dGVyOiAnQycsIGFjYzogJ2InLCBwYzogJ0NiJywgc3RlcDogMCwgYWx0OiAtMSwgY2hyb21hOiAtMSxcbiAqICAgICAgICAgb2N0OiA0LCBtaWRpOiA1OSwgZnJlcTogMjQ2Ljk0MTY1MDYyODA2MjA2IH1cbiAqIC8vIGlmIG5vIG9jdGF2ZSwgbm8gbWlkaSwgbm8gZnJlcVxuICogcGFyc2UoJ2Z4JylcbiAqIC8vID0+IHsgbGV0dGVyOiAnRicsIGFjYzogJyMjJywgcGM6ICdGIyMnLCBzdGVwOiAzLCBhbHQ6IDIsIGNocm9tYTogNyB9KVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBpc1RvbmljLCB0dW5pbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSByZXR1cm4gbnVsbFxuICB2YXIgbSA9IFJFR0VYLmV4ZWMoc3RyKVxuICBpZiAoIW0gfHwgIWlzVG9uaWMgJiYgbVs0XSkgcmV0dXJuIG51bGxcblxuICB2YXIgcCA9IHsgbGV0dGVyOiBtWzFdLnRvVXBwZXJDYXNlKCksIGFjYzogbVsyXS5yZXBsYWNlKC94L2csICcjIycpIH1cbiAgcC5wYyA9IHAubGV0dGVyICsgcC5hY2NcbiAgcC5zdGVwID0gKHAubGV0dGVyLmNoYXJDb2RlQXQoMCkgKyAzKSAlIDdcbiAgcC5hbHQgPSBwLmFjY1swXSA9PT0gJ2InID8gLXAuYWNjLmxlbmd0aCA6IHAuYWNjLmxlbmd0aFxuICBwLmNocm9tYSA9IFNFTUlUT05FU1twLnN0ZXBdICsgcC5hbHRcbiAgaWYgKG1bM10pIHtcbiAgICBwLm9jdCA9ICttWzNdXG4gICAgcC5taWRpID0gcC5jaHJvbWEgKyAxMiAqIChwLm9jdCArIDEpXG4gICAgcC5mcmVxID0gbWlkaVRvRnJlcShwLm1pZGksIHR1bmluZylcbiAgfVxuICBpZiAoaXNUb25pYykgcC50b25pY09mID0gbVs0XVxuICByZXR1cm4gcFxufVxuXG4vKipcbiAqIEdpdmVuIGEgbWlkaSBudW1iZXIsIHJldHVybiBpdHMgZnJlcXVlbmN5XG4gKiBAcGFyYW0ge0ludGVnZXJ9IG1pZGkgLSBtaWRpIG5vdGUgbnVtYmVyXG4gKiBAcGFyYW0ge0Zsb2F0fSB0dW5pbmcgLSAoT3B0aW9uYWwpIHRoZSBBNCB0dW5pbmcgKDQ0MEh6IGJ5IGRlZmF1bHQpXG4gKiBAcmV0dXJuIHtGbG9hdH0gZnJlcXVlbmN5IGluIGhlcnR6c1xuICovXG5mdW5jdGlvbiBtaWRpVG9GcmVxIChtaWRpLCB0dW5pbmcpIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIChtaWRpIC0gNjkpIC8gMTIpICogKHR1bmluZyB8fCA0NDApXG59XG5cbnZhciBwYXJzZXIgPSB7IHBhcnNlOiBwYXJzZSwgcmVnZXg6IHJlZ2V4LCBtaWRpVG9GcmVxOiBtaWRpVG9GcmVxIH1cbnZhciBGTlMgPSBbJ2xldHRlcicsICdhY2MnLCAncGMnLCAnc3RlcCcsICdhbHQnLCAnY2hyb21hJywgJ29jdCcsICdtaWRpJywgJ2ZyZXEnXVxuRk5TLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcGFyc2VyW25hbWVdID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHZhciBwID0gcGFyc2Uoc3JjKVxuICAgIHJldHVybiBwICYmICh0eXBlb2YgcFtuYW1lXSAhPT0gJ3VuZGVmaW5lZCcpID8gcFtuYW1lXSA6IG51bGxcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZXJcblxuLy8gZXh0cmEgQVBJIGRvY3Ncbi8qKlxuICogR2V0IG1pZGkgb2YgYSBub3RlXG4gKlxuICogQG5hbWUgbWlkaVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbm90ZSAtIHRoZSBub3RlIG5hbWVcbiAqIEByZXR1cm4ge0ludGVnZXJ9IHRoZSBtaWRpIG51bWJlciBvZiB0aGUgbm90ZSBvciBudWxsIGlmIG5vdCBhIHZhbGlkIG5vdGVcbiAqIG9yIHRoZSBub3RlIGRvZXMgTk9UIGNvbnRhaW5zIG9jdGF2ZVxuICogQGV4YW1wbGVcbiAqIHZhciBwYXJzZXIgPSByZXF1aXJlKCdub3RlLXBhcnNlcicpXG4gKiBwYXJzZXIubWlkaSgnQTQnKSAvLyA9PiA2OVxuICogcGFyc2VyLm1pZGkoJ0EnKSAvLyA9PiBudWxsXG4gKi9cbi8qKlxuICogR2V0IGZyZXEgb2YgYSBub3RlIGluIGhlcnR6cyAoaW4gYSB3ZWxsIHRlbXBlcmVkIDQ0MEh6IEE0KVxuICpcbiAqIEBuYW1lIGZyZXFcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5vdGUgLSB0aGUgbm90ZSBuYW1lXG4gKiBAcmV0dXJuIHtGbG9hdH0gdGhlIGZyZXEgb2YgdGhlIG51bWJlciBpZiBoZXJ0enMgb3IgbnVsbCBpZiBub3QgdmFsaWQgbm90ZVxuICogb3IgdGhlIG5vdGUgZG9lcyBOT1QgY29udGFpbnMgb2N0YXZlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBhcnNlciA9IHJlcXVpcmUoJ25vdGUtcGFyc2VyJylcbiAqIHBhcnNlci5mcmVxKCdBNCcpIC8vID0+IDQ0MFxuICogcGFyc2VyLmZyZXEoJ0EnKSAvLyA9PiBudWxsXG4gKi9cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbG9hZCA9IHJlcXVpcmUoJ2F1ZGlvLWxvYWRlcicpXG52YXIgcGxheWVyID0gcmVxdWlyZSgnc2FtcGxlLXBsYXllcicpXG5cbi8qKlxuICogTG9hZCBhIHNvdW5kZm9udCBpbnN0cnVtZW50LiBJdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFcbiAqIGluc3RydW1lbnQgb2JqZWN0LlxuICpcbiAqIFRoZSBpbnN0cnVtZW50IG9iamVjdCByZXR1cm5lZCBieSB0aGUgcHJvbWlzZSBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gbmFtZTogdGhlIGluc3RydW1lbnQgbmFtZVxuICogLSBwbGF5OiBBIGZ1bmN0aW9uIHRvIHBsYXkgbm90ZXMgZnJvbSB0aGUgYnVmZmVyIHdpdGggdGhlIHNpZ25hdHVyZVxuICogYHBsYXkobm90ZSwgdGltZSwgZHVyYXRpb24sIG9wdGlvbnMpYFxuICpcbiAqXG4gKiBUaGUgdmFsaWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBgZm9ybWF0YDogdGhlIHNvdW5kZm9udCBmb3JtYXQuICdtcDMnIGJ5IGRlZmF1bHQuIENhbiBiZSAnb2dnJ1xuICogLSBgc291bmRmb250YDogdGhlIHNvdW5kZm9udCBuYW1lLiAnTXVzeW5nS2l0ZScgYnkgZGVmYXVsdC4gQ2FuIGJlICdGbHVpZFIzX0dNJ1xuICogLSBgbmFtZVRvVXJsYCA8RnVuY3Rpb24+OiBhIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbSBpbnN0cnVtZW50IG5hbWVzIHRvIFVSTFxuICogLSBgZGVzdGluYXRpb25gOiBieSBkZWZhdWx0IFNvdW5kZm9udCB1c2VzIHRoZSBgYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uYCBidXQgeW91IGNhbiBvdmVycmlkZSBpdC5cbiAqIC0gYGdhaW5gOiB0aGUgZ2FpbiBvZiB0aGUgcGxheWVyICgxIGJ5IGRlZmF1bHQpXG4gKiAtIGBub3Rlc2A6IGFuIGFycmF5IG9mIHRoZSBub3RlcyB0byBkZWNvZGUuIEl0IGNhbiBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXG4gKiB3aXRoIG5vdGUgbmFtZXMgb3IgYW4gYXJyYXkgb2YgbnVtYmVycyB3aXRoIG1pZGkgbm90ZSBudW1iZXJzLiBUaGlzIGlzIGFcbiAqIHBlcmZvcm1hbmNlIG9wdGlvbjogc2luY2UgZGVjb2RpbmcgbXAzIGlzIGEgY3B1IGludGVuc2l2ZSBwcm9jZXNzLCB5b3UgY2FuIGxpbWl0XG4gKiBsaW1pdCB0aGUgbnVtYmVyIG9mIG5vdGVzIHlvdSB3YW50IGFuZCByZWR1Y2UgdGhlIHRpbWUgdG8gbG9hZCB0aGUgaW5zdHJ1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gYWMgLSB0aGUgYXVkaW8gY29udGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgaW5zdHJ1bWVudCBuYW1lLiBGb3IgZXhhbXBsZTogJ2Fjb3VzdGljX2dyYW5kX3BpYW5vJ1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSAoT3B0aW9uYWwpIHRoZSBzYW1lIG9wdGlvbnMgYXMgU291bmRmb250LmxvYWRCdWZmZXJzXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgU291bmRmb250ID0gcmVxdWlyZSgnc291bmZvbnQtcGxheWVyJylcbiAqIFNvdW5kZm9udC5pbnN0cnVtZW50KCdtYXJpbWJhJykudGhlbihmdW5jdGlvbiAobWFyaW1iYSkge1xuICogICBtYXJpbWJhLnBsYXkoJ0M0JylcbiAqIH0pXG4gKi9cbmZ1bmN0aW9uIGluc3RydW1lbnQgKGFjLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gZnVuY3Rpb24gKG4sIG8pIHsgcmV0dXJuIGluc3RydW1lbnQoYWMsIG4sIG8pIH1cbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBpc1VybCA9IG9wdHMuaXNTb3VuZGZvbnRVUkwgfHwgaXNTb3VuZGZvbnRVUkxcbiAgdmFyIHRvVXJsID0gb3B0cy5uYW1lVG9VcmwgfHwgbmFtZVRvVXJsXG4gIHZhciB1cmwgPSBpc1VybChuYW1lKSA/IG5hbWUgOiB0b1VybChuYW1lLCBvcHRzLnNvdW5kZm9udCwgb3B0cy5mb3JtYXQpXG5cbiAgcmV0dXJuIGxvYWQoYWMsIHVybCwgeyBvbmx5OiBvcHRzLm9ubHkgfHwgb3B0cy5ub3RlcyB9KS50aGVuKGZ1bmN0aW9uIChidWZmZXJzKSB7XG4gICAgdmFyIHAgPSBwbGF5ZXIoYWMsIGJ1ZmZlcnMsIG9wdHMpLmNvbm5lY3Qob3B0cy5kZXN0aW5hdGlvbiA/IG9wdHMuZGVzdGluYXRpb24gOiBhYy5kZXN0aW5hdGlvbilcbiAgICBwLnVybCA9IHVybFxuICAgIHAubmFtZSA9IG5hbWVcbiAgICByZXR1cm4gcFxuICB9KVxufVxuXG5mdW5jdGlvbiBpc1NvdW5kZm9udFVSTCAobmFtZSkge1xuICByZXR1cm4gL1xcLmpzKFxcPy4qKT8kL2kudGVzdChuYW1lKVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGluc3RydW1lbnQgbmFtZSByZXR1cm5zIGEgVVJMIHRvIHRvIHRoZSBCZW5qYW1pbiBHbGVpdHptYW4nc1xuICogcGFja2FnZSBvZiBbcHJlLXJlbmRlcmVkIHNvdW5kIGZvbnRzXShodHRwczovL2dpdGh1Yi5jb20vZ2xlaXR6L21pZGktanMtc291bmRmb250cylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGluc3RydW1lbnQgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHNvdW5kZm9udCAtIChPcHRpb25hbCkgdGhlIHNvdW5kZm9udCBuYW1lLiBPbmUgb2YgJ0ZsdWlkUjNfR00nXG4gKiBvciAnTXVzeW5nS2l0ZScgKCdNdXN5bmdLaXRlJyBieSBkZWZhdWx0KVxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCAtIChPcHRpb25hbCkgQ2FuIGJlICdtcDMnIG9yICdvZ2cnIChtcDMgYnkgZGVmYXVsdClcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBTb3VuZGZvbnQgZmlsZSB1cmxcbiAqIEBleGFtcGxlXG4gKiB2YXIgU291bmRmb250ID0gcmVxdWlyZSgnc291bmRmb250LXBsYXllcicpXG4gKiBTb3VuZGZvbnQubmFtZVRvVXJsKCdtYXJpbWJhJywgJ21wMycpXG4gKi9cbmZ1bmN0aW9uIG5hbWVUb1VybCAobmFtZSwgc2YsIGZvcm1hdCkge1xuICBmb3JtYXQgPSBmb3JtYXQgPT09ICdvZ2cnID8gZm9ybWF0IDogJ21wMydcbiAgc2YgPSBzZiA9PT0gJ0ZsdWlkUjNfR00nID8gc2YgOiAnTXVzeW5nS2l0ZSdcbiAgcmV0dXJuICdodHRwczovL2dsZWl0ei5naXRodWIuaW8vbWlkaS1qcy1zb3VuZGZvbnRzLycgKyBzZiArICcvJyArIG5hbWUgKyAnLScgKyBmb3JtYXQgKyAnLmpzJ1xufVxuXG4vLyBJbiB0aGUgMS4wLjAgcmVsZWFzZSBpdCB3aWxsIGJlOlxuLy8gdmFyIFNvdW5kZm9udCA9IHt9XG52YXIgU291bmRmb250ID0gcmVxdWlyZSgnLi9sZWdhY3knKVxuU291bmRmb250Lmluc3RydW1lbnQgPSBpbnN0cnVtZW50XG5Tb3VuZGZvbnQubmFtZVRvVXJsID0gbmFtZVRvVXJsXG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBTb3VuZGZvbnRcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgd2luZG93LlNvdW5kZm9udCA9IFNvdW5kZm9udFxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdub3RlLXBhcnNlcicpXG5cbi8qKlxuICogQ3JlYXRlIGEgU291bmRmb250IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gdGhlIFthdWRpbyBjb250ZXh0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmFtZVRvVXJsIC0gKE9wdGlvbmFsKSBhIGZ1bmN0aW9uIHRoYXQgbWFwcyB0aGUgc291bmQgZm9udCBuYW1lIHRvIHRoZSB1cmxcbiAqIEByZXR1cm4ge1NvdW5kZm9udH0gYSBzb3VuZGZvbnQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIFNvdW5kZm9udCAoY3R4LCBuYW1lVG9VcmwpIHtcbiAgY29uc29sZS53YXJuKCduZXcgU291bmRmb250KCkgaXMgZGVwcmVjdGVkJylcbiAgY29uc29sZS5sb2coJ1BsZWFzZSB1c2UgU291bmRmb250Lmluc3RydW1lbnQoKSBpbnN0ZWFkIG9mIG5ldyBTb3VuZGZvbnQoKS5pbnN0cnVtZW50KCknKVxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU291bmRmb250KSkgcmV0dXJuIG5ldyBTb3VuZGZvbnQoY3R4KVxuXG4gIHRoaXMubmFtZVRvVXJsID0gbmFtZVRvVXJsIHx8IFNvdW5kZm9udC5uYW1lVG9VcmxcbiAgdGhpcy5jdHggPSBjdHhcbiAgdGhpcy5pbnN0cnVtZW50cyA9IHt9XG4gIHRoaXMucHJvbWlzZXMgPSBbXVxufVxuXG5Tb3VuZGZvbnQucHJvdG90eXBlLm9ucmVhZHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgY29uc29sZS53YXJuKCdkZXByZWNhdGVkIEFQSScpXG4gIGNvbnNvbGUubG9nKCdQbGVhc2UgdXNlIFByb21pc2UuYWxsKFNvdW5kZm9udC5pbnN0cnVtZW50KCksIFNvdW5kZm9udC5pbnN0cnVtZW50KCkpLnRoZW4oKSBpbnN0ZWFkIG9mIG5ldyBTb3VuZGZvbnQoKS5vbnJlYWR5KCknKVxuICBQcm9taXNlLmFsbCh0aGlzLnByb21pc2VzKS50aGVuKGNhbGxiYWNrKVxufVxuXG5Tb3VuZGZvbnQucHJvdG90eXBlLmluc3RydW1lbnQgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICBjb25zb2xlLndhcm4oJ25ldyBTb3VuZGZvbnQoKS5pbnN0cnVtZW50KCkgaXMgZGVwcmVjYXRlZC4nKVxuICBjb25zb2xlLmxvZygnUGxlYXNlIHVzZSBTb3VuZGZvbnQuaW5zdHJ1bWVudCgpIGluc3RlYWQuJylcbiAgdmFyIGN0eCA9IHRoaXMuY3R4XG4gIG5hbWUgPSBuYW1lIHx8ICdkZWZhdWx0J1xuICBpZiAobmFtZSBpbiB0aGlzLmluc3RydW1lbnRzKSByZXR1cm4gdGhpcy5pbnN0cnVtZW50c1tuYW1lXVxuICB2YXIgaW5zdCA9IHtuYW1lOiBuYW1lLCBwbGF5OiBvc2NpbGxhdG9yUGxheWVyKGN0eCwgb3B0aW9ucyl9XG4gIHRoaXMuaW5zdHJ1bWVudHNbbmFtZV0gPSBpbnN0XG4gIGlmIChuYW1lICE9PSAnZGVmYXVsdCcpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFNvdW5kZm9udC5pbnN0cnVtZW50KGN0eCwgbmFtZSwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAoaW5zdHJ1bWVudCkge1xuICAgICAgaW5zdC5wbGF5ID0gaW5zdHJ1bWVudC5wbGF5XG4gICAgICByZXR1cm4gaW5zdFxuICAgIH0pXG4gICAgdGhpcy5wcm9taXNlcy5wdXNoKHByb21pc2UpXG4gICAgaW5zdC5vbnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ29ucmVhZHkgaXMgZGVwcmVjYXRlZC4gVXNlIFNvdW5kZm9udC5pbnN0cnVtZW50KCkudGhlbigpJylcbiAgICAgIHByb21pc2UudGhlbihjYilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5zdC5vbnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ29ucmVhZHkgaXMgZGVwcmVjYXRlZC4gVXNlIFNvdW5kZm9udC5pbnN0cnVtZW50KCkudGhlbigpJylcbiAgICAgIGNiKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluc3Rcbn1cblxuLypcbiAqIExvYWQgdGhlIGJ1ZmZlcnMgb2YgYSBnaXZlbiBpbnN0cnVtZW50IG5hbWUuIEl0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXNcbiAqIHRvIGEgaGFzaCB3aXRoIG1pZGkgbm90ZSBudW1iZXJzIGFzIGtleXMsIGFuZCBhdWRpbyBidWZmZXJzIGFzIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gYWMgLSB0aGUgYXVkaW8gY29udGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgaW5zdHJ1bWVudCBuYW1lIChpdCBhY2NlcHRzIGFuIHVybCBpZiBzdGFydHMgd2l0aCBcImh0dHBcIilcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gKE9wdGlvbmFsKSBvcHRpb25zIG9iamVjdFxuICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBIYXNoIG9mIHsgbWlkaU5vdGVOdW06IDxBdWRpb0J1ZmZlcj4gfVxuICpcbiAqIFRoZSBvcHRpb25zIG9iamVjdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqXG4gKiAtIG5hbWVUb1VybCB7RnVuY3Rpb259OiBhIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbSBpbnN0cnVtZW50IG5hbWVzIHRvIHVybHMuXG4gKiBCeSBkZWZhdWx0IGl0IHVzZXMgQmVuamFtaW4gR2xlaXR6bWFuJ3MgcGFja2FnZSBvZlxuICogW3ByZS1yZW5kZXJlZCBzb3VuZCBmb250c10oaHR0cHM6Ly9naXRodWIuY29tL2dsZWl0ei9taWRpLWpzLXNvdW5kZm9udHMpXG4gKiAtIG5vdGVzIHtBcnJheX06IHRoZSBsaXN0IG9mIG5vdGUgbmFtZXMgdG8gYmUgZGVjb2RlZCAoYWxsIGJ5IGRlZmF1bHQpXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBTb3VuZGZvbnQgPSByZXF1aXJlKCdzb3VuZGZvbnQtcGxheWVyJylcbiAqIFNvdW5kZm9udC5sb2FkQnVmZmVycyhjdHgsICdhY291c3RpY19ncmFuZF9waWFubycpLnRoZW4oZnVuY3Rpb24oYnVmZmVycykge1xuICogIGJ1ZmZlcnNbNjBdIC8vID0+IEFuIDxBdWRpb0J1ZmZlcj4gY29ycmVzcG9uZGluZyB0byBub3RlIEM0XG4gKiB9KVxuICovXG5mdW5jdGlvbiBsb2FkQnVmZmVycyAoYWMsIG5hbWUsIG9wdGlvbnMpIHtcbiAgY29uc29sZS53YXJuKCdTb3VuZGZvbnQubG9hZEJ1ZmZlcnMgaXMgZGVwcmVjYXRlLicpXG4gIGNvbnNvbGUubG9nKCdVc2UgU291bmRmb250Lmluc3RydW1lbnQoLi4pIGFuZCBnZXQgYnVmZmVycyBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlc3VsdC4nKVxuICByZXR1cm4gU291bmRmb250Lmluc3RydW1lbnQoYWMsIG5hbWUsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdC5idWZmZXJzXG4gIH0pXG59XG5Tb3VuZGZvbnQubG9hZEJ1ZmZlcnMgPSBsb2FkQnVmZmVyc1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHBsYXlzIGFuIG9zY2lsbGF0b3JcbiAqXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gYWMgLSB0aGUgYXVkaW8gY29udGV4dFxuICogQHBhcmFtIHtIYXNofSBkZWZhdWx0T3B0aW9ucyAtIChPcHRpb25hbCkgYSBoYXNoIG9mIG9wdGlvbnM6XG4gKiAtIHZjb1R5cGU6IHRoZSBvc2NpbGxhdG9yIHR5cGUgKGRlZmF1bHQ6ICdzaW5lJylcbiAqIC0gZ2FpbjogdGhlIG91dHB1dCBnYWluIHZhbHVlIChkZWZhdWx0OiAwLjQpXG4gICogLSBkZXN0aW5hdGlvbjogdGhlIHBsYXllciBkZXN0aW5hdGlvbiAoZGVmYXVsdDogYWMuZGVzdGluYXRpb24pXG4gKi9cbmZ1bmN0aW9uIG9zY2lsbGF0b3JQbGF5ZXIgKGN0eCwgZGVmYXVsdE9wdGlvbnMpIHtcbiAgZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyB8fCB7fVxuICByZXR1cm4gZnVuY3Rpb24gKG5vdGUsIHRpbWUsIGR1cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc29sZS53YXJuKCdUaGUgb3NjaWxsYXRvciBwbGF5ZXIgaXMgZGVwcmVjYXRlZC4nKVxuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyB3aXRoIHZlcnNpb24gMC45LjAgeW91IHdpbGwgaGF2ZSB0byB3YWl0IHVudGlsIHRoZSBzb3VuZGZvbnQgaXMgbG9hZGVkIHRvIHBsYXkgc291bmRzLicpXG4gICAgdmFyIG1pZGkgPSBub3RlID4gMCAmJiBub3RlIDwgMTI5ID8gK25vdGUgOiBwYXJzZXIubWlkaShub3RlKVxuICAgIHZhciBmcmVxID0gbWlkaSA/IHBhcnNlci5taWRpVG9GcmVxKG1pZGksIDQ0MCkgOiBudWxsXG4gICAgaWYgKCFmcmVxKSByZXR1cm5cblxuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yXG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBkZXN0aW5hdGlvbiA9IG9wdGlvbnMuZGVzdGluYXRpb24gfHwgZGVmYXVsdE9wdGlvbnMuZGVzdGluYXRpb24gfHwgY3R4LmRlc3RpbmF0aW9uXG4gICAgdmFyIHZjb1R5cGUgPSBvcHRpb25zLnZjb1R5cGUgfHwgZGVmYXVsdE9wdGlvbnMudmNvVHlwZSB8fCAnc2luZSdcbiAgICB2YXIgZ2FpbiA9IG9wdGlvbnMuZ2FpbiB8fCBkZWZhdWx0T3B0aW9ucy5nYWluIHx8IDAuNFxuXG4gICAgdmFyIHZjbyA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKClcbiAgICB2Y28udHlwZSA9IHZjb1R5cGVcbiAgICB2Y28uZnJlcXVlbmN5LnZhbHVlID0gZnJlcVxuXG4gICAgLyogVkNBICovXG4gICAgdmFyIHZjYSA9IGN0eC5jcmVhdGVHYWluKClcbiAgICB2Y2EuZ2Fpbi52YWx1ZSA9IGdhaW5cblxuICAgIC8qIENvbm5lY3Rpb25zICovXG4gICAgdmNvLmNvbm5lY3QodmNhKVxuICAgIHZjYS5jb25uZWN0KGRlc3RpbmF0aW9uKVxuXG4gICAgdmNvLnN0YXJ0KHRpbWUpXG4gICAgaWYgKGR1cmF0aW9uID4gMCkgdmNvLnN0b3AodGltZSArIGR1cmF0aW9uKVxuICAgIHJldHVybiB2Y29cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgbm90ZSBuYW1lLCByZXR1cm4gdGhlIG5vdGUgbWlkaSBudW1iZXJcbiAqXG4gKiBAbmFtZSBub3RlVG9NaWRpXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBub3RlTmFtZVxuICogQHJldHVybiB7SW50ZWdlcn0gdGhlIG5vdGUgbWlkaSBudW1iZXIgb3IgbnVsbCBpZiBub3QgYSB2YWxpZCBub3RlIG5hbWVcbiAqL1xuU291bmRmb250Lm5vdGVUb01pZGkgPSBwYXJzZXIubWlkaVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNvdW5kZm9udFxuIiwiLyoqXG4gKiBbIVtucG0gdmVyc2lvbl0oaHR0cHM6Ly9pbWcuc2hpZWxkcy5pby9ucG0vdi90b25hbC1hcnJheS5zdmc/c3R5bGU9ZmxhdC1zcXVhcmUpXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS90b25hbC1hcnJheSlcbiAqXG4gKiBUb25hbCBhcnJheSB1dGlsaXRpZXMuIENyZWF0ZSByYW5nZXMsIHNvcnQgbm90ZXMsIC4uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBBcnJheTtcbiAqIEFycmF5LnNvcnQoW1wiZlwiLCBcImFcIiwgXCJjXCJdKSAvLyA9PiBbXCJDXCIsIFwiRlwiLCBcIkFcIl1cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgQXJyYXkgPSByZXF1aXJlKFwidG9uYWwtYXJyYXlcIilcbiAqIEFycmF5LnJhbmdlKDEsIDQpIC8vID0+IFsxLCAyLCAzLCA0XVxuICpcbiAqIEBtb2R1bGUgQXJyYXlcbiAqL1xuaW1wb3J0IHsgcHJvcHMsIG5hbWUgfSBmcm9tIFwidG9uYWwtbm90ZVwiO1xuXG4vLyBhc2NlbmRpbmcgcmFuZ2VcbmZ1bmN0aW9uIGFzY1IoYiwgbikge1xuICBmb3IgKHZhciBhID0gW107IG4tLTsgYVtuXSA9IG4gKyBiKXsgOyB9XG4gIHJldHVybiBhO1xufVxuLy8gZGVzY2VuZGluZyByYW5nZVxuZnVuY3Rpb24gZGVzY1IoYiwgbikge1xuICBmb3IgKHZhciBhID0gW107IG4tLTsgYVtuXSA9IGIgLSBuKXsgOyB9XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG51bWVyaWMgcmFuZ2VcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZnJvbVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqXG4gKiBAZXhhbXBsZVxuICogQXJyYXkucmFuZ2UoLTIsIDIpIC8vID0+IFstMiwgLTEsIDAsIDEsIDJdXG4gKiBBcnJheS5yYW5nZSgyLCAtMikgLy8gPT4gWzIsIDEsIDAsIC0xLCAtMl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbFxuICAgID8gW11cbiAgICA6IGEgPCBiXG4gICAgICA/IGFzY1IoYSwgYiAtIGEgKyAxKVxuICAgICAgOiBkZXNjUihhLCBhIC0gYiArIDEpO1xufVxuLyoqXG4gKlxuICogUm90YXRlcyBhIGxpc3QgYSBudW1iZXIgb2YgdGltZXMuIEl0XCJzIGNvbXBsZXRseSBhZ25vc3RpYyBhYm91dCB0aGVcbiAqIGNvbnRlbnRzIG9mIHRoZSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7SW50ZWdlcn0gdGltZXMgLSB0aGUgbnVtYmVyIG9mIHJvdGF0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgcm90YXRlZCBhcnJheVxuICogQGV4YW1wbGVcbiAqIEFycmF5LnJvdGF0ZSgxLCBbMSwgMiwgM10pIC8vID0+IFsyLCAzLCAxXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKHRpbWVzLCBhcnIpIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBuID0gKCh0aW1lcyAlIGxlbikgKyBsZW4pICUgbGVuO1xuICByZXR1cm4gYXJyLnNsaWNlKG4sIGxlbikuY29uY2F0KGFyci5zbGljZSgwLCBuKSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgYXJyYXkgd2l0aCB0aGUgbnVsbCB2YWx1ZXMgcmVtb3ZlZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHJldHVybiB7QXJyYXl9XG4gKlxuICogQGV4YW1wbGVcbiAqIEFycmF5LmNvbXBhY3QoW1wiYVwiLCBcImJcIiwgbnVsbCwgXCJjXCJdKSAvLyA9PiBbXCJhXCIsIFwiYlwiLCBcImNcIl1cbiAqL1xuZXhwb3J0IHZhciBjb21wYWN0ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAobikgeyByZXR1cm4gbiA9PT0gMCB8fCBuOyB9KTsgfTtcblxuLy8gYSBmdW5jdGlvbiB0aGF0IGdldCBub3RlIGhlaWdodHMgKHdpdGggbmVnYXRpdmUgbnVtYmVyIGZvciBwaXRjaCBjbGFzc2VzKVxudmFyIGhlaWdodCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBtID0gcHJvcHMobmFtZSkubWlkaTtcbiAgcmV0dXJuIG0gIT09IG51bGwgPyBtIDogcHJvcHMobmFtZSArIFwiLTEwMFwiKS5taWRpO1xufTtcblxuLyoqXG4gKiBTb3J0IGFuIGFycmF5IG9mIG5vdGVzIGluIGFzY2VuZGluZyBvcmRlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBub3Rlc1xuICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBhcnJheSBvZiBub3Rlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydChzcmMpIHtcbiAgcmV0dXJuIGNvbXBhY3Qoc3JjLm1hcChuYW1lKSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gaGVpZ2h0KGEpID4gaGVpZ2h0KGIpOyB9KTtcbn1cblxuLyoqXG4gKiBHZXQgc29ydGVkIG5vdGVzIHdpdGggZHVwbGljYXRlcyByZW1vdmVkXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBub3Rlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW5pcXVlKGFycikge1xuICByZXR1cm4gc29ydChhcnIpLmZpbHRlcihmdW5jdGlvbiAobiwgaSwgYSkgeyByZXR1cm4gaSA9PT0gMCB8fCBuICE9PSBhW2kgLSAxXTsgfSk7XG59XG5cbi8qKlxuICogUmFuZG9taXplcyB0aGUgb3JkZXIgb2YgdGhlIHNwZWNpZmllZCBhcnJheSBpbi1wbGFjZSwgdXNpbmcgdGhlIEZpc2hlcuKAk1lhdGVzIHNodWZmbGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFyciAtIHRoZSBhcnJheVxuICogQHJldHVybiB7QXJyYXl9IHRoZSBzaHVmZmxlZCBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBBcnJheS5zaHVmZmxlKFtcIkNcIiwgXCJEXCIsIFwiRVwiLCBcIkZcIl0pXG4gKi9cbmV4cG9ydCB2YXIgc2h1ZmZsZSA9IGZ1bmN0aW9uIChhcnIsIHJuZCkge1xuICBpZiAoIHJuZCA9PT0gdm9pZCAwICkgcm5kID0gTWF0aC5yYW5kb207XG5cbiAgdmFyIGksIHQ7XG4gIHZhciBtID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gKHJuZCgpICogbS0tKSB8IDA7XG4gICAgdCA9IGFyclttXTtcbiAgICBhcnJbbV0gPSBhcnJbaV07XG4gICAgYXJyW2ldID0gdDtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBHZXQgYWxsIHBlcm11dGF0aW9ucyBvZiBhbiBhcnJheVxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85OTYwOTA4L3Blcm11dGF0aW9ucy1pbi1qYXZhc2NyaXB0XG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5Pn0gYW4gYXJyYXkgd2l0aCBhbGwgdGhlIHBlcm11dGF0aW9uc1xuICovXG5leHBvcnQgdmFyIHBlcm11dGF0aW9ucyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHsgcmV0dXJuIFtbXV07IH1cbiAgcmV0dXJuIHBlcm11dGF0aW9ucyhhcnIuc2xpY2UoMSkpLnJlZHVjZShmdW5jdGlvbihhY2MsIHBlcm0pIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChcbiAgICAgIGFyci5tYXAoZnVuY3Rpb24oZSwgcG9zKSB7XG4gICAgICAgIHZhciBuZXdQZXJtID0gcGVybS5zbGljZSgpO1xuICAgICAgICBuZXdQZXJtLnNwbGljZShwb3MsIDAsIGFyclswXSk7XG4gICAgICAgIHJldHVybiBuZXdQZXJtO1xuICAgICAgfSlcbiAgICApO1xuICB9LCBbXSk7XG59O1xuIiwiLyoqXG4gKiBbIVtucG0gdmVyc2lvbl0oaHR0cHM6Ly9pbWcuc2hpZWxkcy5pby9ucG0vdi90b25hbC1jaG9yZC5zdmcpXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS90b25hbC1jaG9yZClcbiAqIFshW3RvbmFsXShodHRwczovL2ltZy5zaGllbGRzLmlvL2JhZGdlL3RvbmFsLWNob3JkLXllbGxvdy5zdmcpXShodHRwczovL3d3dy5ucG1qcy5jb20vYnJvd3NlL2tleXdvcmQvdG9uYWwpXG4gKlxuICogYHRvbmFsLWNob3JkYCBpcyBhIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgbXVzaWNhbCBjaG9yZHNcbiAqXG4gKiBUaGlzIGlzIHBhcnQgb2YgW3RvbmFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS90b25hbCkgbXVzaWMgdGhlb3J5IGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGVzNlxuICogaW1wb3J0ICogYXMgQ2hvcmQgZnJvbSBcInRvbmFsLWNob3JkXCJcbiAqIC8vIGVzNVxuICogY29uc3QgQ2hvcmQgPSByZXF1aXJlKFwidG9uYWwtY2hvcmRcIilcbiAqXG4gKiBAZXhhbXBsZVxuICogQ2hvcmQubm90ZXMoXCJDTWFqN1wiKSAvLyA9PiBbXCJDXCIsIFwiRVwiLCBcIkdcIiwgXCJCXCJdXG4gKlxuICogQG1vZHVsZSBDaG9yZFxuICovXG5pbXBvcnQgeyB0b2tlbml6ZSBhcyBzcGxpdCB9IGZyb20gXCJ0b25hbC1ub3RlXCI7XG5pbXBvcnQgeyB0cmFuc3Bvc2UgfSBmcm9tIFwidG9uYWwtZGlzdGFuY2VcIjtcbmltcG9ydCB7IGNob3JkIH0gZnJvbSBcInRvbmFsLWRpY3Rpb25hcnlcIjtcbmltcG9ydCB7IGNocm9tYSwgaXNTdWJzZXRPZiwgaXNTdXBlcnNldE9mIH0gZnJvbSBcInRvbmFsLXBjc2V0XCI7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhdmFpbGFibGUgY2hvcmQgbmFtZXNcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxpYXNlcyAtIHRydWUgdG8gaW5jbHVkZSBhbGlhc2VzXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIGNob3JkIG5hbWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIENob3JkLm5hbWVzKCkgLy8gPT4gW1wibWFqN1wiLCAuLi5dXG4gKi9cbmV4cG9ydCB2YXIgbmFtZXMgPSBjaG9yZC5uYW1lcztcblxudmFyIE5PX0NIT1JEID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG5hbWU6IG51bGwsXG4gIG5hbWVzOiBbXSxcbiAgaW50ZXJ2YWxzOiBbXSxcbiAgY2hyb21hOiBudWxsLFxuICBzZXRudW06IG51bGxcbn0pO1xuXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBpbnRlcnZhbHMgPSBjaG9yZChuYW1lKTtcbiAgaWYgKCFpbnRlcnZhbHMpIHsgcmV0dXJuIE5PX0NIT1JEOyB9XG4gIHZhciBzID0geyBpbnRlcnZhbHM6IGludGVydmFscywgbmFtZTogbmFtZSB9O1xuICBzLmNocm9tYSA9IGNocm9tYShpbnRlcnZhbHMpO1xuICBzLnNldG51bSA9IHBhcnNlSW50KHMuY2hyb21hLCAyKTtcbiAgcy5uYW1lcyA9IGNob3JkLm5hbWVzKHMuY2hyb21hKTtcbiAgcmV0dXJuIHM7XG59O1xuXG52YXIgbWVtbyA9IGZ1bmN0aW9uIChmbiwgY2FjaGUpIHtcbiAgaWYgKCBjYWNoZSA9PT0gdm9pZCAwICkgY2FjaGUgPSB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gY2FjaGVbc3RyXSB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpOyB9O1xufTtcblxuLyoqXG4gKiBHZXQgY2hvcmQgcHJvcGVydGllcy4gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aDpcbiAqXG4gKiAtIG5hbWU6IHRoZSBjaG9yZCBuYW1lXG4gKiAtIG5hbWVzOiBhIGxpc3Qgd2l0aCBhbGwgcG9zc2libGUgbmFtZXMgKGluY2x1ZGVzIHRoZSBjdXJyZW50KVxuICogLSBpbnRlcnZhbHM6IGFuIGFycmF5IHdpdGggdGhlIGNob3JkIGludGVydmFsc1xuICogLSBjaHJvbWE6ICBjaG9yZCBjcm9tYSAoc2VlIHBjc2V0KVxuICogLSBzZXRudW06IGNob3JkIGNocm9tYSBudW1iZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIGNob3JkIG5hbWUgKHdpdGhvdXQgdG9uaWMpXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9yIGEgb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXNcbiAqIHNldCB0byBudWxsIGlmIG5vdCB2YWxpZCBjaG9yZCBuYW1lXG4gKi9cbmV4cG9ydCB2YXIgcHJvcHMgPSBtZW1vKHByb3BlcnRpZXMpO1xuXG4vKipcbiAqIEdldCBjaG9yZCBpbnRlcnZhbHMuIEl0IGFsd2F5cyByZXR1cm5zIGFuIGFycmF5XG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBjaG9yZCBuYW1lIChvcHRpb25hbGx5IGEgdG9uaWMgYW5kIHR5cGUpXG4gKiBAcmV0dXJuIHtBcnJheTxTdHJpbmc+fSBhIGxpc3Qgb2YgaW50ZXJ2YWxzIG9yIG51bGwgaWYgdGhlIHR5cGUgaXMgbm90IGtub3duXG4gKi9cbmV4cG9ydCB2YXIgaW50ZXJ2YWxzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHByb3BzKHRva2VuaXplKG5hbWUpWzFdKS5pbnRlcnZhbHM7IH07XG5cbi8qKlxuICogR2V0IHRoZSBjaG9yZCBub3RlcyBvZiBhIGNob3JkLiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgZWl0aGVyIGEgY2hvcmQgbmFtZVxuICogKGZvciBleGFtcGxlOiBcIkNtYWo3XCIpIG9yIGEgbGlzdCBvZiBub3Rlcy5cbiAqXG4gKiBJdCBhbHdheXMgcmV0dXJucyBhbiBhcnJheSwgZXZlbiBpZiB0aGUgY2hvcmQgaXMgbm90IGZvdW5kLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVPclRvbmljIC0gbmFtZSBvZiB0aGUgY2hvcmQgb3IgdGhlIHRvbmljIChpZiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyBwcmVzZW50KVxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIChPcHRpb25hbCkgbmFtZSBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSB0b25pY1xuICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIG5vdGVzIG9yIGFuIGVtcHR5IGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIENob3JkLm5vdGVzKFwiQ21hajdcIikgLy8gPT4gW1wiQ1wiLCBcIkVcIiwgXCJHXCIsIFwiQlwiXVxuICogQ2hvcmQubm90ZXMoXCJDXCIsIFwibWFqN1wiKSAvLyA9PiBbXCJDXCIsIFwiRVwiLCBcIkdcIiwgXCJCXCJdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RlcyhuYW1lT3JUb25pYywgbmFtZSkge1xuICBpZiAobmFtZSkgeyByZXR1cm4gcHJvcHMobmFtZSkuaW50ZXJ2YWxzLm1hcCh0cmFuc3Bvc2UobmFtZU9yVG9uaWMpKTsgfVxuICB2YXIgcmVmID0gdG9rZW5pemUobmFtZU9yVG9uaWMpO1xuICB2YXIgdG9uaWMgPSByZWZbMF07XG4gIHZhciB0eXBlID0gcmVmWzFdO1xuICByZXR1cm4gcHJvcHModHlwZSkuaW50ZXJ2YWxzLm1hcCh0cmFuc3Bvc2UodG9uaWMpKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIG5hbWUgY29ycmVzcG9uZCB0byBhIGNob3JkIGluIHRoZSBkaWN0aW9uYXJ5XG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKiBDaG9yZC5leGlzdHMoXCJDTWFqN1wiKSAvLyA9PiB0cnVlXG4gKiBDaG9yZC5leGlzdHMoXCJNYWo3XCIpIC8vID0+IHRydWVcbiAqIENob3JkLmV4aXN0cyhcIkFibGFoXCIpIC8vID0+IGZhbHNlXG4gKi9cbmV4cG9ydCB2YXIgZXhpc3RzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGNob3JkKHRva2VuaXplKG5hbWUpWzFdKSAhPT0gdW5kZWZpbmVkOyB9O1xuXG4vKipcbiAqIEdldCBhbGwgY2hvcmRzIG5hbWVzIHRoYXQgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGdpdmVuIG9uZVxuICogKGhhcyB0aGUgc2FtZSBub3RlcyBhbmQgYXQgbGVhc3Qgb25lIG1vcmUpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7QXJyYXl9IGEgbGlzdCBvZiBjaG9yZCBuYW1lc1xuICovXG5leHBvcnQgdmFyIHN1cGVyc2V0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaW50ZXJ2YWxzKG5hbWUpLmxlbmd0aCkgeyByZXR1cm4gW107IH1cbiAgdmFyIGlzU3VwZXJzZXQgPSBpc1N1cGVyc2V0T2YoaW50ZXJ2YWxzKG5hbWUpKTtcbiAgcmV0dXJuIGNob3JkLm5hbWVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpc1N1cGVyc2V0KGNob3JkKG5hbWUpKTsgfSk7XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIGNob3JkcyBuYW1lcyB0aGF0IGFyZSBhIHN1YnNldCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiAoaGFzIGxlc3Mgbm90ZXMgYnV0IGFsbCBmcm9tIHRoZSBnaXZlbiBjaG9yZClcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtBcnJheX0gYSBsaXN0IG9mIGNob3JkIG5hbWVzXG4gKi9cbmV4cG9ydCB2YXIgc3Vic2V0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBpc1N1YnNldCA9IGlzU3Vic2V0T2YoaW50ZXJ2YWxzKG5hbWUpKTtcbiAgcmV0dXJuIGNob3JkLm5hbWVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpc1N1YnNldChjaG9yZChuYW1lKSk7IH0pO1xufTtcblxuLy8gNiwgNjQsIDcsIDksIDExIGFuZCAxMyBhcmUgY29uc2lkZXIgcGFydCBvZiB0aGUgY2hvcmRcbi8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RhbmlnYi90b25hbC9pc3N1ZXMvNTUpXG52YXIgTlVNX1RZUEVTID0gL14oNnw2NHw3fDl8MTF8MTMpJC87XG4vKipcbiAqIFRva2VuaXplIGEgY2hvcmQgbmFtZS4gSXQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0b25pYyBhbmQgY2hvcmQgdHlwZVxuICogSWYgbm90IHRvbmljIGlzIGZvdW5kLCBhbGwgdGhlIG5hbWUgaXMgY29uc2lkZXJlZCB0aGUgY2hvcmQgbmFtZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgTk9UIGNoZWNrIGlmIHRoZSBjaG9yZCB0eXBlIGV4aXN0cyBvciBub3QuIEl0IG9ubHkgdHJpZXNcbiAqIHRvIHNwbGl0IHRoZSB0b25pYyBhbmQgY2hvcmQgdHlwZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIGNob3JkIG5hbWVcbiAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSB3aXRoIFt0b25pYywgdHlwZV1cbiAqIEBleGFtcGxlXG4gKiBDaG9yZC50b2tlbml6ZShcIkNtYWo3XCIpIC8vID0+IFsgXCJDXCIsIFwibWFqN1wiIF1cbiAqIENob3JkLnRva2VuaXplKFwiQzdcIikgLy8gPT4gWyBcIkNcIiwgXCI3XCIgXVxuICogQ2hvcmQudG9rZW5pemUoXCJtTWFqN1wiKSAvLyA9PiBbIFwiXCIsIFwibU1hajdcIiBdXG4gKiBDaG9yZC50b2tlbml6ZShcIkNub25zZW5zZVwiKSAvLyA9PiBbIFwiQ1wiLCBcIm5vbnNlbnNlXCIgXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5pemUobmFtZSkge1xuICB2YXIgcCA9IHNwbGl0KG5hbWUpO1xuICBpZiAocFswXSA9PT0gXCJcIikgeyByZXR1cm4gW1wiXCIsIG5hbWVdOyB9XG4gIC8vIGF1ZyBpcyBhdWdtZW50ZWQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGFuaWdiL3RvbmFsL2lzc3Vlcy81NSlcbiAgaWYgKHBbMF0gPT09IFwiQVwiICYmIHBbM10gPT09IFwidWdcIikgeyByZXR1cm4gW1wiXCIsIFwiYXVnXCJdOyB9XG5cbiAgaWYgKE5VTV9UWVBFUy50ZXN0KHBbMl0pKSB7XG4gICAgcmV0dXJuIFtwWzBdICsgcFsxXSwgcFsyXSArIHBbM11dO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbcFswXSArIHBbMV0gKyBwWzJdLCBwWzNdXTtcbiAgfVxufVxuIiwiLyoqXG4gKiBbIVtucG0gdmVyc2lvbl0oaHR0cHM6Ly9pbWcuc2hpZWxkcy5pby9ucG0vdi90b25hbC1kaWN0aW9uYXJ5LnN2ZyldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3RvbmFsLWRpY3Rpb25hcnkpXG4gKlxuICogYHRvbmFsLWRpY3Rpb25hcnlgIGNvbnRhaW5zIGEgZGljdGlvbmFyeSBvZiBtdXNpY2FsIHNjYWxlcyBhbmQgY2hvcmRzXG4gKlxuICogVGhpcyBpcyBwYXJ0IG9mIFt0b25hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdG9uYWwpIG11c2ljIHRoZW9yeSBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBlczZcbiAqIGltcG9ydCAqIGFzIERpY3Rpb25hcnkgZnJvbSBcInRvbmFsLWRpY3Rpb25hcnlcIlxuICogLy8gZXM1XG4gKiBjb25zdCBEaWN0aW9uYXJ5ID0gcmVxdWlyZShcInRvbmFsLWRpY3Rpb25hcnlcIilcbiAqXG4gKiBAZXhhbXBsZVxuICogRGljdGlvbmFyeS5jaG9yZChcIk1hajdcIikgLy8gPT4gW1wiMVBcIiwgXCIzTVwiLCBcIjVQXCIsIFwiN01cIl1cbiAqXG4gKiBAbW9kdWxlIERpY3Rpb25hcnlcbiAqL1xuaW1wb3J0IHNkYXRhIGZyb20gXCIuL2RhdGEvc2NhbGVzLmpzb25cIjtcbmltcG9ydCBjZGF0YSBmcm9tIFwiLi9kYXRhL2Nob3Jkcy5qc29uXCI7XG5pbXBvcnQgeyBjaHJvbWEgfSBmcm9tIFwidG9uYWwtcGNzZXRcIjtcblxuZXhwb3J0IHZhciBkaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKHJhdykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJhdykuc29ydCgpO1xuICB2YXIgZGF0YSA9IFtdO1xuICB2YXIgaW5kZXggPSBbXTtcblxuICB2YXIgYWRkID0gZnVuY3Rpb24gKG5hbWUsIGl2bHMsIGNocm9tYSkge1xuICAgIGRhdGFbbmFtZV0gPSBpdmxzO1xuICAgIGluZGV4W2Nocm9tYV0gPSBpbmRleFtjaHJvbWFdIHx8IFtdO1xuICAgIGluZGV4W2Nocm9tYV0ucHVzaChuYW1lKTtcbiAgfTtcblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpdmxzID0gcmF3W2tleV1bMF0uc3BsaXQoXCIgXCIpO1xuICAgIHZhciBhbGlhcyA9IHJhd1trZXldWzFdO1xuICAgIHZhciBjaHIgPSBjaHJvbWEoaXZscyk7XG5cbiAgICBhZGQoa2V5LCBpdmxzLCBjaHIpO1xuICAgIGlmIChhbGlhcykgeyBhbGlhcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhZGQoYSwgaXZscywgY2hyKTsgfSk7IH1cbiAgfSk7XG4gIHZhciBhbGxLZXlzID0gT2JqZWN0LmtleXMoZGF0YSkuc29ydCgpO1xuXG4gIHZhciBkaWN0ID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGRhdGFbbmFtZV07IH07XG4gIGRpY3QubmFtZXMgPSBmdW5jdGlvbiAocCkge1xuICAgIGlmICh0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIikgeyByZXR1cm4gKGluZGV4W3BdIHx8IFtdKS5zbGljZSgpOyB9XG4gICAgZWxzZSB7IHJldHVybiAocCA9PT0gdHJ1ZSA/IGFsbEtleXMgOiBrZXlzKS5zbGljZSgpOyB9XG4gIH07XG4gIHJldHVybiBkaWN0O1xufTtcblxuZXhwb3J0IHZhciBjb21iaW5lID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGRpY3QgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYShuYW1lKSB8fCBiKG5hbWUpOyB9O1xuICBkaWN0Lm5hbWVzID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuIGEubmFtZXMocCkuY29uY2F0KGIubmFtZXMocCkpOyB9O1xuICByZXR1cm4gZGljdDtcbn07XG5cbi8qKlxuICogQSBkaWN0aW9uYXJ5IG9mIHNjYWxlczogYSBmdW5jdGlvbiB0aGF0IGdpdmVuIGEgc2NhbGUgbmFtZSAod2l0aG91dCB0b25pYylcbiAqIHJldHVybnMgYW4gYXJyYXkgb2YgaW50ZXJ2YWxzXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7QXJyYXl9IGludGVydmFsc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHNjYWxlIH0gZnJvbSBcInRvbmFsLWRpY3Rpb25hcnlcIlxuICogc2NhbGUoXCJtYWpvclwiKSAvLyA9PiBbXCIxUFwiLCBcIjJNXCIsIC4uLl1cbiAqIHNjYWxlLm5hbWVzKCk7IC8vID0+IFtcIm1ham9yXCIsIC4uLl1cbiAqL1xuZXhwb3J0IHZhciBzY2FsZSA9IGRpY3Rpb25hcnkoc2RhdGEpO1xuXG4vKipcbiAqIEEgZGljdGlvbmFyeSBvZiBjaG9yZHM6IGEgZnVuY3Rpb24gdGhhdCBnaXZlbiBhIGNob3JkIHR5cGVcbiAqIHJldHVybnMgYW4gYXJyYXkgb2YgaW50ZXJ2YWxzXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7QXJyYXl9IGludGVydmFsc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGNob3JkIH0gZnJvbSBcInRvbmFsLWRpY3Rpb25hcnlcIlxuICogY2hvcmQoXCJNYWo3XCIpIC8vID0+IFtcIjFQXCIsIFwiM01cIiwgLi4uXVxuICogY2hvcmQubmFtZXMoKTsgLy8gPT4gW1wiTWFqM1wiLCAuLi5dXG4gKi9cbmV4cG9ydCB2YXIgY2hvcmQgPSBkaWN0aW9uYXJ5KGNkYXRhKTtcbmV4cG9ydCB2YXIgcGNzZXQgPSBjb21iaW5lKHNjYWxlLCBjaG9yZCk7XG4iLCIvKipcbiAqIFshW25wbSB2ZXJzaW9uXShodHRwczovL2ltZy5zaGllbGRzLmlvL25wbS92L3RvbmFsLWRpc3RhbmNlLnN2ZyldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3RvbmFsLWRpc3RhbmNlKVxuICogWyFbdG9uYWxdKGh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vYmFkZ2UvdG9uYWwtZGlzdGFuY2UteWVsbG93LnN2ZyldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5pZ2IvdG9uYWwvdHJlZS9tYXN0ZXIvcGFja2FnZXMvdG9uYWwvZGlzdGFuY2UpXG4gKlxuICogVHJhbnNwb3NlIG5vdGVzIGJ5IGludGVydmFscyBhbmQgZmluZCBkaXN0YW5jZXMgYmV0d2VlbiBub3Rlc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBlczZcbiAqIGltcG9ydCAqIGFzIERpc3RhbmNlIGZyb20gXCJ0b25hbC1kaXN0YW5jZVwiXG4gKiBEaXN0YW5jZS5pbnRlcnZhbChcIkMzXCIsIFwiQzRcIikgLy8gPT4gXCIxUFwiXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGVzNiBpbXBvcnQgc2VsZWN0ZWQgZnVuY3Rpb25zXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCwgc2VtaXRvbmVzLCB0cmFuc3Bvc2UgfSBmcm9tIFwidG9uYWwtZGlzdGFuY2VcIlxuICpcbiAqIHNlbWl0b25lcyhcIkNcIiAsXCJEXCIpIC8vID0+IDJcbiAqIGludGVydmFsKFwiQzRcIiwgXCJHNFwiKSAvLyA9PiBcIjVQXCJcbiAqIHRyYW5zcG9zZShcIkM0XCIsIFwiUDVcIikgLy8gPT4gXCJHNFwiXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGluY2x1ZGVkIGluIHRvbmFsIGZhY2FkZVxuICogY29uc3QgVG9uYWwgPSByZXF1aXJlKFwidG9uYWxcIik7XG4gKiBUb25hbC5EaXN0YW5jZS50cmFuc3Bvc2UoXCJDNFwiLCBcIlA1XCIpXG4gKiBUb25hbC5EaXN0YW5jZS50cmFuc3Bvc2VCeShcIlA1XCIsIFwiQzRcIilcbiAqXG4gKiBAbW9kdWxlIERpc3RhbmNlXG4gKi9cbmltcG9ydCB7IHByb3BzIGFzIG5vdGVQcm9wcywgYnVpbGQgYXMgZnJvbU5vdGUgfSBmcm9tIFwidG9uYWwtbm90ZVwiO1xuaW1wb3J0IHsgcHJvcHMgYXMgaXByb3BzLCBidWlsZCBhcyBpYnVpbGQgfSBmcm9tIFwidG9uYWwtaW50ZXJ2YWxcIjtcblxuLy8gTWFwIGZyb20gbGV0dGVyIHN0ZXAgdG8gbnVtYmVyIG9mIGZpZnRocyBzdGFydGluZyBmcm9tIFwiQ1wiOlxuLy8geyBDOiAwLCBEOiAyLCBFOiA0LCBGOiAtMSwgRzogMSwgQTogMywgQjogNSB9XG52YXIgRklGVEhTID0gWzAsIDIsIDQsIC0xLCAxLCAzLCA1XTtcblxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZmlmdGhzLCByZXR1cm4gdGhlIG9jdGF2ZXMgdGhleSBzcGFuXG52YXIgZk9jdHMgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gTWF0aC5mbG9vcigoZiAqIDcpIC8gMTIpOyB9O1xuXG4vLyBHZXQgdGhlIG51bWJlciBvZiBvY3RhdmVzIGl0IHNwYW4gZWFjaCBzdGVwXG52YXIgRklGVEhfT0NUUyA9IEZJRlRIUy5tYXAoZk9jdHMpO1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHJlZikge1xuICB2YXIgc3RlcCA9IHJlZi5zdGVwO1xuICB2YXIgYWx0ID0gcmVmLmFsdDtcbiAgdmFyIG9jdCA9IHJlZi5vY3Q7XG4gIHZhciBkaXIgPSByZWYuZGlyOyBpZiAoIGRpciA9PT0gdm9pZCAwICkgZGlyID0gMTtcblxuICB2YXIgZiA9IEZJRlRIU1tzdGVwXSArIDcgKiBhbHQ7XG4gIGlmIChvY3QgPT09IG51bGwpIHsgcmV0dXJuIFtkaXIgKiBmXTsgfVxuICB2YXIgbyA9IG9jdCAtIEZJRlRIX09DVFNbc3RlcF0gLSA0ICogYWx0O1xuICByZXR1cm4gW2RpciAqIGYsIGRpciAqIG9dO1xufTtcblxuLy8gV2UgbmVlZCB0byBnZXQgdGhlIHN0ZXBzIGZyb20gZmlmdGhzXG4vLyBGaWZ0aHMgZm9yIENERUZHQUIgYXJlIFsgMCwgMiwgNCwgLTEsIDEsIDMsIDUgXVxuLy8gV2UgYWRkIDEgdG8gZmlmdGhzIHRvIGF2b2lkIG5lZ2F0aXZlIG51bWJlcnMsIHNvOlxuLy8gZm9yIFtcIkZcIiwgXCJDXCIsIFwiR1wiLCBcIkRcIiwgXCJBXCIsIFwiRVwiLCBcIkJcIl0gd2UgaGF2ZTpcbnZhciBTVEVQUyA9IFszLCAwLCA0LCAxLCA1LCAyLCA2XTtcblxuLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZmlmdGhzIGFzIGlmIGl0IHdlcmUgdW5hbHRlcmVkXG5mdW5jdGlvbiB1bmFsdGVyZWQoZikge1xuICB2YXIgaSA9IChmICsgMSkgJSA3O1xuICByZXR1cm4gaSA8IDAgPyA3ICsgaSA6IGk7XG59XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiAoZiwgbywgZGlyKSB7XG4gIHZhciBzdGVwID0gU1RFUFNbdW5hbHRlcmVkKGYpXTtcbiAgdmFyIGFsdCA9IE1hdGguZmxvb3IoKGYgKyAxKSAvIDcpO1xuICBpZiAobyA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB7IHN0ZXA6IHN0ZXAsIGFsdDogYWx0LCBkaXI6IGRpciB9OyB9XG4gIHZhciBvY3QgPSBvICsgNCAqIGFsdCArIEZJRlRIX09DVFNbc3RlcF07XG4gIHJldHVybiB7IHN0ZXA6IHN0ZXAsIGFsdDogYWx0LCBvY3Q6IG9jdCwgZGlyOiBkaXIgfTtcbn07XG5cbnZhciBtZW1vID0gZnVuY3Rpb24gKGZuLCBjYWNoZSkge1xuICBpZiAoIGNhY2hlID09PSB2b2lkIDAgKSBjYWNoZSA9IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7IH07XG59O1xuXG52YXIgZW5jb2RlciA9IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gbWVtbyhmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIHAgPSBwcm9wcyhzdHIpO1xuICAgIHJldHVybiBwLm5hbWUgPT09IG51bGwgPyBudWxsIDogZW5jb2RlKHApO1xuICB9KTsgfTtcblxudmFyIGVuY29kZU5vdGUgPSBlbmNvZGVyKG5vdGVQcm9wcyk7XG52YXIgZW5jb2RlSXZsID0gZW5jb2RlcihpcHJvcHMpO1xuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG5vdGUgYnkgYW4gaW50ZXJ2YWwuIFRoZSBub3RlIGNhbiBiZSBhIHBpdGNoIGNsYXNzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub3RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW50ZXJ2YWxcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHRyYW5zcG9zZWQgbm90ZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHRyYW5wb3NlIH0gZnJvbSBcInRvbmFsLWRpc3RhbmNlXCJcbiAqIHRyYW5zcG9zZShcImQzXCIsIFwiM01cIikgLy8gPT4gXCJGIzNcIlxuICogLy8gaXQgd29ya3Mgd2l0aCBwaXRjaCBjbGFzc2VzXG4gKiB0cmFuc3Bvc2UoXCJEXCIsIFwiM01cIikgLy8gPT4gXCJGI1wiXG4gKiAvLyBjYW4gYmUgcGFydGlhbGx5IGFwcGxpZWRcbiAqIFtcIkNcIiwgXCJEXCIsIFwiRVwiLCBcIkZcIiwgXCJHXCJdLm1hcCh0cmFuc3Bvc2UoXCJNMykpIC8vID0+IFtcIkVcIiwgXCJGI1wiLCBcIkcjXCIsIFwiQVwiLCBcIkJcIl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShub3RlLCBpbnRlcnZhbCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyByZXR1cm4gZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRyYW5zcG9zZShub3RlLCBpKTsgfTsgfVxuICB2YXIgbiA9IGVuY29kZU5vdGUobm90ZSk7XG4gIHZhciBpID0gZW5jb2RlSXZsKGludGVydmFsKTtcbiAgaWYgKG4gPT09IG51bGwgfHwgaSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICB2YXIgdHIgPSBuLmxlbmd0aCA9PT0gMSA/IFtuWzBdICsgaVswXV0gOiBbblswXSArIGlbMF0sIG5bMV0gKyBpWzFdXTtcbiAgcmV0dXJuIGZyb21Ob3RlKGRlY29kZSh0clswXSwgdHJbMV0pKTtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgYSBwaXRjaCBjbGFzcyBieSBhIG51bWJlciBvZiBwZXJmZWN0IGZpZnRocy5cbiAqXG4gKiBJdCBjYW4gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGl0Y2hDbGFzcyAtIHRoZSBwaXRjaCBjbGFzc1xuICogQHBhcmFtIHtJbnRlZ2VyfSBmaWZodHMgLSB0aGUgbnVtYmVyIG9mIGZpZnRoc1xuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdHJhbnNwb3NlZCBwaXRjaCBjbGFzc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyB0ckZpZnRocyB9IGZyb20gXCJ0b25hbC10cmFuc3Bvc2VcIlxuICogWzAsIDEsIDIsIDMsIDRdLm1hcCh0ckZpZnRocyhcIkNcIikpIC8vID0+IFtcIkNcIiwgXCJHXCIsIFwiRFwiLCBcIkFcIiwgXCJFXCJdXG4gKiAvLyBvciB1c2luZyB0b25hbFxuICogRGlzdGFuY2UudHJGaWZ0aHMoXCJHNFwiLCAxKSAvLyA9PiBcIkRcIlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0ckZpZnRocyhub3RlLCBmaWZ0aHMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB0ckZpZnRocyhub3RlLCBmKTsgfTsgfVxuICB2YXIgbiA9IGVuY29kZU5vdGUobm90ZSk7XG4gIGlmIChuID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gIHJldHVybiBmcm9tTm90ZShkZWNvZGUoblswXSArIGZpZnRocykpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZGlzdGFuY2UgaW4gZmlmdGhzIGJldHdlZW4gcGl0Y2ggY2xhc3Nlc1xuICpcbiAqIENhbiBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG8gLSBub3RlIG9yIHBpdGNoIGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbSAtIG5vdGUgb3IgcGl0Y2ggY2xhc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpZnRocyhmcm9tLCB0bykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyByZXR1cm4gZnVuY3Rpb24gKHRvKSB7IHJldHVybiBmaWZ0aHMoZnJvbSwgdG8pOyB9OyB9XG4gIHZhciBmID0gZW5jb2RlTm90ZShmcm9tKTtcbiAgdmFyIHQgPSBlbmNvZGVOb3RlKHRvKTtcbiAgaWYgKHQgPT09IG51bGwgfHwgZiA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICByZXR1cm4gdFswXSAtIGZbMF07XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgdHJhbnNwb3NlIHdpdGggdGhlIGFyZ3VtZW50cyBpbnZlcnRlZC5cbiAqXG4gKiBDYW4gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcnZhbFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdHJhbnNwb3NlZCBub3RlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgdHJhbnBvc2VCeSB9IGZyb20gXCJ0b25hbC1kaXN0YW5jZVwiXG4gKiB0cmFuc3Bvc2VCeShcIjNtXCIsIFwiNVBcIikgLy8gPT4gXCI3bVwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2VCeShpbnRlcnZhbCwgbm90ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyByZXR1cm4gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHRyYW5zcG9zZShuLCBpbnRlcnZhbCk7IH07IH1cbiAgcmV0dXJuIHRyYW5zcG9zZShub3RlLCBpbnRlcnZhbCk7XG59XG5cbnZhciBpc0Rlc2NlbmRpbmcgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVswXSAqIDcgKyBlWzFdICogMTIgPCAwOyB9O1xudmFyIGRlY29kZUl2bCA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiBpc0Rlc2NlbmRpbmcoaSkgPyBkZWNvZGUoLWlbMF0sIC1pWzFdLCAtMSkgOiBkZWNvZGUoaVswXSwgaVsxXSwgMSk7IH07XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJbnRlcnZhbHMoaXZsMSwgaXZsMiwgZGlyKSB7XG4gIHZhciBpMSA9IGVuY29kZUl2bChpdmwxKTtcbiAgdmFyIGkyID0gZW5jb2RlSXZsKGl2bDIpO1xuICBpZiAoaTEgPT09IG51bGwgfHwgaTIgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgdmFyIGkgPSBbaTFbMF0gKyBkaXIgKiBpMlswXSwgaTFbMV0gKyBkaXIgKiBpMlsxXV07XG4gIHJldHVybiBpYnVpbGQoZGVjb2RlSXZsKGkpKTtcbn1cblxuLyoqXG4gKiBBZGQgdHdvIGludGVydmFsc1xuICpcbiAqIENhbiBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW50ZXJ2YWwxXG4gKiBAcGFyYW0ge3N0cmluZ30gaW50ZXJ2YWwyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgaW50ZXJ2YWxcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBhZGQgfSBmcm9tIFwidG9uYWwtZGlzdGFuY2VcIlxuICogYWRkKFwiM21cIiwgXCI1UFwiKSAvLyA9PiBcIjdtXCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChpdmwxLCBpdmwyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IHJldHVybiBmdW5jdGlvbiAoaTIpIHsgcmV0dXJuIGFkZChpdmwxLCBpMik7IH07IH1cbiAgcmV0dXJuIGFkZEludGVydmFscyhpdmwxLCBpdmwyLCAxKTtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdCB0d28gaW50ZXJ2YWxzXG4gKlxuICogQ2FuIGJlIHBhcnRpYWxseSBhcHBsaWVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1pbnVlbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWJ0cmFoZW5kXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGludGVydmFsIGRpZmVyZW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3QoaXZsMSwgaXZsMikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyByZXR1cm4gZnVuY3Rpb24gKGkyKSB7IHJldHVybiBhZGQoaXZsMSwgaTIpOyB9OyB9XG4gIHJldHVybiBhZGRJbnRlcnZhbHMoaXZsMSwgaXZsMiwgLTEpO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIGludGVydmFsIGJldHdlZW4gdHdvIHBpdGNoZXMuIEl0IHdvcmtzIHdpdGggcGl0Y2ggY2xhc3Nlc1xuICogKGJvdGggbXVzdCBiZSBwaXRjaCBjbGFzc2VzIGFuZCB0aGUgaW50ZXJ2YWwgaXMgYWx3YXlzIGFzY2VuZGluZylcbiAqXG4gKiBDYW4gYmUgcGFydGlhbGx5IGFwcGxpZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbSAtIGRpc3RhbmNlIGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nfSB0byAtIGRpc3RhbmNlIHRvXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBpbnRlcnZhbCBkaXN0YW5jZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCB9IGZyb20gXCJ0b25hbC1kaXN0YW5jZVwiXG4gKiBpbnRlcnZhbChcIkMyXCIsIFwiQzNcIikgLy8gPT4gXCJQOFwiXG4gKiBpbnRlcnZhbChcIkdcIiwgXCJCXCIpIC8vID0+IFwiTTNcIlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBEaXN0YW5jZSBmcm9tIFwidG9uYWwtZGlzdGFuY2VcIlxuICogRGlzdGFuY2UuaW50ZXJ2YWwoXCJNMlwiLCBcIlA1XCIpIC8vID0+IFwiUDRcIlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJ2YWwoZnJvbSwgdG8pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiBpbnRlcnZhbChmcm9tLCB0KTsgfTsgfVxuICB2YXIgZiA9IGVuY29kZU5vdGUoZnJvbSk7XG4gIHZhciB0ID0gZW5jb2RlTm90ZSh0byk7XG4gIGlmIChmID09PSBudWxsIHx8IHQgPT09IG51bGwgfHwgZi5sZW5ndGggIT09IHQubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG4gIHZhciBkID1cbiAgICBmLmxlbmd0aCA9PT0gMVxuICAgICAgPyBbdFswXSAtIGZbMF0sIC1NYXRoLmZsb29yKCgodFswXSAtIGZbMF0pICogNykgLyAxMildXG4gICAgICA6IFt0WzBdIC0gZlswXSwgdFsxXSAtIGZbMV1dO1xuICByZXR1cm4gaWJ1aWxkKGRlY29kZUl2bChkKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBub3RlcyBpbiBzZW1pdG9uZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xQaXRjaH0gZnJvbSAtIGZpcnN0IG5vdGVcbiAqIEBwYXJhbSB7U3RyaW5nfFBpdGNofSB0byAtIGxhc3Qgbm90ZVxuICogQHJldHVybiB7SW50ZWdlcn0gdGhlIGRpc3RhbmNlIGluIHNlbWl0b25lcyBvciBudWxsIGlmIG5vdCB2YWxpZCBub3Rlc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHNlbWl0b25lcyB9IGZyb20gXCJ0b25hbC1kaXN0YW5jZVwiXG4gKiBzZW1pdG9uZXMoXCJDM1wiLCBcIkEyXCIpIC8vID0+IC0zXG4gKiAvLyBvciB1c2UgdG9uYWxcbiAqIFRvbmFsLkRpc3RhbmNlLnNlbWl0b25lcyhcIkMzXCIsIFwiRzNcIikgLy8gPT4gN1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VtaXRvbmVzKGZyb20sIHRvKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gc2VtaXRvbmVzKGZyb20sIHQpOyB9OyB9XG4gIHZhciBmID0gbm90ZVByb3BzKGZyb20pO1xuICB2YXIgdCA9IG5vdGVQcm9wcyh0byk7XG4gIHJldHVybiBmLm1pZGkgIT09IG51bGwgJiYgdC5taWRpICE9PSBudWxsXG4gICAgPyB0Lm1pZGkgLSBmLm1pZGlcbiAgICA6IGYuY2hyb21hICE9PSBudWxsICYmIHQuY2hyb21hICE9PSBudWxsXG4gICAgICA/ICh0LmNocm9tYSAtIGYuY2hyb21hICsgMTIpICUgMTJcbiAgICAgIDogbnVsbDtcbn1cbiIsInZhciBJVkxfVE5MID0gXCIoWy0rXT9cXFxcZCspKGR7MSw0fXxtfE18UHxBezEsNH0pXCI7XHJcbnZhciBJVkxfU1RSID0gXCIoQUF8QXxQfE18bXxkfGRkKShbLStdP1xcXFxkKylcIjtcclxudmFyIFJFR0VYID0gbmV3IFJlZ0V4cChcIl5cIiArIElWTF9UTkwgKyBcInxcIiArIElWTF9TVFIgKyBcIiRcIik7XHJcbnZhciBTSVpFUyA9IFswLCAyLCA0LCA1LCA3LCA5LCAxMV07XHJcbnZhciBUWVBFUyA9IFwiUE1NUFBNTVwiO1xyXG52YXIgQ0xBU1NFUyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA1LCA0LCAzLCAyLCAxXTtcclxudmFyIE5BTUVTID0gXCIxUCAybSAyTSAzbSAzTSA0UCA1UCA2bSA2TSA3bSA3TSA4UFwiLnNwbGl0KFwiIFwiKTtcclxudmFyIG5hbWVzID0gZnVuY3Rpb24gKHR5cGVzKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHR5cGVzICE9PSBcInN0cmluZ1wiXHJcbiAgICAgICAgPyBOQU1FUy5zbGljZSgpXHJcbiAgICAgICAgOiBOQU1FUy5maWx0ZXIoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHR5cGVzLmluZGV4T2YoblsxXSkgIT09IC0xOyB9KTtcclxufTtcclxudmFyIHRva2VuaXplID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgdmFyIG0gPSBSRUdFWC5leGVjKFwiXCIgKyBzdHIpO1xyXG4gICAgaWYgKG0gPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gKG1bMV0gPyBbbVsxXSwgbVsyXV0gOiBbbVs0XSwgbVszXV0pO1xyXG59O1xyXG52YXIgTk9fSVZMID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBuYW1lOiBudWxsLFxyXG4gICAgbnVtOiBudWxsLFxyXG4gICAgcTogbnVsbCxcclxuICAgIHN0ZXA6IG51bGwsXHJcbiAgICBhbHQ6IG51bGwsXHJcbiAgICBkaXI6IG51bGwsXHJcbiAgICB0eXBlOiBudWxsLFxyXG4gICAgc2ltcGxlOiBudWxsLFxyXG4gICAgc2VtaXRvbmVzOiBudWxsLFxyXG4gICAgY2hyb21hOiBudWxsLFxyXG4gICAgb2N0OiBudWxsXHJcbn0pO1xyXG52YXIgZmlsbFN0ciA9IGZ1bmN0aW9uIChzLCBuKSB7IHJldHVybiBBcnJheShNYXRoLmFicyhuKSArIDEpLmpvaW4ocyk7IH07XHJcbnZhciBxVG9BbHQgPSBmdW5jdGlvbiAodHlwZSwgcSkge1xyXG4gICAgaWYgKHEgPT09IFwiTVwiICYmIHR5cGUgPT09IFwiTVwiKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgaWYgKHEgPT09IFwiUFwiICYmIHR5cGUgPT09IFwiUFwiKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgaWYgKHEgPT09IFwibVwiICYmIHR5cGUgPT09IFwiTVwiKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIGlmICgvXkErJC8udGVzdChxKSlcclxuICAgICAgICByZXR1cm4gcS5sZW5ndGg7XHJcbiAgICBpZiAoL15kKyQvLnRlc3QocSkpXHJcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiUFwiID8gLXEubGVuZ3RoIDogLXEubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG52YXIgYWx0VG9RID0gZnVuY3Rpb24gKHR5cGUsIGFsdCkge1xyXG4gICAgaWYgKGFsdCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJNXCIgPyBcIk1cIiA6IFwiUFwiO1xyXG4gICAgZWxzZSBpZiAoYWx0ID09PSAtMSAmJiB0eXBlID09PSBcIk1cIilcclxuICAgICAgICByZXR1cm4gXCJtXCI7XHJcbiAgICBlbHNlIGlmIChhbHQgPiAwKVxyXG4gICAgICAgIHJldHVybiBmaWxsU3RyKFwiQVwiLCBhbHQpO1xyXG4gICAgZWxzZSBpZiAoYWx0IDwgMClcclxuICAgICAgICByZXR1cm4gZmlsbFN0cihcImRcIiwgdHlwZSA9PT0gXCJQXCIgPyBhbHQgOiBhbHQgKyAxKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxufTtcclxudmFyIG51bVRvU3RlcCA9IGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuIChNYXRoLmFicyhudW0pIC0gMSkgJSA3OyB9O1xyXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHZhciB0ID0gdG9rZW5pemUoc3RyKTtcclxuICAgIGlmICh0ID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBOT19JVkw7XHJcbiAgICB2YXIgcCA9IHtcclxuICAgICAgICBudW06IDAsXHJcbiAgICAgICAgcTogXCJkXCIsXHJcbiAgICAgICAgbmFtZTogXCJcIixcclxuICAgICAgICB0eXBlOiBcIk1cIixcclxuICAgICAgICBzdGVwOiAwLFxyXG4gICAgICAgIGRpcjogLTEsXHJcbiAgICAgICAgc2ltcGxlOiAxLFxyXG4gICAgICAgIGFsdDogMCxcclxuICAgICAgICBvY3Q6IDAsXHJcbiAgICAgICAgc2VtaXRvbmVzOiAwLFxyXG4gICAgICAgIGNocm9tYTogMCxcclxuICAgICAgICBpYzogMFxyXG4gICAgfTtcclxuICAgIHAubnVtID0gK3RbMF07XHJcbiAgICBwLnEgPSB0WzFdO1xyXG4gICAgcC5zdGVwID0gbnVtVG9TdGVwKHAubnVtKTtcclxuICAgIHAudHlwZSA9IFRZUEVTW3Auc3RlcF07XHJcbiAgICBpZiAocC50eXBlID09PSBcIk1cIiAmJiBwLnEgPT09IFwiUFwiKVxyXG4gICAgICAgIHJldHVybiBOT19JVkw7XHJcbiAgICBwLm5hbWUgPSBcIlwiICsgcC5udW0gKyBwLnE7XHJcbiAgICBwLmRpciA9IHAubnVtIDwgMCA/IC0xIDogMTtcclxuICAgIHAuc2ltcGxlID0gKHAubnVtID09PSA4IHx8IHAubnVtID09PSAtOFxyXG4gICAgICAgID8gcC5udW1cclxuICAgICAgICA6IHAuZGlyICogKHAuc3RlcCArIDEpKTtcclxuICAgIHAuYWx0ID0gcVRvQWx0KHAudHlwZSwgcC5xKTtcclxuICAgIHAub2N0ID0gTWF0aC5mbG9vcigoTWF0aC5hYnMocC5udW0pIC0gMSkgLyA3KTtcclxuICAgIHAuc2VtaXRvbmVzID0gcC5kaXIgKiAoU0laRVNbcC5zdGVwXSArIHAuYWx0ICsgMTIgKiBwLm9jdCk7XHJcbiAgICBwLmNocm9tYSA9ICgoKChwLmRpciAqIChTSVpFU1twLnN0ZXBdICsgcC5hbHQpKSAlIDEyKSArIDEyKSAlXHJcbiAgICAgICAgMTIpO1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocCk7XHJcbn07XHJcbnZhciBjYWNoZSA9IHt9O1xyXG5mdW5jdGlvbiBwcm9wcyhzdHIpIHtcclxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIHJldHVybiBOT19JVkw7XHJcbiAgICByZXR1cm4gY2FjaGVbc3RyXSB8fCAoY2FjaGVbc3RyXSA9IHByb3BlcnRpZXMoc3RyKSk7XHJcbn1cclxudmFyIG51bSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHByb3BzKHN0cikubnVtOyB9O1xyXG52YXIgbmFtZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHByb3BzKHN0cikubmFtZTsgfTtcclxudmFyIHNlbWl0b25lcyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHByb3BzKHN0cikuc2VtaXRvbmVzOyB9O1xyXG52YXIgY2hyb21hID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gcHJvcHMoc3RyKS5jaHJvbWE7IH07XHJcbnZhciBpYyA9IGZ1bmN0aW9uIChpdmwpIHtcclxuICAgIGlmICh0eXBlb2YgaXZsID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIGl2bCA9IHByb3BzKGl2bCkuY2hyb21hO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBpdmwgPT09IFwibnVtYmVyXCIgPyBDTEFTU0VTW2l2bCAlIDEyXSA6IG51bGw7XHJcbn07XHJcbnZhciBidWlsZCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG51bSA9IF9iLm51bSwgc3RlcCA9IF9iLnN0ZXAsIGFsdCA9IF9iLmFsdCwgX2MgPSBfYi5vY3QsIG9jdCA9IF9jID09PSB2b2lkIDAgPyAxIDogX2MsIGRpciA9IF9iLmRpcjtcclxuICAgIGlmIChzdGVwICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgbnVtID0gc3RlcCArIDEgKyA3ICogb2N0O1xyXG4gICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYgKHR5cGVvZiBhbHQgIT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgZCA9IHR5cGVvZiBkaXIgIT09IFwibnVtYmVyXCIgPyBcIlwiIDogZGlyIDwgMCA/IFwiLVwiIDogXCJcIjtcclxuICAgIHZhciB0eXBlID0gVFlQRVNbbnVtVG9TdGVwKG51bSldO1xyXG4gICAgcmV0dXJuIChkICsgbnVtICsgYWx0VG9RKHR5cGUsIGFsdCkpO1xyXG59O1xyXG52YXIgc2ltcGxpZnkgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICB2YXIgcCA9IHByb3BzKHN0cik7XHJcbiAgICBpZiAocCA9PT0gTk9fSVZMKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgdmFyIGludGVydmFsUHJvcHMgPSBwO1xyXG4gICAgcmV0dXJuIGludGVydmFsUHJvcHMuc2ltcGxlICsgaW50ZXJ2YWxQcm9wcy5xO1xyXG59O1xyXG52YXIgaW52ZXJ0ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgdmFyIHAgPSBwcm9wcyhzdHIpO1xyXG4gICAgaWYgKHAgPT09IE5PX0lWTClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHZhciBpbnRlcnZhbFByb3BzID0gcDtcclxuICAgIHZhciBzdGVwID0gKDcgLSBpbnRlcnZhbFByb3BzLnN0ZXApICUgNztcclxuICAgIHZhciBhbHQgPSBpbnRlcnZhbFByb3BzLnR5cGUgPT09IFwiUFwiID8gLWludGVydmFsUHJvcHMuYWx0IDogLShpbnRlcnZhbFByb3BzLmFsdCArIDEpO1xyXG4gICAgcmV0dXJuIGJ1aWxkKHsgc3RlcDogc3RlcCwgYWx0OiBhbHQsIG9jdDogaW50ZXJ2YWxQcm9wcy5vY3QsIGRpcjogaW50ZXJ2YWxQcm9wcy5kaXIgfSk7XHJcbn07XHJcbnZhciBJTiA9IFsxLCAyLCAyLCAzLCAzLCA0LCA1LCA1LCA2LCA2LCA3LCA3XTtcclxudmFyIElRID0gXCJQIG0gTSBtIE0gUCBkIFAgbSBNIG0gTVwiLnNwbGl0KFwiIFwiKTtcclxudmFyIGZyb21TZW1pdG9uZXMgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICB2YXIgZCA9IG51bSA8IDAgPyAtMSA6IDE7XHJcbiAgICB2YXIgbiA9IE1hdGguYWJzKG51bSk7XHJcbiAgICB2YXIgYyA9IG4gJSAxMjtcclxuICAgIHZhciBvID0gTWF0aC5mbG9vcihuIC8gMTIpO1xyXG4gICAgcmV0dXJuIGQgKiAoSU5bY10gKyA3ICogbykgKyBJUVtjXTtcclxufTtcblxuZXhwb3J0IHsgbmFtZXMsIHRva2VuaXplLCBxVG9BbHQsIGFsdFRvUSwgcHJvcHMsIG51bSwgbmFtZSwgc2VtaXRvbmVzLCBjaHJvbWEsIGljLCBidWlsZCwgc2ltcGxpZnksIGludmVydCwgZnJvbVNlbWl0b25lcyB9O1xuIiwiLyoqXG4gKiBBIG1pZGkgbm90ZSBudW1iZXIgaXMgYSBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgYSBub3RlIHBpdGNoLiBJdCBjYW4gYmVcbiAqIGludGVnZXJzIHNvIGl0J3MgZXF1YWwgdGVtcGVyZWQgdHVuZWQsIG9yIGZsb2F0IHRvIGluZGljYXRlIGl0J3Mgbm90XG4gKiB0dW5lZCBpbnRvIGVxdWFsIHRlbWVwZXJlZCBzY2FsZS5cbiAqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBmdW5jdGlvbnMgdG8gY29udmVydCB0byBhbmQgZnJvbSBtaWRpIG5vdGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbWlkaSA9IHJlcXVpcmUoJ3RvbmFsLW1pZGknKVxuICogbWlkaS50b01pZGkoJ0E0JykgLy8gPT4gNjlcbiAqIG1pZGkubm90ZSg2OSkgLy8gPT4gJ0E0J1xuICogbWlkaS5ub3RlKDYxKSAvLyA9PiAnRGI0J1xuICogbWlkaS5ub3RlKDYxLCB0cnVlKSAvLyA9PiAnQyM0J1xuICpcbiAqIEBtb2R1bGUgbWlkaVxuICovXG5cbmltcG9ydCB7IG1pZGkgfSBmcm9tICdub3RlLXBhcnNlcidcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBub3RlIHRvIGEgbWlkaSBub3RlIG51bWJlci4gSWYgeW91IHBhc3MgYSBtaWRpIG51bWJlciBpdFxuICogd2lsbCByZXR1cm5lZCBhcyBpcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xOdW1iZXJ9IG5vdGUgLSB0aGUgbm90ZSB0byBnZXQgdGhlIG1pZGkgbnVtYmVyIGZyb21cbiAqIEByZXR1cm4ge0ludGVnZXJ9IHRoZSBtaWRpIG51bWJlciBvciBudWxsIGlmIG5vdCB2YWxpZCBwaXRjaFxuICogQGV4YW1wbGVcbiAqIG1pZGkudG9NaWRpKCdDNCcpIC8vID0+IDYwXG4gKiBtaWRpLnRvTWlkaSg2MCkgLy8gPT4gNjBcbiAqIG1pZGkudG9NaWRpKCc2MCcpIC8vID0+IDYwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b01pZGkgKHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDIpIHJldHVybiB2YWxbMF0gKiA3ICsgdmFsWzFdICogMTIgKyAxMlxuICByZXR1cm4gbWlkaSh2YWwpXG59XG5cbnZhciBGTEFUUyA9ICdDIERiIEQgRWIgRSBGIEdiIEcgQWIgQSBCYiBCJy5zcGxpdCgnICcpXG52YXIgU0hBUlBTID0gJ0MgQyMgRCBEIyBFIEYgRiMgRyBHIyBBIEEjIEInLnNwbGl0KCcgJylcblxuLyoqXG4gKiBHaXZlbiBhIG1pZGkgbnVtYmVyLCByZXR1cm5zIGEgbm90ZSBuYW1lLiBUaGUgYWx0ZXJlZCBub3RlcyB3aWxsIGhhdmVcbiAqIGZsYXRzIHVubGVzcyBleHBsaWNpdGx5IHNldCB3aXRoIHRoZSBvcHRpb25hbCBgdXNlU2hhcnBzYCBwYXJhbWV0ZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0ludGVnZXJ9IG1pZGkgLSB0aGUgbWlkaSBub3RlIG51bWJlclxuICogQHBhcmFtIHtCb29sZWFufSB1c2VTaGFycHMgLSAoT3B0aW9uYWwpIHNldCB0byB0cnVlIHRvIHVzZSBzaGFycHMgaW5zdGVhZCBvZiBmbGF0c1xuICogQHJldHVybiB7U3RyaW5nfSB0aGUgbm90ZSBuYW1lXG4gKiBAZXhhbXBsZVxuICogdmFyIG1pZGkgPSByZXF1aXJlKCd0b25hbC1taWRpJylcbiAqIG1pZGkubm90ZSg2MSkgLy8gPT4gJ0RiNCdcbiAqIG1pZGkubm90ZSg2MSwgdHJ1ZSkgLy8gPT4gJ0MjNCdcbiAqIC8vIGl0IHJvdW5kcyB0byBuZWFyZXN0IG5vdGVcbiAqIG1pZGkubm90ZSg2MS43KSAvLyA9PiAnRDQnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RlIChudW0sIHNoYXJwcykge1xuICBpZiAobnVtID09PSB0cnVlIHx8IG51bSA9PT0gZmFsc2UpIHJldHVybiBmdW5jdGlvbiAobSkgeyByZXR1cm4gbm90ZShtLCBudW0pIH1cbiAgbnVtID0gTWF0aC5yb3VuZChudW0pXG4gIHZhciBwY3MgPSBzaGFycHMgPT09IHRydWUgPyBTSEFSUFMgOiBGTEFUU1xuICB2YXIgcGMgPSBwY3NbbnVtICUgMTJdXG4gIHZhciBvID0gTWF0aC5mbG9vcihudW0gLyAxMikgLSAxXG4gIHJldHVybiBwYyArIG9cbn1cbiIsInZhciBOQU1FUyA9IFwiQyBDIyBEYiBEIEQjIEViIEUgRiBGIyBHYiBHIEcjIEFiIEEgQSMgQmIgQlwiLnNwbGl0KFwiIFwiKTtcclxudmFyIG5hbWVzID0gZnVuY3Rpb24gKGFjY1R5cGVzKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFjY1R5cGVzICE9PSBcInN0cmluZ1wiXHJcbiAgICAgICAgPyBOQU1FUy5zbGljZSgpXHJcbiAgICAgICAgOiBOQU1FUy5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgdmFyIGFjYyA9IG5bMV0gfHwgXCIgXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2NUeXBlcy5pbmRleE9mKGFjYykgIT09IC0xO1xyXG4gICAgICAgIH0pO1xyXG59O1xyXG52YXIgU0hBUlBTID0gbmFtZXMoXCIgI1wiKTtcclxudmFyIEZMQVRTID0gbmFtZXMoXCIgYlwiKTtcclxudmFyIFJFR0VYID0gL14oW2EtZ0EtR10/KSgjezEsfXxiezEsfXx4ezEsfXwpKC0/XFxkKilcXHMqKC4qKSQvO1xyXG5mdW5jdGlvbiB0b2tlbml6ZShzdHIpIHtcclxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICB2YXIgbSA9IFJFR0VYLmV4ZWMoc3RyKTtcclxuICAgIHJldHVybiBbbVsxXS50b1VwcGVyQ2FzZSgpLCBtWzJdLnJlcGxhY2UoL3gvZywgXCIjI1wiKSwgbVszXSwgbVs0XV07XHJcbn1cclxudmFyIE5PX05PVEUgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIHBjOiBudWxsLFxyXG4gICAgbmFtZTogbnVsbCxcclxuICAgIHN0ZXA6IG51bGwsXHJcbiAgICBhbHQ6IG51bGwsXHJcbiAgICBvY3Q6IG51bGwsXHJcbiAgICBvY3RTdHI6IG51bGwsXHJcbiAgICBjaHJvbWE6IG51bGwsXHJcbiAgICBtaWRpOiBudWxsLFxyXG4gICAgZnJlcTogbnVsbFxyXG59KTtcclxudmFyIFNFTUkgPSBbMCwgMiwgNCwgNSwgNywgOSwgMTFdO1xyXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHZhciB0b2tlbnMgPSB0b2tlbml6ZShzdHIpO1xyXG4gICAgaWYgKHRva2Vuc1swXSA9PT0gXCJcIiB8fCB0b2tlbnNbM10gIT09IFwiXCIpXHJcbiAgICAgICAgcmV0dXJuIE5PX05PVEU7XHJcbiAgICB2YXIgbGV0dGVyID0gdG9rZW5zWzBdLCBhY2MgPSB0b2tlbnNbMV0sIG9jdFN0ciA9IHRva2Vuc1syXTtcclxuICAgIHZhciBwID0ge1xyXG4gICAgICAgIGxldHRlcjogbGV0dGVyLFxyXG4gICAgICAgIGFjYzogYWNjLFxyXG4gICAgICAgIG9jdFN0cjogb2N0U3RyLFxyXG4gICAgICAgIHBjOiBsZXR0ZXIgKyBhY2MsXHJcbiAgICAgICAgbmFtZTogbGV0dGVyICsgYWNjICsgb2N0U3RyLFxyXG4gICAgICAgIHN0ZXA6IChsZXR0ZXIuY2hhckNvZGVBdCgwKSArIDMpICUgNyxcclxuICAgICAgICBhbHQ6IGFjY1swXSA9PT0gXCJiXCIgPyAtYWNjLmxlbmd0aCA6IGFjYy5sZW5ndGgsXHJcbiAgICAgICAgb2N0OiBvY3RTdHIubGVuZ3RoID8gK29jdFN0ciA6IG51bGwsXHJcbiAgICAgICAgY2hyb21hOiAwLFxyXG4gICAgICAgIG1pZGk6IG51bGwsXHJcbiAgICAgICAgZnJlcTogbnVsbFxyXG4gICAgfTtcclxuICAgIHAuY2hyb21hID0gKFNFTUlbcC5zdGVwXSArIHAuYWx0ICsgMTIwKSAlIDEyO1xyXG4gICAgcC5taWRpID0gcC5vY3QgIT09IG51bGwgPyBTRU1JW3Auc3RlcF0gKyBwLmFsdCArIDEyICogKHAub2N0ICsgMSkgOiBudWxsO1xyXG4gICAgcC5mcmVxID0gbWlkaVRvRnJlcShwLm1pZGkpO1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocCk7XHJcbn07XHJcbnZhciBtZW1vID0gZnVuY3Rpb24gKGZuLCBjYWNoZSkge1xyXG4gICAgaWYgKGNhY2hlID09PSB2b2lkIDApIHsgY2FjaGUgPSB7fTsgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTsgfTtcclxufTtcclxudmFyIHByb3BzID0gbWVtbyhwcm9wZXJ0aWVzKTtcclxudmFyIG5hbWUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBwcm9wcyhzdHIpLm5hbWU7IH07XHJcbnZhciBwYyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHByb3BzKHN0cikucGM7IH07XHJcbnZhciBpc01pZGlSYW5nZSA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtID49IDAgJiYgbSA8PSAxMjc7IH07XHJcbnZhciBtaWRpID0gZnVuY3Rpb24gKG5vdGUpIHtcclxuICAgIGlmICh0eXBlb2Ygbm90ZSAhPT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygbm90ZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pZGkgPSBwcm9wcyhub3RlKS5taWRpO1xyXG4gICAgdmFyIHZhbHVlID0gbWlkaSB8fCBtaWRpID09PSAwID8gbWlkaSA6ICtub3RlO1xyXG4gICAgcmV0dXJuIGlzTWlkaVJhbmdlKHZhbHVlKSA/IHZhbHVlIDogbnVsbDtcclxufTtcclxudmFyIG1pZGlUb0ZyZXEgPSBmdW5jdGlvbiAobWlkaSwgdHVuaW5nKSB7XHJcbiAgICBpZiAodHVuaW5nID09PSB2b2lkIDApIHsgdHVuaW5nID0gNDQwOyB9XHJcbiAgICByZXR1cm4gdHlwZW9mIG1pZGkgPT09IFwibnVtYmVyXCIgPyBNYXRoLnBvdygyLCAobWlkaSAtIDY5KSAvIDEyKSAqIHR1bmluZyA6IG51bGw7XHJcbn07XHJcbnZhciBmcmVxID0gZnVuY3Rpb24gKG5vdGUpIHsgcmV0dXJuIHByb3BzKG5vdGUpLmZyZXEgfHwgbWlkaVRvRnJlcShub3RlKTsgfTtcclxudmFyIEwyID0gTWF0aC5sb2coMik7XHJcbnZhciBMNDQwID0gTWF0aC5sb2coNDQwKTtcclxudmFyIGZyZXFUb01pZGkgPSBmdW5jdGlvbiAoZnJlcSkge1xyXG4gICAgdmFyIHYgPSAoMTIgKiAoTWF0aC5sb2coZnJlcSkgLSBMNDQwKSkgLyBMMiArIDY5O1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodiAqIDEwMCkgLyAxMDA7XHJcbn07XHJcbnZhciBjaHJvbWEgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBwcm9wcyhzdHIpLmNocm9tYTsgfTtcclxudmFyIG9jdCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHByb3BzKHN0cikub2N0OyB9O1xyXG52YXIgTEVUVEVSUyA9IFwiQ0RFRkdBQlwiO1xyXG52YXIgc3RlcFRvTGV0dGVyID0gZnVuY3Rpb24gKHN0ZXApIHsgcmV0dXJuIExFVFRFUlNbc3RlcF07IH07XHJcbnZhciBmaWxsU3RyID0gZnVuY3Rpb24gKHMsIG4pIHsgcmV0dXJuIEFycmF5KG4gKyAxKS5qb2luKHMpOyB9O1xyXG52YXIgbnVtVG9TdHIgPSBmdW5jdGlvbiAobnVtLCBvcCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBudW0gIT09IFwibnVtYmVyXCIgPyBcIlwiIDogb3AobnVtKTtcclxufTtcclxudmFyIGFsdFRvQWNjID0gZnVuY3Rpb24gKGFsdCkge1xyXG4gICAgcmV0dXJuIG51bVRvU3RyKGFsdCwgZnVuY3Rpb24gKGFsdCkgeyByZXR1cm4gKGFsdCA8IDAgPyBmaWxsU3RyKFwiYlwiLCAtYWx0KSA6IGZpbGxTdHIoXCIjXCIsIGFsdCkpOyB9KTtcclxufTtcclxudmFyIGZyb20gPSBmdW5jdGlvbiAoZnJvbVByb3BzLCBiYXNlTm90ZSkge1xyXG4gICAgaWYgKGZyb21Qcm9wcyA9PT0gdm9pZCAwKSB7IGZyb21Qcm9wcyA9IHt9OyB9XHJcbiAgICBpZiAoYmFzZU5vdGUgPT09IHZvaWQgMCkgeyBiYXNlTm90ZSA9IG51bGw7IH1cclxuICAgIHZhciBfYSA9IGJhc2VOb3RlXHJcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyhiYXNlTm90ZSksIGZyb21Qcm9wcylcclxuICAgICAgICA6IGZyb21Qcm9wcywgc3RlcCA9IF9hLnN0ZXAsIGFsdCA9IF9hLmFsdCwgb2N0ID0gX2Eub2N0O1xyXG4gICAgaWYgKHR5cGVvZiBzdGVwICE9PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgdmFyIGxldHRlciA9IHN0ZXBUb0xldHRlcihzdGVwKTtcclxuICAgIGlmICghbGV0dGVyKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgdmFyIHBjID0gbGV0dGVyICsgYWx0VG9BY2MoYWx0KTtcclxuICAgIHJldHVybiBvY3QgfHwgb2N0ID09PSAwID8gcGMgKyBvY3QgOiBwYztcclxufTtcclxudmFyIGJ1aWxkID0gZnJvbTtcclxuZnVuY3Rpb24gZnJvbU1pZGkobnVtLCBzaGFycHMpIHtcclxuICAgIGlmIChzaGFycHMgPT09IHZvaWQgMCkgeyBzaGFycHMgPSBmYWxzZTsgfVxyXG4gICAgbnVtID0gTWF0aC5yb3VuZChudW0pO1xyXG4gICAgdmFyIHBjcyA9IHNoYXJwcyA9PT0gdHJ1ZSA/IFNIQVJQUyA6IEZMQVRTO1xyXG4gICAgdmFyIHBjID0gcGNzW251bSAlIDEyXTtcclxuICAgIHZhciBvID0gTWF0aC5mbG9vcihudW0gLyAxMikgLSAxO1xyXG4gICAgcmV0dXJuIHBjICsgbztcclxufVxyXG52YXIgc2ltcGxpZnkgPSBmdW5jdGlvbiAobm90ZSwgc2FtZUFjYykge1xyXG4gICAgaWYgKHNhbWVBY2MgPT09IHZvaWQgMCkgeyBzYW1lQWNjID0gdHJ1ZTsgfVxyXG4gICAgdmFyIF9hID0gcHJvcHMobm90ZSksIGFsdCA9IF9hLmFsdCwgY2hyb21hID0gX2EuY2hyb21hLCBtaWRpID0gX2EubWlkaTtcclxuICAgIGlmIChjaHJvbWEgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgYWx0ZXJhdGlvbiA9IGFsdDtcclxuICAgIHZhciB1c2VTaGFycHMgPSBzYW1lQWNjID09PSBmYWxzZSA/IGFsdGVyYXRpb24gPCAwIDogYWx0ZXJhdGlvbiA+IDA7XHJcbiAgICByZXR1cm4gbWlkaSA9PT0gbnVsbFxyXG4gICAgICAgID8gcGMoZnJvbU1pZGkoY2hyb21hLCB1c2VTaGFycHMpKVxyXG4gICAgICAgIDogZnJvbU1pZGkobWlkaSwgdXNlU2hhcnBzKTtcclxufTtcclxudmFyIGVuaGFybW9uaWMgPSBmdW5jdGlvbiAobm90ZSkgeyByZXR1cm4gc2ltcGxpZnkobm90ZSwgZmFsc2UpOyB9O1xuXG5leHBvcnQgeyBuYW1lcywgdG9rZW5pemUsIHByb3BzLCBuYW1lLCBwYywgbWlkaSwgbWlkaVRvRnJlcSwgZnJlcSwgZnJlcVRvTWlkaSwgY2hyb21hLCBvY3QsIHN0ZXBUb0xldHRlciwgYWx0VG9BY2MsIGZyb20sIGJ1aWxkLCBmcm9tTWlkaSwgc2ltcGxpZnksIGVuaGFybW9uaWMgfTtcbiIsIi8qKlxuICogWyFbbnBtIHZlcnNpb25dKGh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vbnBtL3YvdG9uYWwtcGNzZXQuc3ZnP3N0eWxlPWZsYXQtc3F1YXJlKV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdG9uYWwtcGNzZXQpXG4gKiBbIVt0b25hbF0oaHR0cHM6Ly9pbWcuc2hpZWxkcy5pby9iYWRnZS90b25hbC1wY3NldC15ZWxsb3cuc3ZnP3N0eWxlPWZsYXQtc3F1YXJlKV0oaHR0cHM6Ly93d3cubnBtanMuY29tL2Jyb3dzZS9rZXl3b3JkL3RvbmFsKVxuICpcbiAqIGB0b25hbC1wY3NldGAgaXMgYSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggcGl0Y2ggY2xhc3Mgc2V0cywgb3JpZW50ZWRcbiAqIHRvIG1ha2UgY29tcGFyYXRpb25zIChpc0VxdWFsLCBpc1N1YnNldCwgaXNTdXBlcnNldClcbiAqXG4gKiBUaGlzIGlzIHBhcnQgb2YgW3RvbmFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS90b25hbCkgbXVzaWMgdGhlb3J5IGxpYnJhcnkuXG4gKlxuICogWW91IGNhbiBpbnN0YWxsIHZpYSBucG06IGBucG0gaSAtLXNhdmUgdG9uYWwtcGNzZXRgXG4gKlxuICogYGBganNcbiAqIC8vIGVzNlxuICogaW1wb3J0IFBjU2V0IGZyb20gXCJ0b25hbC1wY3NldFwiXG4gKiB2YXIgUGNTZXQgPSByZXF1aXJlKFwidG9uYWwtcGNzZXRcIilcbiAqXG4gKiBQY1NldC5pc0VxdWFsKFwiYzIgZDUgZTZcIiwgXCJjNiBlMyBkMVwiKSAvLyA9PiB0cnVlXG4gKiBgYGBcbiAqXG4gKiAjIyBBUEkgZG9jdW1lbnRhdGlvblxuICpcbiAqIEBtb2R1bGUgUGNTZXRcbiAqL1xuaW1wb3J0IHsgY2hyb21hIGFzIG5vdGVjaHIgfSBmcm9tIFwidG9uYWwtbm90ZVwiO1xuaW1wb3J0IHsgY2hyb21hIGFzIGl2bGNociB9IGZyb20gXCJ0b25hbC1pbnRlcnZhbFwiO1xuaW1wb3J0IHsgcm90YXRlLCByYW5nZSwgY29tcGFjdCB9IGZyb20gXCJ0b25hbC1hcnJheVwiO1xuXG52YXIgY2hyID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gbm90ZWNocihzdHIpIHx8IGl2bGNocihzdHIpIHx8IDA7IH07XG52YXIgcGNzZXROdW0gPSBmdW5jdGlvbiAoc2V0KSB7IHJldHVybiBwYXJzZUludChjaHJvbWEoc2V0KSwgMik7IH07XG52YXIgY2xlbiA9IGZ1bmN0aW9uIChjaHJvbWEpIHsgcmV0dXJuIGNocm9tYS5yZXBsYWNlKC8wL2csIFwiXCIpLmxlbmd0aDsgfTtcblxuLyoqXG4gKiBHZXQgY2hyb21hIG9mIGEgcGl0Y2ggY2xhc3Mgc2V0LiBBIGNocm9tYSBpZGVudGlmaWVzIGVhY2ggc2V0IHVuaXF1ZWx5LlxuICogSXRcInMgYSAxMi1kaWdpdCBiaW5hcnkgZWFjaCBwcmVzZW50aW5nIG9uZSBzZW1pdG9uZSBvZiB0aGUgb2N0YXZlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFjY2VwdHMgYSBjaHJvbWEgYXMgcGFyYW1ldGVyIGFuZCByZXR1cm4gaXRcbiAqIHdpdGhvdXQgbW9kaWZpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBzZXQgLSB0aGUgcGl0Y2ggY2xhc3Mgc2V0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwaXRjaCBjbGFzcyBzZXRcbiAqIEBleGFtcGxlXG4gKiBQY1NldC5jaHJvbWEoW1wiQ1wiLCBcIkRcIiwgXCJFXCJdKSAvLyA9PiBcIjEwMTAxMDAwMDAwMDBcIlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hyb21hKHNldCkge1xuICBpZiAoaXNDaHJvbWEoc2V0KSkgeyByZXR1cm4gc2V0OyB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzZXQpKSB7IHJldHVybiBcIlwiOyB9XG4gIHZhciBiID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICBzZXQubWFwKGNocikuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgIGJbaV0gPSAxO1xuICB9KTtcbiAgcmV0dXJuIGIuam9pbihcIlwiKTtcbn1cblxudmFyIGFsbCA9IG51bGw7XG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIHBvc3NpYmxlIGNocm9tYXMgKGFsbCBwb3NzaWJsZSBzY2FsZXMpXG4gKiBNb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vYWxsdGhlc2NhbGVzLm9yZy9cbiAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBwb3NzaWJsZSBjaHJvbWFzIGZyb20gJzEwMDAwMDAwMDAwJyB0byAnMTExMTExMTExMTEnXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hyb21hcyhuKSB7XG4gIGFsbCA9IGFsbCB8fCByYW5nZSgyMDQ4LCA0MDk1KS5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udG9TdHJpbmcoMik7IH0pO1xuICByZXR1cm4gdHlwZW9mIG4gPT09IFwibnVtYmVyXCJcbiAgICA/IGFsbC5maWx0ZXIoZnVuY3Rpb24gKGNocm9tYSkgeyByZXR1cm4gY2xlbihjaHJvbWEpID09PSBuOyB9KVxuICAgIDogYWxsLnNsaWNlKCk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBhIGxpc3Qgb2Ygbm90ZXMgb3IgYSBwY3NldCBjaHJvbWEsIHByb2R1Y2UgdGhlIHJvdGF0aW9uc1xuICogb2YgdGhlIGNocm9tYSBkaXNjYXJkaW5nIHRoZSBvbmVzIHRoYXQgc3RhcnRzIHdpdGggXCIwXCJcbiAqXG4gKiBUaGlzIGlzIHVzZWQsIGZvciBleGFtcGxlLCB0byBnZXQgYWxsIHRoZSBtb2RlcyBvZiBhIHNjYWxlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBzZXQgLSB0aGUgbGlzdCBvZiBub3RlcyBvciBwaXRjaENociBvZiB0aGUgc2V0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IG5vcm1hbGl6ZSAtIChPcHRpb25hbCwgdHJ1ZSBieSBkZWZhdWx0KSByZW1vdmUgYWxsXG4gKiB0aGUgcm90YXRpb25zIHRoYXQgc3RhcnRzIHdpdGggXCIwXCJcbiAqIEByZXR1cm4ge0FycmF5PFN0cmluZz59IGFuIGFycmF5IHdpdGggYWxsIHRoZSBtb2RlcyBvZiB0aGUgY2hyb21hXG4gKlxuICogQGV4YW1wbGVcbiAqIFBjU2V0Lm1vZGVzKFtcIkNcIiwgXCJEXCIsIFwiRVwiXSkubWFwKFBjU2V0LmludGVydmFscylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vZGVzKHNldCwgbm9ybWFsaXplKSB7XG4gIG5vcm1hbGl6ZSA9IG5vcm1hbGl6ZSAhPT0gZmFsc2U7XG4gIHZhciBiaW5hcnkgPSBjaHJvbWEoc2V0KS5zcGxpdChcIlwiKTtcbiAgcmV0dXJuIGNvbXBhY3QoXG4gICAgYmluYXJ5Lm1hcChmdW5jdGlvbihfLCBpKSB7XG4gICAgICB2YXIgciA9IHJvdGF0ZShpLCBiaW5hcnkpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZSAmJiByWzBdID09PSBcIjBcIiA/IG51bGwgOiByLmpvaW4oXCJcIik7XG4gICAgfSlcbiAgKTtcbn1cblxudmFyIFJFR0VYID0gL15bMDFdezEyfSQvO1xuLyoqXG4gKiBUZXN0IGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBwaXRjaCBjbGFzcyBzZXQgY2hyb21hLlxuICogQHBhcmFtIHtzdHJpbmd9IGNocm9tYSAtIHRoZSBwaXRjaCBjbGFzcyBzZXQgY2hyb21hXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGl0cyBhIHZhbGlkIHBjc2V0IGNocm9tYVxuICogQGV4YW1wbGVcbiAqIFBjU2V0LmlzQ2hyb21hKFwiMTAxMDEwMTAxMDEwXCIpIC8vID0+IHRydWVcbiAqIFBjU2V0LmlzQ2hyb21hKFwiMTAxMDAxXCIpIC8vID0+IGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9tYShzZXQpIHtcbiAgcmV0dXJuIFJFR0VYLnRlc3Qoc2V0KTtcbn1cblxudmFyIElWTFMgPSBcIjFQIDJtIDJNIDNtIDNNIDRQIDVkIDVQIDZtIDZNIDdtIDdNXCIuc3BsaXQoXCIgXCIpO1xuLyoqXG4gKiBHaXZlbiBhIHBjc2V0IChub3RlcyBvciBjaHJvbWEpIHJldHVybiBpdFwicyBpbnRlcnZhbHNcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwY3NldCAtIHRoZSBwaXRjaCBjbGFzcyBzZXQgKG5vdGVzIG9yIGNocm9tYSlcbiAqIEByZXR1cm4ge0FycmF5fSBpbnRlcnZhbHMgb3IgZW1wdHkgYXJyYXkgaWYgbm90IHZhbGlkIHBjc2V0XG4gKiBAZXhhbXBsZVxuICogUGNTZXQuaW50ZXJ2YWxzKFwiMTAxMDEwMDAwMDAwMFwiKSA9PiBbXCIxUFwiLCBcIjJNXCIsIFwiM01cIl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVydmFscyhzZXQpIHtcbiAgaWYgKCFpc0Nocm9tYShzZXQpKSB7IHJldHVybiBbXTsgfVxuICByZXR1cm4gY29tcGFjdChcbiAgICBzZXQuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHJldHVybiBkID09PSBcIjFcIiA/IElWTFNbaV0gOiBudWxsO1xuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogVGVzdCBpZiB0d28gcGl0Y2ggY2xhc3Mgc2V0cyBhcmUgaWRlbnRpY2FsXG4gKlxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHNldDEgLSBvbmUgb2YgdGhlIHBpdGNoIGNsYXNzIHNldHNcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBzZXQyIC0gdGhlIG90aGVyIHBpdGNoIGNsYXNzIHNldFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVhbFxuICogQGV4YW1wbGVcbiAqIFBjU2V0LmlzRXF1YWwoW1wiYzJcIiwgXCJkM1wiXSwgW1wiYzVcIiwgXCJkMlwiXSkgLy8gPT4gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChzMSwgczIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgcmV0dXJuIGZ1bmN0aW9uIChzKSB7IHJldHVybiBpc0VxdWFsKHMxLCBzKTsgfTsgfVxuICByZXR1cm4gY2hyb21hKHMxKSA9PT0gY2hyb21hKHMyKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHRlc3QgaWYgYSBjb2xsZWN0aW9uIG9mIG5vdGVzIGlzIGFcbiAqIHN1YnNldCBvZiBhIGdpdmVuIHNldFxuICpcbiAqIFRoZSBmdW5jdGlvbiBjYW4gYmUgcGFydGlhbGx5IGFwcGxpZWRcbiAqXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gc2V0IC0gYW4gYXJyYXkgb2Ygbm90ZXMgb3IgYSBjaHJvbWEgc2V0IHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBub3RlcyAtIGFuIGFycmF5IG9mIG5vdGVzIG9yIGEgY2hyb21hIHNldFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub3RlcyBpcyBhIHN1YnNldCBvZiBzZXQsIGZhbHNlIG90aGVyd2lzZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGluQ01ham9yID0gUGNTZXQuaXNTdWJzZXRPZihbXCJDXCIsIFwiRVwiLCBcIkdcIl0pXG4gKiBpbkNNYWpvcihbXCJlNlwiLCBcImM0XCJdKSAvLyA9PiB0cnVlXG4gKiBpbkNNYWpvcihbXCJlNlwiLCBcImM0XCIsIFwiZDNcIl0pIC8vID0+IGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N1YnNldE9mKHNldCwgbm90ZXMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IHJldHVybiBpc1N1YnNldE9mKHNldCkobm90ZXMpOyB9XG4gIHNldCA9IHBjc2V0TnVtKHNldCk7XG4gIHJldHVybiBmdW5jdGlvbihub3Rlcykge1xuICAgIG5vdGVzID0gcGNzZXROdW0obm90ZXMpO1xuICAgIHJldHVybiBub3RlcyAhPT0gc2V0ICYmIChub3RlcyAmIHNldCkgPT09IG5vdGVzO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgdGVzdCBpZiBhIGNvbGxlY3RpbyBvZiBub3RlcyBpcyBhXG4gKiBzdXBlcnNldCBvZiBhIGdpdmVuIHNldCAoaXQgY29udGFpbnMgYWxsIG5vdGVzIGFuZCBhdCBsZWFzdCBvbmUgbW9yZSlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gc2V0IC0gYW4gYXJyYXkgb2Ygbm90ZXMgb3IgYSBjaHJvbWEgc2V0IHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBub3RlcyAtIGFuIGFycmF5IG9mIG5vdGVzIG9yIGEgY2hyb21hIHNldFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub3RlcyBpcyBhIHN1cGVyc2V0IG9mIHNldCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZXh0ZW5kc0NNYWpvciA9IFBjU2V0LmlzU3VwZXJzZXRPZihbXCJDXCIsIFwiRVwiLCBcIkdcIl0pXG4gKiBleHRlbmRzQ01ham9yKFtcImU2XCIsIFwiYVwiLCBcImM0XCIsIFwiZzJcIl0pIC8vID0+IHRydWVcbiAqIGV4dGVuZHNDTWFqb3IoW1wiYzZcIiwgXCJlNFwiLCBcImczXCJdKSAvLyA9PiBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdXBlcnNldE9mKHNldCwgbm90ZXMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IHJldHVybiBpc1N1cGVyc2V0T2Yoc2V0KShub3Rlcyk7IH1cbiAgc2V0ID0gcGNzZXROdW0oc2V0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgbm90ZXMgPSBwY3NldE51bShub3Rlcyk7XG4gICAgcmV0dXJuIG5vdGVzICE9PSBzZXQgJiYgKG5vdGVzIHwgc2V0KSA9PT0gbm90ZXM7XG4gIH07XG59XG5cbi8qKlxuICogVGVzdCBpZiBhIGdpdmVuIHBpdGNoIGNsYXNzIHNldCBpbmNsdWRlcyBhIG5vdGVcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBzZXQgLSB0aGUgYmFzZSBzZXQgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0ge1N0cmluZ3xQaXRjaH0gbm90ZSAtIHRoZSBub3RlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG5vdGUgaXMgaW5jbHVkZWQgaW4gdGhlIHBjc2V0XG4gKiBAZXhhbXBsZVxuICogUGNTZXQuaW5jbHVkZXMoW1wiQ1wiLCBcIkRcIiwgXCJFXCJdLCBcIkM0XCIpIC8vID0+IHRydWVcbiAqIFBjU2V0LmluY2x1ZGVzKFtcIkNcIiwgXCJEXCIsIFwiRVwiXSwgXCJDIzRcIikgLy8gPT4gZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGVzKHNldCwgbm90ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsgcmV0dXJuIGluY2x1ZGVzKHNldCkobm90ZSk7IH1cbiAgc2V0ID0gY2hyb21hKHNldCk7XG4gIHJldHVybiBmdW5jdGlvbihub3RlKSB7XG4gICAgcmV0dXJuIHNldFtjaHIobm90ZSldID09PSBcIjFcIjtcbiAgfTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgYSBsaXN0IHdpdGggYSBwaXRjaCBjbGFzcyBzZXRcbiAqXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gc2V0IC0gdGhlIHBpdGNoIGNsYXNzIHNldCBub3Rlc1xuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG5vdGVzIC0gdGhlIG5vdGUgbGlzdCB0byBiZSBmaWx0ZXJlZFxuICogQHJldHVybiB7QXJyYXl9IHRoZSBmaWx0ZXJlZCBub3Rlc1xuICpcbiAqIEBleGFtcGxlXG4gKiBQY1NldC5maWx0ZXIoW1wiQ1wiLCBcIkRcIiwgXCJFXCJdLCBbXCJjMlwiLCBcImMjMlwiLCBcImQyXCIsIFwiYzNcIiwgXCJjIzNcIiwgXCJkM1wiXSkgLy8gPT4gWyBcImMyXCIsIFwiZDJcIiwgXCJjM1wiLCBcImQzXCIgXSlcbiAqIFBjU2V0LmZpbHRlcihbXCJDMlwiXSwgW1wiYzJcIiwgXCJjIzJcIiwgXCJkMlwiLCBcImMzXCIsIFwiYyMzXCIsIFwiZDNcIl0pIC8vID0+IFsgXCJjMlwiLCBcImMzXCIgXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihzZXQsIG5vdGVzKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IHJldHVybiBmdW5jdGlvbiAobikgeyByZXR1cm4gZmlsdGVyKHNldCwgbik7IH07IH1cbiAgcmV0dXJuIG5vdGVzLmZpbHRlcihpbmNsdWRlcyhzZXQpKTtcbn1cbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJzb3VyY2VSb290IjoiIn0=